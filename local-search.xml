<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS-系统C函数的hook</title>
    <link href="/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/"/>
    <url>/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/</url>
    
    <content type="html"><![CDATA[<h3 id="fishhook方案"><a href="#fishhook方案" class="headerlink" title="fishhook方案"></a>fishhook方案</h3><p>通过解析<code>bind</code>、<code>lazy_bind</code>、<code>weak_bind</code>可以获取到元组列表，每个元组会告诉我们符号和指针信息，指针信息包括指针位于哪个段以及在段的偏移</p><p>在iOS中，我们使用用变量或类似<code>NSLog()</code>等外部函数并不是直接调用地址，而是在经过bind 或 lazy_bind后才能得到真正的地址。bind或lazy_bind后真正的函数地址记录在 <code>nl_symbol_ptr</code> 或 <code>la_symbol_ptr</code>中，通过符号表可以找到每个函数对应在<code>nl_symbol_ptr</code>或<code>la_symbol_ptr</code>中的地址。fishhook 就是通过查找符号表，找到记录函数指针的地址修改函数指针从而实现C函数的hook。</p><p>bind是在加载镜像的时候就就已经绑定，而lazy_bind是在首次使用时才触发绑定。</p><blockquote><p> lazy_bind是如何实现在首次调用函数时进行bind的呢？</p></blockquote><p>假设张三和李四是同学，老师手里有个名单，这个名单上记录着要参加值日的同学。本来今天应该是李四值日，但是由于打印名单时教务处老师不知道李四的名字，因此打印了班长张三的名字。老师只认名单，因此老师找来张三打扫卫生。但是张三只做了一件事情，就是把名单上的名字改成了李四，并且叫李四来打扫卫生。这样老师以后如果再吩咐打扫卫生的事情时就直接找到了李四。这就是lazy_bind。故事中老师就是我们写的代码，代码只认地址。名单就是<code>la_symbol_ptr</code>，上面记录了值日同学名。张三就是stub机制，它只是起到了辅助作用。而李四则是真正的外部函数，需要真正执行的函数。</p><h3 id="动态库C函数hook"><a href="#动态库C函数hook" class="headerlink" title="动态库C函数hook"></a>动态库C函数hook</h3><p>除了<code>fishhook</code>外，笔者也有一种C函数的静态hook方式，相比于<code>fishhook</code>，此方案不存在耗时的查找比对操作。下面我将介绍这种比较特殊的方案：基于动态库的C函数hook </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dv8sqwtvj20xc0fjmyr.jpg"></p><p><strong>Step1</strong>: 首先在主工程中定义一个同名同参同返回的函数，这样在<code>ld64</code>链接时会认为<code>func1</code>和<code>func2</code> 中用到的<code>NSLog</code>是我们自定义的函数，这样就不会跟系统库的函数进行匹配，<code>NSLog</code>也就不会被标记为需要<code>bind</code>的函数。</p><p><strong>Step2</strong>: 在我们自定义的<code>NSLog</code>内部，我们调用自定义动态库的中间函数<code>MyNSLog</code>，这一步是为了能够调用到真正的<code>NSLog</code></p><p><strong>Step3</strong>: 由于动态库中我们没有自定义<code>NSLog</code>去“欺骗”ld64，因此动态中的<code>NSLog</code>会去调用真正的系统函数。</p><p>到这里可能有同学会问，“难道动态库的<code>NSLog</code>不存在重新调用到主程序的<code>NSLog</code>函数的风险吗？那样岂不是会死循环？”</p><p>不会的。因为动态库是具备编译和链接过程的产物。经过链接时，在二进制文件中就已经写定了<code>NSLog</code>  <code>bind</code>到系统库中的<code>NSLog</code>了，因此在启动阶段<code>dyld</code>不会“违抗”二进制的命令执行到主程序的<code>NSLog</code>。</p><p>但是由于侵入性较强，仅对部分需要<strong>同步启动</strong>用到的函数使用。<code>fishhook</code> 还是项目中最主要的使用方式。</p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</title>
    <link href="/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <url>/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化"><a href="#dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化" class="headerlink" title="dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化"></a>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</h3><p>dyld 是动态加载器，它主要用于动态库的链接和程序启动加载工作，它目前有两个主要版本：dyld 2 和 dyld 3。</p><p><strong>dyld 2</strong></p><p><a href="https://github.com/opensource-apple/dyld/tree/master/src" title="dyld开源地址">dyld2</a> 从 iOS 3.1 开始引入，一直到 iOS 12 被 dyld 3 全面代替。它经过了很多次版本迭代，我们现在常见的特性比如 ASLR，Code Sign，Shared Cache 等技术，都是在 dyld 2 中引入的。dyld 2 的执行流程是这样的：</p><p><img src="http://cdn.zhangferry.com/Images/20220104235847.png"></p><ul><li>解析 <code>mach-o</code> 头文件，找到依赖库，依赖库又可能有别的依赖，这里会进行递归分析，直到获得所有 dylib 的完整图。这里数据庞大，需要进行大量的处理；</li><li>映射所有 <code>mach-o</code> 文件，将它们放入地址空间；</li><li>执行符号查找，若你的程序使用 <code>printf</code> 函数，将会查找 <code>printf</code> 是否在库系统中，然后我们找到它的地址，将它复制到你的程序中的函数指针上；</li><li>进行 bind 和 rebase，修复内部和外部指针；</li><li>运行一些初始化任务，像是加载 category、load 方法等；</li><li>执行 main；</li></ul><p><strong>dyld 3</strong></p><p>dyld 3 在 2017 年就被引入至 iOS 11，当时主要用来优化系统库。现在，在 iOS 13 中它也将用于启动第三方 APP，完全替代 dyld 2。</p><p>dyld 3 最大的特点就是引入了启动闭包，闭包里包含了启动所需要的缓存信息，而且这个闭包在进程外就完成了。在打开 APP 时，实际上已经有不少工作都完成了，这会使 dyld 的执行更快。</p><p>最重要的特性就是启动闭包，闭包里包含了启动所需要的缓存信息，从而提高启动速度。下图是 dyld 2 和 dyld 3 的执行步骤对比：</p><p><img src="http://cdn.zhangferry.com/Images/20220105001119.png"></p><p>dyld 3 的执行步骤分两大步，以图中虚线隔开，虚线以上进程外执行，以下进程创建时执行：</p><ul><li>前 3 步查找依赖和符号相对耗时，且涉及一些安全问题，所以将这些信息做成缓存闭包写入磁盘里，对应地址：<code>tmp/com.apple.dyld</code>。闭包会在重启手机&#x2F;更新&#x2F;下载 App 的首启等时机创建。</li><li>进程启动时，读取闭包并验证闭包有效性。</li><li>后面步骤同 dyld 2</li></ul><h3 id="iOS-15-的LC-DYLD-CHAINED-FIXUPS"><a href="#iOS-15-的LC-DYLD-CHAINED-FIXUPS" class="headerlink" title="iOS 15 的LC_DYLD_CHAINED_FIXUPS"></a>iOS 15 的LC_DYLD_CHAINED_FIXUPS</h3><p>在iOS15 上，APP的<code>rebase</code> &amp; <code>bind</code> 的方式发生了变化。</p><p>如果我们将<code>iOS Deployment Target</code>设置为15的话，通过<code>MachOView</code>查看打包后的Mach-O文件会发现新的二进制上出现了不支持的LC。</p><p><img src="https://upload-images.jianshu.io/upload_images/4642217-76d3f18e9cc92b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/830/format/webp" alt="img"></p><p>这是由于<code>LC_DYLD_INFO_ONLY</code>被替换成了新增的<code>LC_DYLD_EXPORTS_TRIE</code>和<code>LC_DYLD_CHAINED_FIXUPS</code>。</p><p>文件的变化意味着iOS 15的<code>rebase</code>和<code>bind</code>机制发生了变化。回顾iOS 14及以前，<code>dyld</code>是通过解析压缩字节流实现了<code>rebase</code>和<code>bind</code>。解析压缩字节会告诉<code>dyld</code> 整个二进制文件中有哪些地址需要修正，以及在<code>bind</code>时每个地址是为哪个外部符号预留。那iOS 15 <code>dyld</code>是如何进行过修正的呢？接下来我们探索下<code>dyld</code>。</p><p> 前段时间听到有同学讨论iOS 15 <code>dyld3</code> 更新为<code>dyld4</code>了。笔者无法确定苹果是否偷偷地升级了<code>dyld</code>，但是从蛛丝马迹中可以看出来<code>dyld</code> 确实是有变化，例如在<code>instrument</code> 中我们可以看到部分函数的命名空间变成了<code>dyld4</code>。还有就是一些API的调用上发生了一些变化，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">let header:UnsafePointer<span class="hljs-tag">&lt;<span class="hljs-name">mach_header</span>&gt;</span> = _dyld_get_image_header(0)<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在iOS 15系统之前通过索引获取<code>header</code>时，如果<code>index == 0</code>，返回的是可执行程序的<code>header</code>。但是在iOS 15中，<code>index == 0</code>获取到的却是系统库。当然这些变化对我们的业务代码可能还不足以产生影响，但是可以说明<code>dyld</code> 确定是有改动。那<code>LC_DYLD_CHAINED_FIXUPS</code>是<code>dyld</code>的新特性吗？我的答案是否定的。因为从<code>dyld3</code>的<code>dyld-852.2</code>版本中可以看到<code>LC_DYLD_CHAINED_FIXUPS</code>早就预埋在dyld中了，只不过在<code>iOS Deployment Target == 15</code>时引起Mach-O文件变化后，才能进入相应的代码分支。</p><h3 id="iOS15上如何让你的应用启动更快？"><a href="#iOS15上如何让你的应用启动更快？" class="headerlink" title="iOS15上如何让你的应用启动更快？"></a>iOS15上如何让你的应用启动更快？</h3><p>在iOS 15中，原本用于rebase &amp; bind 的压缩字节流被替换，取而代之的是fixup-chains(链表结构)。在iOS 启动时，dyld 先判断是否存在fixup-chains，如果存在fixup-chains 则按照fixup-chains的方式进行解析，否则还是按照压缩字节流的方式解析。解析的目的是为了将应用程序的地址进行修正。fixup-chains 机制是由三层结构进行存储，分别是segment（段）-&gt; pages(页) -&gt; fixup-chains(指针链表) 组成。LC_DYLD_CHAINED_FIXUPS所指向的数据会告诉我们有多少segments，每个segment的信息又会告诉我们这个segment有多少pages，以及每个page 的fixup-chains在哪里。 而 fixup-chains中的指针指向了当前page中每一个需要rebase 或者 bind的地址，这些地址中存储的数据并非像iOS 15之前那样都是0x00，而是有一定格式的具有一定意义的8字节数据。而这短短的8字节数据被按照不同的结构体拆分成多个bit，每个或连续几个bit都具有其特殊的含义用于推断rebase 或 bind 所需要的一切信息。iOS 15废除了lazy_bind(weak_bind仍然保留)，由于rebase和bind 被整合为一个链表，因此遍历一次链表即可完成一个page所需的rebase和bind。</p><p><strong>那fixup-chains为什么能加快启动呢？</strong></p><p>因为在iOS 15以前，rebase和bind的信息在压缩字节流中是分别存储的。这就意味着，在启动时dyld在做rebase时会先遍历一遍rebase压缩字节流所记录的地址进行地址修改，假设为N次page fault，由于经过rebase 的page 是被写入数据的dirty page，因此不会被释放，iOS 会通过压缩的方式优化最近没有使用到的dirty page。然后在进行bind时，又遍历bind压缩字节流所记录的那些地址进行修改，假设需要bind M个page。那么在N和M这两个Pages集合中可能存在很多重叠，这就造成了二次遍历，并且iOS可能对其中某些dirty page做了压缩优化。在这种情况下，bind时就需要对这些重叠的pages做解压操作。而fixup-chains很巧妙地解决了这个问题，因为同一个page的rebase和bind整合成一个链表，同时进行这两种操作，这样就不会存在重复遍历相同的page，也不会存在解压的问题。</p><p><strong>疑问</strong></p><p>fixup-chains 会减少page falut次数吗？：不会，依旧是<code>M</code> ∪<code>N</code></p><p>有人问这个算不算iOS 帮我们做了二进制重排？：完全是两回事。虽然都提到了page fault，但是阶段是不同的。</p><p><a href="https://easeapi.com/blog/blog/83-ios13-dyld3.html" title="iOS 13中dyld 3的改进和优化">iOS 13中dyld 3的改进和优化</a></p><p><a href="https://www.yotrolz.com/posts/c2aae680/" title="iOS dyld 前世今生">iOS dyld 前世今生</a></p><p><a href="https://www.jianshu.com/p/6ff72443377b">从野指针探测到对iOS 15 bind 的探索</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift-weak的实现</title>
    <link href="/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在Swift中, <code>SideTable</code> 是针对有需要的对象而创建，系统会为目标对象分配一块新的内存来保存该对象额外的信息。 因为这不是对象必须的内容，所以这个 <code>SideTable</code> 可有可无。对象会有一个指向 <code>SideTable</code> 的指针，同时 <code>SideTable</code> 也有一个指回原对象的指针。在实现上为了不额外多占用内存，目前只有在创建弱引用时，会先把对象的引用计数放到新创建的 <code>SideTable</code> 去，再把空出来的空间存放 <code>SideTable</code> 的地址，会通过一个标志位来区分对象是否有 <code>SideTable</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JYObject</span>&#123;<br>    <span class="hljs-keyword">var</span> age :<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;JY&quot;</span><br>&#125;<br> <br>  <span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">JYObject</span>()<br>    <br>  <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> t2 <span class="hljs-operator">=</span> t<br>    <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们在<code>print</code>处打上断点，查看t2对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">(lldb) po t2<br>▿ Optional&lt;JYObject&gt;<br>  ▿ some : &lt;JYObject: <span class="hljs-number">0x6000001a9710</span>&gt;<br><br>(lldb) x/<span class="hljs-number">8</span>gx  <span class="hljs-number">0x6000001a9710</span><br><span class="hljs-number">0x6000001a9710</span>: <span class="hljs-number">0x0000000100491e18</span> <span class="hljs-number">0xc0000c00001f03dc</span><br><span class="hljs-number">0x6000001a9720</span>: <span class="hljs-number">0x0000000000000012</span> <span class="hljs-number">0x000000000000594a</span><br><span class="hljs-number">0x6000001a9730</span>: <span class="hljs-number">0xe200000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000001a9740</span>: <span class="hljs-number">0x00007efd22b59740</span> <span class="hljs-number">0x000000000000009c</span><br>(lldb) <br></code></pre></td></tr></table></figure><p>通过查看汇编，定义了一个<code>weak</code>变量，编译器自动调用了<code>swift_weakInit</code>函数，这个函数是由<code>WeakReference</code>调用的。说明<code>weak</code>字段在编译器声明的过程当中自动生成了<code>WeakReference</code>对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">WeakReference *<span class="hljs-title">swift::swift_weakInit</span><span class="hljs-params">(WeakReference *ref, HeapObject *value)</span> </span>&#123;<br>  ref-&gt;<span class="hljs-built_in">nativeInit</span>(value);<br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">(HeapObject *object)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = object ? object-&gt;refCounts.formWeakReference() : <span class="hljs-literal">nullptr</span>;<br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">WeakReferenceBits</span>(side), std::memory_order_relaxed);<br>  &#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::formWeakReference()<br>&#123;<br>    <span class="hljs-comment">// 创建一个 Side Table</span><br>  <span class="hljs-keyword">auto</span> side = <span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (side)<br>      <span class="hljs-comment">// 增加一个弱引用</span><br>    <span class="hljs-keyword">return</span> side-&gt;<span class="hljs-built_in">incrementWeak</span>();<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 我们来看一下<code>allocateSideTable</code>方法，是如何创建一个<code>Side Table</code>的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::<span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-type">bool</span> failIfDeiniting)<br>&#123;<br>  <span class="hljs-comment">//1.拿到原有的引用计数</span><br>  <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>  <br>  <span class="hljs-comment">// 判断是否有SideTable，</span><br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>    <span class="hljs-comment">// Already have a side table. Return it.</span><br>    <span class="hljs-keyword">return</span> oldbits.<span class="hljs-built_in">getSideTable</span>();<br>  &#125; <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>    <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Preflight passed. Allocate a side table.</span><br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> custom side table allocator</span><br> <br>  <span class="hljs-comment">//2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象</span><br>  HeapObjectSideTableEntry *side = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HeapObjectSideTableEntry</span>(<span class="hljs-built_in">getHeapObject</span>());<br> <br>  <span class="hljs-comment">//3.将创建的实例对象地址给了InlineRefCountBits，也就是 RefCountBitsT</span><br>  <span class="hljs-keyword">auto</span> newbits = <span class="hljs-built_in">InlineRefCountBits</span>(side);<br>  <br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>      <span class="hljs-comment">// Already have a side table. Return it and delete ours.</span><br>      <span class="hljs-comment">// Read before delete to streamline barriers.</span><br>      <span class="hljs-keyword">auto</span> result = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>      <span class="hljs-keyword">delete</span> side;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>      <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>     <br>    <span class="hljs-comment">// 将原有的引用计数存储</span><br>    side-&gt;<span class="hljs-built_in">initRefCounts</span>(oldbits);<br>     <br>  &#125; <span class="hljs-keyword">while</span> (! refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                             std::memory_order_release,<br>                                             std::memory_order_relaxed));<br>  <span class="hljs-keyword">return</span> side;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结一下上面所做的事情</p><p>1.拿到原有的引用计数<br>2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象<br>3.将创建的实例对象地址给了<code>InlineRefCountBits</code>，也就是 RefCountBitsT。</p></blockquote><p>构造完 <code>Side Table</code> 以后，对象中的 <code>RefCountBitsT</code> 就不是原来的引用计数了，而是一个指向 <code>Side Table</code> 的指针，然而由于它们实际都是 <code>uint64_t</code>，因此需要一个方法来区分。区分的方法我们可以来看 <code>InlineRefCountBits</code> 的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//弱引用</span><br><span class="hljs-function">LLVM_ATTRIBUTE_ALWAYS_INLINE</span><br><span class="hljs-function">  <span class="hljs-title">RefCountBitsT</span><span class="hljs-params">(HeapObjectSideTableEntry* side)</span></span><br><span class="hljs-function">    : bits((reinterpret_cast&lt;BitsType&gt;(side) &gt;&gt; Offsets::SideTableUnusedLowBits)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::UseSlowRCShift)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::SideTableMarkShift))</span><br><span class="hljs-function">  &#123;</span><br>    <span class="hljs-built_in">assert</span>(refcountIsInline);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在弱引用方法中把创建出来的地址做了偏移操作然后存放到了内存当中。</p><p><code>SideTableUnusedLowBits</code> &#x3D; 3，所以，在这个过程中，传进来的<code>side</code>往右移了 3 位，下面的两个是 62 位和 63 位标记成 1</p></blockquote><p>我们接着来看一下 <code>HeapObjectSideTableEntry</code> 的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapObjectSideTableEntry</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> does object need to be atomic?</span><br>  std::atomic&lt;HeapObject*&gt; object;<br>  SideTableRefCounts refCounts;<br><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HeapObjectSideTableEntry</span>(HeapObject *newObject)<br>    : <span class="hljs-built_in">object</span>(newObject), <span class="hljs-built_in">refCounts</span>()<br>  &#123; &#125;<br></code></pre></td></tr></table></figure><p>我们来尝试还原一下 拿到弱引用计数 </p><p><code>0xc0000c00001f03dc</code>62位和63位清0得到 <code>HeapObjectSideTableEntry</code> 实例对象的地址<code>0xC00001F03DC</code></p><p>它既然是右移 3 位，那么我左移 3 位把它还原，<code>HeapObjectSideTableEntry</code>左移三位 得到<code>0x10062AFE0</code></p><p><img src="https://gitee.com/zhangferry/Images/raw/master/iOSWeeklyLearning/20220302155825.png"></p><ul><li><code>0x6000001a9710</code> 就是实例对象的地址。</li><li><code>0x0000000000000002</code>就是弱引用计数。<br>这里弱引用为<code>2</code>的原因是因为<code>SideTableRefCountBits</code>初始化的时候从<code>1</code>开始.</li></ul><p> <code>Side Table</code>的生命周期与对象是分离的，当强引用计数为 0 时，只有 <code>HeapObject</code> 被释放了，并没有释放<code>Side Table</code>，只有所有的 <code>weak</code> 引用者都被释放了或相关变量被置 <code>nil</code> 后，<code>Side Table</code> 才能得以释放</p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-编译过程梳理</title>
    <link href="/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-编译过程梳理"><a href="#iOS-编译过程梳理" class="headerlink" title="iOS 编译过程梳理"></a>iOS 编译过程梳理</h1><p>编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率很高。</p><h2 id="编译器的概述"><a href="#编译器的概述" class="headerlink" title="编译器的概述"></a>编译器的概述</h2><p>编译器的作用是把我们的高级语言转换成机器可以识别的机器码，经典的设计结构如下：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dwrp77ruj20ki03z0sn.jpg"></p><ul><li>前端（Frontend）：语法分析，语义分析和生成中间代码。在这个过程中，也会对代码进行检查，如果发现出错的或需要警告的会标注出来。</li><li>优化器（Optimizer）：会进行 BitCode 的生成，链接期优化等工作。</li><li>后端（Backend）：针对不同的架构，生成对应的机器码。</li></ul><h2 id="Clang-LLVM-的编译过程"><a href="#Clang-LLVM-的编译过程" class="headerlink" title="Clang + LLVM 的编译过程"></a>Clang + LLVM 的编译过程</h2><ol><li><strong>预处理阶段</strong>：import 头文件替换；macro 宏展开；处理预编译指令</li><li><strong>词法分析</strong>：预处理完成后进入词法分析，将输入的代码转化为一系列符合特定语言的词法单元（token 流）。</li><li><strong>语法分析</strong>：将词法分析得到的 token 流进行语法静态分析（Static Analysis），输出<strong>抽象语法树（AST）</strong>，过程中会校验语法是否错误。</li><li><strong>CodeGen 生成 IR 中间代码</strong>：CodeGen 负责将语法树自顶向下遍历翻译成 <code>LLVM IR</code>，<code>IR</code> 是编译过程中前端的输出后端的输入。</li><li><strong>Optimize 优化 IR</strong>：到这里 LLVM 会做一些优化工作，在 Xcode 的编译设置里可以设置优化级别 -01, -03, -0s，也可以写自己的 Pass，Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。附件：<a href="http://llvm.org/docs/WritingAnLLVMPass.html">官方 Pass 教程</a>。</li><li><strong>LLVM Bitcode 生成字节码</strong>：如果开启了 bitcode，苹果会做进一步优化。若有新的后端架构，依旧可以用这份优化过的 bitcode 去生成。</li><li><strong>生成汇编</strong></li><li><strong>生成目标文件</strong></li><li><strong>生成可执行文件</strong></li></ol><h2 id="Xcode-Build-的流程"><a href="#Xcode-Build-的流程" class="headerlink" title="Xcode Build 的流程"></a>Xcode Build 的流程</h2><p>我们在 Xcode 中使用 <strong>Command + B</strong> 或 <strong>Command + R</strong> 时，即完成了一次编译，来看下这个过程做了哪些事情。</p><p>编译过程分为四个步骤：</p><ul><li>预编译（Pre-process）：宏替换、删除注释、展开头文件，产生 .i 文件。</li><li>编译（Compliling）：把前面生成的 .i 文件转化为汇编语言，产生 .s 文件。</li><li>汇编（Asembly）：把汇编语言 .s 文件转化为机器码文件，产生 .0 文件。</li><li>链接（Link）：对 .o 文件中的对于其他库的引用的地方进行引用，生成最后的可执行文件。也包括多个 .o 文件进行 link。</li></ul><p>通过解析 Xcode 编译 log，可以发现 Xcode 是根据 Target 进行编译的。我们可以通过 Xcode 中的 Build Phases、Build Settings 及 Build Rules 来控制编译过程。</p><ul><li>Build Settings：这一栏下是对编译的细节进行设定，包含 build 过程的每个阶段的设置选项（包含编译、链接、代码签名、打包）。</li><li>Build Phases：用于控制从源文件到可执行文件的整个过程，如编译哪些文件，编译过程中执行哪些自定义脚本。例如 CocoaPods 在这里会进行相关配置。</li><li>Build Rules：指定了不同的文件类型该如何编译。一般我们不需要修改这里的内容。如果需要对特定类型的文件添加处理方法，可以在这里添加规则。</li></ul><p>每个 Target 的具体编译过程也可以通过 log 日志获得。大致过程为：</p><ul><li>编译信息写入辅助文件（如Entitlements.plist），创建编译后的文件架构</li><li>写入辅助信息（.hmap 文件）。将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件。</li><li>运行预设的脚本。如 Cocoapods 会在 Build Phases 中预设一些脚本（CheckPods Manifest.lock）。</li><li>编译 .m 文件，生成可执行文件 Mach-O。每次进行了 LLVM 的完整流程：前端（词法分析 - 语法分析 - 生成 IR）、优化器（优化 IR）、后端（生成汇编 - 生成目标文件 - 生成可执行文件）。使用 <code>CompileC</code> 和 <code>clang</code> 命令。 CompileC 是 xcodebuild 内部函数的日志记录表示形式，它是 build.log 文件中有关编译的基本信息来源。</li><li>链接需要的库。如 Foundation.framework，AFNetworking.framework…</li><li>拷贝资源文件到目标包</li><li>编译 storyboard 文件</li><li>链接 storyboard 文件</li><li>编译 Asset 文件。如果使用 Asset.xcassets 来管理图片，这些图片会被编译为机器码，除了 icon 和 launchIamge。</li><li>处理 infoplist</li><li>执行 CocoaPods 脚本，将在编译项目前已编译好的依赖库和相关资源拷贝到包中。</li><li>拷贝 Swift 标准库</li><li>创建 .app 文件并对其签名</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-线程数量监控</title>
    <link href="/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/"/>
    <url>/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<p>在iOS开发中，我们会经常开辟新的线程去做一些事，如何合理的开辟线程，在App开发阶段，监控线程的开辟数量，避免线上发生意外情况。 </p><p>当线程过多或瞬间创建大量子线程(线程爆炸)，就在控制台打印信息，并记录信息。</p><ol><li><p>创建子线程过多，是会造成性能问题的，因为创建线程需要占用内存空间（默认的情况下，主线程占1M,子线程占用512KB）。</p></li><li><p>不合理创建和使用线程，容易引发数据一致性（线程安全）和死锁问题。</p></li></ol><p>因为在iOS中基本上都是使用的<code>p_thread</code>，在<code>Mach</code>层中<code>thread_basic_info</code> 结构体封装了单个线程的基本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">struct thread_basic_info &#123;<br>    time_value_t  user_time;      /* user run time */<br>    time_value_t  system_time;    /* system run time */<br>    integer_t    cpu_usage;       /* scaled cpu usage percentage */<br>    policy_t     policy;          /* scheduling policy in effect */<br>    integer_t    run_state;       /* run state (see below) */<br>    integer_t    flags;           /* various flags (see below) */<br>    integer_t    suspend_count;   /* suspend count for thread */<br>    integer_t    sleep_time;      /* number of seconds that thread  has been sleeping */<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<code>Mach Task</code>包含它的线程列表。内核提供了<code>task_threads</code> API 调用获取指定 task 的线程列表，然后可以通过<code>thread_info</code> API调用来查询指定线程的信息，在 thread_act.h 中有相关定义。</p><p><code>task_threads</code> 将<code>target_task</code> 任务中的所有线程保存在<code>act_list</code>数组中，act_listCnt表示线程个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">kern_return_t task_threads<br>(<br>    task_t target_task,<br>    thread_act_array_t *act_list,<br>    mach_msg_type_number_t *act_listCnt<br>);<br></code></pre></td></tr></table></figure><p> <code>thread_info</code>结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">kern_return_t</span> <span class="hljs-title">thread_info</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_act_t</span> target_act,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_flavor_t</span> flavor,  <span class="hljs-comment">// 传入不同的宏定义获取不同的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_info_t</span> thread_info_out,  <span class="hljs-comment">// 查询到的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">mach_msg_type_number_t</span> *thread_info_outCnt  <span class="hljs-comment">// 信息的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p> 如果频繁调用<code>task_threads</code>函数，来获取线程数量和增长速度，大量调用这个函数会造成一定的性能问题</p><p>通过<code>hook</code>线程的创建和销毁，来监听线程的数量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//在#include &lt;pthread/introspection.h&gt;文件里</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">定义函数指针：pthread_introspection_hook_t</span><br><span class="hljs-comment">event  : 线程处于的生命周期（下面枚举了线程的4个生命周期）</span><br><span class="hljs-comment">thread ：线程</span><br><span class="hljs-comment">addr   ：线程栈内存基址</span><br><span class="hljs-comment">size   ：线程栈内存可用大小</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">pthread_introspection_hook_t</span>)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> event,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-keyword">enum</span> &#123;<br>PTHREAD_INTROSPECTION_THREAD_CREATE = <span class="hljs-number">1</span>, <span class="hljs-comment">//创建线程</span><br>PTHREAD_INTROSPECTION_THREAD_START, <span class="hljs-comment">// 线程开始运行</span><br>PTHREAD_INTROSPECTION_THREAD_TERMINATE,  <span class="hljs-comment">//线程运行终止</span><br>PTHREAD_INTROSPECTION_THREAD_DESTROY, <span class="hljs-comment">//销毁线程</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">看这个函数名，很像我们平时hook函数一样的。</span><br><span class="hljs-comment">返回值是上面声明的pthread_introspection_hook_t函数指针：返回原线程生命周期函数。</span><br><span class="hljs-comment">参数也是函数指针：传入的是我们自定义的线程生命周期函数</span><br><span class="hljs-comment">*/</span><br>__attribute__((__nonnull__, __warn_unused_result__))<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">pthread_introspection_hook_t</span></span><br><span class="hljs-function"><span class="hljs-title">pthread_introspection_hook_install</span><span class="hljs-params">(<span class="hljs-type">pthread_introspection_hook_t</span> hook)</span></span>;<br><br></code></pre></td></tr></table></figure><h4 id="下面开始写一个Monitor"><a href="#下面开始写一个Monitor" class="headerlink" title="下面开始写一个Monitor"></a>下面开始写一个<code>Monitor</code></h4><p>先来定义一些参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static pthread_introspection_hook_t original_pthread_introspection_hook_t = NULL;<br><br>/// 创建信号量<br>static dispatch_semaphore_t semaphore;<br><br>/// 线程总数<br>static int threadCount = 0;<br><br>/// 是否开启监控<br>static bool isMonitor = false;<br><br>/// 线程总数阈值<br>static int averageThreadCount = 40;<br><br>/// 线程在一定时间内新增数<br>static int newThreadCount = 0;<br><br>/// 线程在一定时间内新增阈值<br>static int newAverageThreadCount = 10;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 开启监控<br>+ (void)startMonitor&#123;<br>    // 创建信号量 最大并发数为1<br>    semaphore = dispatch_semaphore_create(1);<br>    // 等待<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <br>    mach_msg_type_number_t count;<br>    thread_act_array_t threads;<br>    // 获取到count<br>    task_threads(mach_task_self(), &amp;threads, &amp;count);<br>   <br>    // 保证加锁的时候，线程数量不变<br>    threadCount = count;<br>    <br>    // 添加🪝钩子函数<br>    original_pthread_introspection_hook_t = pthread_introspection_hook_install(kry_pthread_introspection_hook_t);<br>    <br>    // 解锁 信号量+1<br>    dispatch_semaphore_signal(semaphore);<br>    <br>    // 开始监控<br>    isMonitor = true;<br>    <br>    <br>    // 开启一个定时器 检测每秒线程创建 然后通过clearNewThreadCount置位0<br>    const char *queenIdentifier = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);<br>    if (queenIdentifier == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>    &#125;else&#123;<br>        dispatch_async(dispatch_get_main_queue(), ^&#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>        &#125;);<br>    &#125;<br>&#125;<br><br>// 当前线程总数<br>+ (int)currentThreadCount&#123;<br>    return threadCount;<br>&#125;<br><br>void kry_pthread_introspection_hook_t(unsigned int event,<br>                                      pthread_t thread, void *addr, size_t size)&#123;<br>    <br>    // 正常调用原有逻辑<br>    if (original_pthread_introspection_hook_t) &#123;<br>        original_pthread_introspection_hook_t(event,thread,addr,size);<br>    &#125;<br>    <br>    // 开始记录<br>    <br>    // 如果是创建线程,则线程的数量+1，新增数+1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) &#123;<br>        threadCount +=1;<br>        if (isMonitor &amp;&amp; threadCount &gt; averageThreadCount) &#123;<br>            // 总数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(false, 0);<br>        &#125;<br>        <br>        newThreadCount +=1;<br>        if (isMonitor &amp;&amp; newThreadCount &gt; newAverageThreadCount) &#123;<br>            // 新增数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(true, newThreadCount);<br>        &#125;<br>    &#125;<br>    <br>    <br>    // 销毁线程，则线程数量-1，新增数-1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_DESTROY) &#123;<br>        threadCount -=1;<br>       <br>        if (newThreadCount &gt; 0 ) &#123;<br>            newThreadCount -=1;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><br>void kry_Log_CallStack(bool isIncreaseLog, int num)<br>&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    if (isIncreaseLog) &#123;<br>        printf(&quot;\n🔥一秒钟开启 %d 条线程！！！！\n&quot;, num);<br>    &#125;<br>    // 可以记录堆栈信息<br>    dispatch_semaphore_signal(semaphore);<br>&#125;<br><br>+ (void)clearNewThreadCount&#123;<br>    newThreadCount = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，都有注释，近期在看PCL的堆栈记录，后期会把堆栈记录完善上去</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.jianshu.com/p/95df83780c8f">APP性能检测方案汇总</a></p><p><a href="https://juejin.cn/post/6844904122248855560">iOS线程数量监控工具</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-夜间模式框架</title>
    <link href="/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>iOS夜间模式的适配，主要用到了<code>NSProxy</code>转发原理 ，其中JYDynamicColor继承于UIColor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColor : UIColor<br><br>@property (nonatomic, readonly) UIColor * lightColor;<br><br>@property (nonatomic, readonly) UIColor * darkColor;<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider;<br><br>@end<br></code></pre></td></tr></table></figure><p>  但是在.m文件中,我们实际将消息给了JYDynamicColorProxy处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYDynamicColor<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor &#123;<br>  return [self colorWithDynamicProvider:^(JYTraitCollection *traitCollection)&#123;<br>    return traitCollection.userInterfaceStyle == JYInterfaceStyleDark ? darkColor : lightColor;<br>  &#125;];<br>&#125;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * _Nonnull (^)(JYTraitCollection * _Nonnull))dynamicProvider &#123;<br>    <br>    return (JYDynamicColor *)[[JYDynamicColorProxy alloc] initWithDynamicProvider:dynamicProvider];<br>&#125;<br><br>- (UIColor *)lightColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>  return nil;<br>&#125;<br><br>- (UIColor *)darkColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>   return nil;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>接着看到<code>JYDynamicColorProxy</code>是继承于<code>NSProxy</code>，将所有的事件都转发到了<code>resolvedColor</code>，而<code>resolvedColor</code>是根据当前模式返回 <code>lightColor</code> 或者 <code>darkColor</code>,这样就实现了，对外其实是一个<code>UIColor</code>，但是实际上是一个<code>JYDynamicColorProxy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColorProxy : NSProxy &lt;NSCopying&gt;<br><br>@property (nonatomic, readonly) UIColor * resolvedColor;<br><br>@property (nonatomic, strong) UIColor *(^dynamicProvider)(JYTraitCollection *);<br><br>@end<br><br><br>@implementation JYDynamicColorProxy<br><br>- (instancetype)initWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider &#123;<br>  self.dynamicProvider = dynamicProvider;<br>  return self;<br>&#125;<br><br>// MARK: NSProxy - 转发消息 将消息全部转发到 resolvedColor<br>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;<br>  return [self.resolvedColor methodSignatureForSelector:sel];<br>&#125;<br><br>- (void)forwardInvocation:(NSInvocation *)invocation &#123;<br>  [invocation invokeWithTarget:self.resolvedColor];<br>&#125;<br><br>- (UIColor *)resolvedColor &#123;<br>  return [self resolvedColorWithTraitCollection:JYTraitCollection.overrideTraitCollection];<br>&#125;<br><br>- (UIColor *)resolvedColorWithTraitCollection:(JYTraitCollection *)traitCollection &#123;<br>    return self.dynamicProvider(traitCollection);<br>&#125;<br><br>// MARK: UIColor<br>- (UIColor *)colorWithAlphaComponent:(CGFloat)alpha &#123;<br>  return [JYDynamicColor colorWithDynamicProvider:^UIColor *(JYTraitCollection *traitCollection) &#123;<br>    return [self.dynamicProvider(traitCollection) colorWithAlphaComponent:alpha];<br>  &#125;];<br>&#125;<br><br>- (CGColorRef)CGColor &#123;<br>  return [[self resolvedColor] CGColor];<br>&#125;<br><br><br>// MARK: NSObject<br>- (BOOL)isKindOfClass:(Class)aClass &#123;<br>  static JYDynamicColor *dynamicColor = nil;<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^&#123;<br>    dynamicColor = [[JYDynamicColor alloc] init];<br>  &#125;);<br>  return [dynamicColor isKindOfClass:aClass];<br>&#125;<br><br>// MARK: NSCopying<br>- (id)copy &#123;<br>  return [self copyWithZone:nil];<br>&#125;<br><br>- (id)copyWithZone:(NSZone *)zone &#123;<br>  return [[JYDynamicColorProxy alloc] initWithDynamicProvider:[self.dynamicProvider copy]];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> iOS13以下，如果需要切换颜色，该如何刷新？<code>JYDynamicColorProxy</code>是如何存储颜色的呢？</p></blockquote><p>我们<code>swizzle</code>将设置颜色方法进行了hook，例如<code>@selector(setBackgroundColor:);</code>方法，将<code>backgroundColor</code>为<code>JYDynamicColor</code>的都进行处理</p><p>这里采用了关联对象的思想，写了一个<code>UIView</code>的分类,将<code>JYDynamicColorProxy</code>进行存储，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">...<br>@property (nullable, readonly) JYDynamicColor *jy_dynamicBackgroundColor;<br>...<br><br>- (JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>    return objc_getAssociatedObject(self, @selector(jy_dynamicBackgroundColor));<br>&#125;<br><br>- (void)setJy_dynamicBackgroundColor:(JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>  objc_setAssociatedObject(self,<br>                           @selector(jy_dynamicBackgroundColor),<br>                           jy_dynamicBackgroundColor,<br>                           OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br></code></pre></td></tr></table></figure><p>当修改当前模式的时候，我们将初始化拿到的<code>UIApplication</code>进行遍历，拿到<code>UIView</code>,然后调用分类当中的修改颜色方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jyTraitCollectionDidChange:(JYTraitCollection *)previousTraitCollection &#123;<br>  if (@available(iOS 13.0, *)) &#123;<br>    return;<br>  &#125;<br>    [self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull view, NSUInteger idx, BOOL * _Nonnull stop) &#123;<br>        [view jyTraitCollectionDidChange:previousTraitCollection];<br>     &#125;];<br>     <br>    [self setNeedsLayout];<br>    [self setNeedsDisplay];<br>#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_13_0<br>    [self jy_updateDynamicColors];<br>#endif<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jy_updateDynamicColors&#123;<br>    JYDynamicColor * backgroundColor = [self jy_dynamicBackgroundColor];<br>    if (backgroundColor) &#123;<br>        [self setBackgroundColor:backgroundColor];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过关联对象取到对应模式的Color,然后赋值即可，图片也是一样的原理</p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-渲染机制</title>
    <link href="/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="CALayer-与-UIView"><a href="#CALayer-与-UIView" class="headerlink" title="CALayer 与 UIView"></a>CALayer 与 UIView</h3><p>UIView拥有一个属性为<code>layer</code>和<code>layerClass</code>属性</p><ul><li><code>layer</code> 属性返回的是 <code>UIView</code> 所持有的主 <code>Layer(RootLayer)</code> 实例，我们可以通过其来设置 <code>UIView</code> 没有封装的一些 <code>layer</code> 属性；</li><li><code>layerClass</code> 则返回 <code>RootLayer</code> 所使用的类，我们可以通过重写该属性，来让 <code>UIView</code> 使用不同的 <code>CALayer</code> 来显示</li></ul><p><code>CALayer</code>继承自<code>NSObject</code>，负责图像渲染</p><p><code>UIView</code>继承自<code>UIResponder</code>，负责事件的响应</p><h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024844.png" alt="image-20190312112603570"></p><p>CPU和GPU通过总线连接，CPU中计算出的往往是<code>bitmap</code>位图，通过总线由合适的时机传递给GPU，GPU拿到位图后，渲染到帧缓存区<code>FrameBuffer</code>,然后由视频控制器根据<code>Vsync</code>信号在指定时间之前去帧缓冲区提取内容，显示到屏幕上。</p><p>CPU工作内容: </p><ol><li>layout（UI布局，文本计算）</li><li>display（绘制 drawRect）</li><li>prepare(图片解码)</li><li>commit（提交位图）</li></ol><p><code>GPU工作内容:</code> 顶点着色，图元装配，光栅化，片段着色，片段处理，最后提交帧缓冲区</p><h3 id="View绘制渲染机制和Runloop什么关系"><a href="#View绘制渲染机制和Runloop什么关系" class="headerlink" title="View绘制渲染机制和Runloop什么关系"></a>View绘制渲染机制和Runloop什么关系</h3><p>例如有以下 <code>UIView</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYView<br>- (void)drawRect:(CGRect)rect &#123;<br>    CGContextRef con = UIGraphicsGetCurrentContext();<br>    CGContextAddEllipseInRect(con, CGRectMake(0,0,100,200));<br>    CGContextSetRGBFillColor(con, 0, 0, 1, 1);<br>    CGContextFillPath(con);<br>&#125;<br>@end<br><br><br>@implementation ViewController<br><br>- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    JYView *view = [[JYView alloc] init];<br>    view.backgroundColor = [UIColor whiteColor];<br>    view.bounds = CGRectMake(0, 0, 100, 100);<br>    view.center = CGPointMake(100, 100);<br>    [self.view addSubview:view];<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>重写了 <code>UIView</code> 的 <code>DrawRect</code>方法.展现在屏幕前经历以下堆栈</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-03-093059.jpg" alt="img"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>当在操作 UI 时，比如改变了<code>Frame</code> 、更新了 <code>UIView/CALayer</code> 的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()<br>QuartzCore:CA::Transaction::observer_callback:<br>CA::Transaction::commit();<br>CA::Context::commit_transaction();<br>CA::Layer::layout_and_display_if_needed();<br>CA::Layer::layout_if_needed();<br>[CALayer layoutSublayers];<br>[UIView layoutSubviews];<br>CA::Layer::display_if_needed();<br>[CALayer display];<br>[UIView drawRect];<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-A4.png" alt="img"></p><h3 id="View布局与约束时机"><a href="#View布局与约束时机" class="headerlink" title="View布局与约束时机"></a>View布局与约束时机</h3><p>一个视图的布局指的是它在屏幕上的的大小和位置。每个 view 都有一个 frame 属性，用来表示在父 view 坐标系中的位置和具体的大小。<code>UIView</code> 给你提供了用来通知系统某个 view 布局发生变化的方法，也提供了在 view 布局重新计算后调用的可重写的方法。</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局:"></a>布局:</h4><p><strong>layoutSubviews()</strong></p><p>它负责给出当前 view 和每个子 view 的位置和大小。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。系统会在任何它需要重新计算视图的 frame 的时候调用这个方法，所以你应该在需要更新 frame 来重新定位或更改大小时重载它。然而你不应该在代码中显式调用这个方法。相反，有许多可以在 run loop 的不同时间点触发 <code>layoutSubviews</code> 调用的机制，这些触发机制比直接调用 <code>layoutSubviews</code> 的资源消耗要小得多。</p><p><strong>自动刷新触发器</strong></p><p>有许多事件会自动给视图打上 “update layout” 标记，因此 <code>layoutSubviews</code> 会在<strong>下一个周期中（重点！！！）</strong>被调用，而不需要开发者手动操作。这些自动通知系统 view 的布局发生变化的方式有：</p><ul><li>修改 view 的大小</li><li>新增 subview</li><li>用户在 <code>UIScrollView</code> 上滚动（<code>layoutSubviews</code> 会在 <code>UIScrollView</code> 和它的父 view 上被调用）</li><li>用户旋转设备</li><li>更新视图的 constraints</li></ul><p>这些方式都会告知系统 view 的位置需要被重新计算，继而会自动转化为一个最终的 <code>layoutSubviews</code> 调用。当然，也有直接触发 <code>layoutSubviews</code> 的方法。</p><p><strong>setNeedsLayout()</strong></p><p>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法。调用这个方法代表向系统表示视图的布局需要重新计算。<code>setNeedsLayout</code> 方法会立刻执行并返回，但在返回前不会真正更新视图。视图会在下一个 update cycle 中更新，就在系统调用视图们的 <code>layoutSubviews</code> 以及他们的所有子视图的 <code>layoutSubviews</code> 方法的时候。</p><p><strong>layoutIfNeeded()</strong></p><p><code>layoutIfNeeded</code> 是另一个会让 <code>UIView</code> 触发 <code>layoutSubviews</code> 的方法。 当视图需要更新的时候，与 <code>setNeedsLayout()</code> 会让视图在下一周期调用 <code>layoutSubviews</code> 更新视图不同，<code>layoutIfNeeded</code> 会立即调用 <code>layoutSubviews</code> 方法。但是如果你调用了 <code>layoutIfNeeded</code> 之后，并且没有任何操作向系统表明需要刷新视图，那么就不会调用 <code>layoutsubview</code>。如果你在同一个 run loop 内调用两次 <code>layoutIfNeeded</code>，并且两次之间没有更新视图，第二个调用同样不会触发 <code>layoutSubviews</code> 方法。</p><p>使用 <code>layoutIfNeeded</code>，则布局和重绘会立即发生并在函数返回之前完成（除非有正在运行中的动画）。这个方法在你需要依赖新布局，无法等到下一次 update cycle 的时候会比 <code>setNeedsLayout</code> 有用</p><p>当对希望通过修改 constraint 进行动画时，这个方法特别有用。你需要在 animation block 之前对 self.view 调用 <code>layoutIfNeeded</code>，以确保在动画开始之前传播所有的布局更新。在 animation block 中设置新 constrait 后，需要再次调用 <code>layoutIfNeeded</code> 来动画到新的状态。</p><p>(<strong>注:</strong> Masonry 动画需要这个)</p><h4 id="显示："><a href="#显示：" class="headerlink" title="显示："></a>显示：</h4><p>一个视图的显示包含了颜色、文本、图片和 Core Graphics 绘制等视图属性，不包括其本身和子视图的大小和位置。和布局的方法类似，显示也有触发更新的方法，它们由系统在检测到更新时被自动调用，或者我们可以手动调用直接刷新。</p><p><strong>setNeedsDisplay()</strong></p><p>这个方法类似于布局中的 <code>setNeedsLayout</code> 。它会给有内容更新的视图设置一个内部的标记，但在视图重绘之前就会返回。然后在下一个 update cycle 中，系统会遍历所有已标标记的视图，并调用它们的 <code>draw</code> 方法。</p><p>大部分时候，在视图中更新任何 UI 组件都会把相应的视图标记为“dirty”，通过设置视图“内部更新标记”，在下一次 update cycle 中就会重绘，而不需要显式的 <code>setNeedsDisplay</code> 调用</p><h4 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h4><p><strong>updateConstraints()</strong></p><p>这个方法用来在自动布局中动态改变视图约束。和布局中的 <code>layoutSubviews()</code> 方法或者显示中的 <code>draw</code> 方法类似，<code>updateConstraints()</code> 只应该被重载，<strong>绝不要在代码中显式地调用</strong>。通常你只应该在 <code>updateConstraints</code> 方法中实现必须要更新的约束。</p><p><strong>setNeedsUpdateConstraints()</strong></p><p>调用 <code>setNeedsUpdateConstraints()</code> 会保证在下一次更新周期中更新约束。它通过标记“update constraints”来触发 <code>updateConstraints()</code>。这个方法和 <code>setNeedsDisplay()</code> 以及 <code>setNeedsLayout()</code> 方法的工作机制类似。</p><p><strong>updateConstraintsIfNeeded()</strong></p><p>对于使用自动布局的视图来说，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 “update constraints”标记（可以被 <code>setNeedsUpdateConstraints</code> 或者 <code>invalidateInstrinsicContentSize</code>方法自动设置）。如果它认为这些约束需要被更新，它会立即触发 <code>updateConstraints()</code> ，<strong>而不会等到 RunLoop 的末尾。</strong></p><h3 id="UI-卡顿-列表卡顿、掉帧原理"><a href="#UI-卡顿-列表卡顿、掉帧原理" class="headerlink" title="UI 卡顿,列表卡顿、掉帧原理"></a>UI 卡顿,列表卡顿、掉帧原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024849.png" alt="image-20190312140156990"></p><p>iOS的 <code>mainRunloop</code>是一个60fps的回调，也就是说每16.7ms(VSync信号时间)会绘制一次屏幕，这个时间段内要完成view的缓冲区创建，view内容的绘制（如果重写了drawRect），这些CPU的工作。然后将这个缓冲区交给GPU渲染，这个过程又包括多个view的拼接(compositing)，纹理的渲染（Texture）等，最终显示在屏幕上。整个过程就是我们上面画的流程图。 因此，如果在16.7ms内完不成这些操作，比如，CPU做了太多的工作，或者view层次过于多，图片过于大，导致GPU压力太大，就会导致“卡”的现象，也就是丢帧.</p><blockquote><p>在规定的16.7ms内，在下一个VSync信号到来之前，CPU和GPU并没有共同完成下一帧视频的合成，就会出现掉帧、卡顿。</p></blockquote><h5 id="滑动优化方案思路："><a href="#滑动优化方案思路：" class="headerlink" title="滑动优化方案思路："></a>滑动优化方案思路：</h5><ul><li>CPU：<ul><li>对象的创建、调整、销毁可以放在子线程中去做ASDK；</li><li>预排班。布局计算、文本计算等事先放到子线程中去做；</li><li>使用轻量级对象，比如CALayer代替UIView</li><li>预渲染。文本等异步绘制，图片编解码等。</li><li>控制并发线程数量</li><li>减少重复计算布局，减少修改frame等</li><li>autolayout比frame更消耗资源</li><li>可以让图片的size跟frame一致</li></ul></li><li>GPU：<ul><li>纹理渲染。避免离屏渲染</li><li>视图混合。减少视图层级的复杂性，减少透明视图；不透明的opaque设置为YES</li><li>GPU能处理的最大纹理是4096 * 4096，一旦超过这个尺寸就会调用CPU进行资源处理，所以纹理尽量不要超过这个尺寸</li></ul></li></ul><h3 id="UIView的绘制原理"><a href="#UIView的绘制原理" class="headerlink" title="UIView的绘制原理"></a>UIView的绘制原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024854.png" alt="image-20190312141642996"></p><p><code>[UIView setNeedsDisplay]</code> 并没有发生当前视图立即绘制工作,打上需要重绘的脏标记，最后是在某个时机完成</p><p><code>[UIView setLayoutIfNeed]</code> 立即重新布局视图(下一个Runloop)</p><p><code>[view layouIfNeeded]</code> 当前RunLoop休眠前更新</p><p>当我们调用UIView的<code>setNeedsDisplay</code>的方法时候，会调用<code>layer</code>的同名方法，相当于在当前<code>layer</code>打上绘制标记，在当前<code>runloop</code>将要结束的时候，才会调用CALayer的<code>display</code>方法进入到真正的绘制当中。</p><p>CALayer的<code>display</code>方法中，首先会判断layer的delegate方法<code>displayLayer：</code>是否实现，如果代理没有响应这个方法，则进入到系统绘制流程；如果代理响应了这个方法，则进入到异步绘制流程</p><h3 id="系统绘制流程"><a href="#系统绘制流程" class="headerlink" title="系统绘制流程"></a>系统绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024857.png" alt="image-20190312142115333"></p><p>在CALayer内部，系统会创建一个backingStore（可以理解为CGContextRef，drawRect中取到的currentRef就是这个东西），然后layer回判断是否有delegate，如果没有代理，就调用CALayer的<code>drawInContext：</code>方法；如果有代理，则调用layer代理的<code>drawLayer:inContext:</code>方法，这一步发生在系统内部，然后在合适的时间给与我们回调一个熟悉的UIView的<code>drawRect：</code>方法。也就是在系统内部的绘制之上，允许我们再做一些额外的绘制。最后CALayer把backting store（位图）传给GPU。</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-07-23-134925.jpg" alt="15420320733034"></p><ol><li>首先一个视图由 CPU 进行 Frame 布局，准备视图和图层的层级关系，查询是否有重写 <code>drawRect:</code> 或 <code>drawLayer:inContext:</code>方法，<strong>注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</strong></li><li>CPU 会将处理视图和图层的层级关系打包，通过 IPC（内部处理通信）通道提交给渲染服务，渲染服务由 OpenGL ES 和 GPU 组成。</li><li>渲染服务首先将图层数据交给 OpenGL ES 进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧缓存的切换。</li><li>最后，将最终要显示在画面上的后帧缓存交给 GPU，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</li></ol><blockquote><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存，即GPU会预先渲染好一帧放入一个缓冲区内（前帧缓存），让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器（后帧缓存）。当你视频控制器已经读完一帧，准备读下一帧的时候，GPU会等待显示器的VSync信号发出后，前帧缓存和后帧缓存会瞬间切换，后帧缓存会变成新的前帧缓存，同时旧的前帧缓存会变成新的后帧缓存。</p></blockquote><h3 id="异步绘制流程"><a href="#异步绘制流程" class="headerlink" title="异步绘制流程"></a>异步绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024902.png" alt="image-20190312142425272"></p><p>layer的delegate如果实现了<code>displayLayer:</code>方法，就会进入到异步绘制的流程。在异步绘制的过程中，需要代理来生成对应的bitmap位图文件，并把此bitmap作为layer的contents属性</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024910.png" alt="image-20190312142514299"></p><h3 id="drawRect方法内为何第一行代码总要获取图形的上下文"><a href="#drawRect方法内为何第一行代码总要获取图形的上下文" class="headerlink" title="drawRect方法内为何第一行代码总要获取图形的上下文"></a>drawRect方法内为何第一行代码总要获取图形的上下文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">CGContextRef con = UIGraphicsGetCurrentContext();<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-082448.jpg" alt="img"></p><p>每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store 当UIView被绘制时（从 CA::Transaction::commit:以后），CPU执行drawRect，通过context将数据写入backing store 当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上 所以在 drawRect 方法中 要首先获取 context</p><h3 id="为什么要将图像渲染和事件响应这两个功能分开？"><a href="#为什么要将图像渲染和事件响应这两个功能分开？" class="headerlink" title="为什么要将图像渲染和事件响应这两个功能分开？"></a>为什么要将图像渲染和事件响应这两个功能分开？</h3><p>因为<code>CALayer</code>属于<code>QuartzCore</code>框架，<code>UIView</code>属于<code>UIKit</code>框架，</p><p><code>QuartzCore</code> 框架是可以跨平台使用的，但是<code>UIKit</code>框架只能在iOS中，在MacOs当中触摸是鼠标键盘，而iOS是触摸事件，遵循设计原则中的单一职责。</p><h3 id="CALayer为什么可以呈现可视化内容呢？"><a href="#CALayer为什么可以呈现可视化内容呢？" class="headerlink" title="CALayer为什么可以呈现可视化内容呢？"></a>CALayer为什么可以呈现可视化内容呢？</h3><p>CALayer包含一个<code>contents</code>属性,<code>CALayer</code> 中的 <code>contents</code> 属性保存了由设备渲染流水线渲染好的位图 <code>bitmap</code>（通常也被称为 <code>backing store</code>），而当设备屏幕进行刷新时，会从 <code>CALayer</code> 中读取生成好的 <code>bitmap</code>，进而呈现到屏幕上。CALayer的<code>contents</code>的值必须是<code>CGImage</code>。</p><h3 id="例如添加一个View-其底层做了什么操作？"><a href="#例如添加一个View-其底层做了什么操作？" class="headerlink" title="例如添加一个View,其底层做了什么操作？"></a>例如添加一个View,其底层做了什么操作？</h3><p><code>Core Animation</code> 会在APP启动时像 <code>Runloop</code> 注册一个 <code>Observer</code>，当事件到来的时候，<code>Runloop</code> 会被唤醒处理相关的业务逻辑（UIView 的创建，修改），将UI信息提交给<code>Render Server</code>,然后会等待<code>VSync</code>信号的到来，然后会通过<code>Metal</code>或者<code>OpenGLES</code>做一些绘制操作，然后把处理完的数据，纹理，顶点，着色器等提交给<code>GPU</code>，在下一个<code>VSync</code>信号到来的时候，视频控制器等读取帧缓冲区的数据显示到屏幕上。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><h3 id="界面掉帧是因为什么引起的？"><a href="#界面掉帧是因为什么引起的？" class="headerlink" title="界面掉帧是因为什么引起的？"></a>界面掉帧是因为什么引起的？</h3><p>掉帧是因为当在一个<code>Vsync</code>周期中，<code>CPU</code>或者<code>GPU</code>没有完成内容提交，那么这一帧就会被废弃掉，等待下一个<code>Vsync</code>的到来，而显示屏还会保持之前的内容不变，这也是界面卡顿的原因。</p><h3 id="CoreAnimation渲染流程？"><a href="#CoreAnimation渲染流程？" class="headerlink" title="CoreAnimation渲染流程？"></a>CoreAnimation渲染流程？</h3><p>首先收到事件的处理，例如布局改变</p><p>通过CPU完成显示内容计算，对APP图层进行打包，在下一次runloop时将描述好的 UI 信息以 <code>IPC</code> 的形式提供给<strong>系统常驻的 UI 绘制进程</strong>渲染服务RenderServer, </p><p>将收到的打包进行解码，执行metal相关程序，调用GPU</p><p>GPU完成对图像的渲染，最后显示到屏幕上</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzj6f3n9o3j20xc0hq406.jpg"></p><p><strong>但是如果重写了 <code>drawRect:</code> 方法，这个方法会直接调用 <code>Core Graphics</code> 绘制方法得到 <code>bitmap</code> 数据，同时系统会额外申请一块内存，用于暂存绘制好的 <code>bitmap</code>。</strong></p><p>由于重写了 <code>drawRect:</code> 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。</p><h3 id="离屏渲染指的是什么？"><a href="#离屏渲染指的是什么？" class="headerlink" title="离屏渲染指的是什么？"></a>离屏渲染指的是什么？</h3><p>我们知道<code>GPU</code>会将渲染完成后的结果放入<code>Frame Buffer</code>当中，但是如果<code>GPU</code>无法一次完成渲染工作，需要两，这时就需要一个额外的载体来保存第一次的结果，而这个载体也就是离屏渲染缓冲区。</p><p>离屏渲染会创建新的缓冲区，增加额外的空间，大量的离屏渲染可能造成内存的过大压力。</p><p>离屏渲染的过程中，会进行两次上下文的切换，先切换到屏幕外，离屏渲染完成后再切回当前屏幕。</p><h3 id="所有的离屏渲染都是坏的吗？"><a href="#所有的离屏渲染都是坏的吗？" class="headerlink" title="所有的离屏渲染都是坏的吗？"></a>所有的离屏渲染都是坏的吗？</h3><p>我们可以利用开启<code>CALayer</code>的<code>shouldRasterize</code>属性去触发离屏渲染。开启之后，<code>Render Server</code> 会强制将 <code>CALayer 的渲染位图结果</code>bitmap&#96; 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。</p><p>保存的 <code>bitmap</code> 包含 <code>layer</code> 的 <code>subLayer</code>、圆角、阴影、组透明度 <code>group opacity</code> 等，所以如果 <code>layer</code> 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。<strong>其主旨在于降低性能损失，但总是至少会触发一次离屏渲染。</strong></p><blockquote><p>圆角、阴影、组透明度等会由系统自动触发离屏渲染，那么打开光栅化就可以节约第二次及以后的渲染时间。而多层 subLayer 的情况由于不会自动触发离屏渲染，所以相比之下会多花费第一次离屏渲染的时间，但是可以节约后续的重复渲染的开销。</p></blockquote><h3 id="哪些情况会触发离屏渲染？"><a href="#哪些情况会触发离屏渲染？" class="headerlink" title="哪些情况会触发离屏渲染？"></a>哪些情况会触发离屏渲染？</h3><ul><li>使用了 <code>mask</code> 的 <code>layer (layer.mask)</code>；</li><li>添加了投影的<code> layer (layer.shadow*，表示相关的 shadow 开头的属性)</code></li><li>设置了组透明度为 YES，并且透明度不为 1 的<code>layer (layer.allowsGroupOpacity/layer.opacity)</code></li><li>采用了光栅化的 <code>layer (layer.shouldRasterize)</code></li><li>绘制了文字的 <code>layer (UILabel, CATextLayer, Core Text 等)</code></li><li>需要进行裁剪的<code> layer (layer.masksToBounds / view.clipsToBounds)</code></li></ul><p>总结一下，iOS 9 之后圆角造成离屏渲染的条件包括：</p><ul><li>圆角</li><li>裁剪</li><li><code>layer</code> 的<code>contents</code>不为 <code>nil</code></li><li>设置了背景色 &#x2F; 边框 &#x2F; 其他有图像内容的图层</li></ul><h3 id="知识点问题梳理"><a href="#知识点问题梳理" class="headerlink" title="知识点问题梳理"></a>知识点问题梳理</h3><ul><li><p>图像显示的原理</p></li><li><p>layoutSubviews()&#x2F;setNeedsLayout()&#x2F;layoutIfNeeded()三者之间的区别？</p></li><li><p>setNeedsDisplay()有什么作用？</p></li><li><p>界面掉帧是因为什么引起的？</p></li><li><p>离屏渲染是什么?所有的离屏渲染都是坏的吗？哪些情况会触发离屏渲染？</p></li><li><p>异步绘制的流程</p></li><li><p>drawRect方法在什么时候调用？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-Runloop</title>
    <link href="/2021/03/01/iOS-Runloop/"/>
    <url>/2021/03/01/iOS-Runloop/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><ul><li>Run loops是线程相关的的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比 如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</li></ul><h3 id="runloop和线程的关系"><a href="#runloop和线程的关系" class="headerlink" title="runloop和线程的关系"></a>runloop和线程的关系</h3><ul><li>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。</li><li>子线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。</li><li>子线程中，RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。</li><li>你只能在一个线程的内部获取其 RunLoop（主线程除外）。</li></ul><h3 id="runloop的接口"><a href="#runloop的接口" class="headerlink" title="runloop的接口"></a>runloop的接口</h3><ul><li>CFRunLoopRef<ul><li>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source&#x2F;Timer&#x2F;Observer，让其互不影响</li></ul></li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef<ul><li>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。<ul><li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li><li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li></ul></li></ul></li><li>CFRunLoopTimerRef<ul><li>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</li></ul></li><li>CFRunLoopObserverRef<ul><li>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</li></ul></li></ul><h3 id="runloop的mode"><a href="#runloop的mode" class="headerlink" title="runloop的mode"></a>runloop的mode</h3><ul><li>kCFRunLoopDefaultMode&#x2F;NSDefaultRunLoopMode<ul><li>App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li></ul></li><li>UITrackingRunLoopMode<ul><li>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li></ul></li><li>UIInitializationRunLoopMode<ul><li>在刚启动App时第进入的第一个Mode，启动完成后就不再使用</li></ul></li><li>GSEventReceiveRunLoopMode<ul><li>接受系统事件的内部Mode，通常用不到</li></ul></li><li>kCFRunLoopCommonModes&#x2F;NSRunLoopCommonModes<ul><li>组合状态，这是一个占位的 Mode，没有实际作用。</li></ul></li></ul><h3 id="runloop内部逻辑"><a href="#runloop内部逻辑" class="headerlink" title="runloop内部逻辑"></a>runloop内部逻辑</h3><p><img src="http://blog.qiji.tech/wp-content/uploads/2016/04/RunLoop_1.png" alt="image"></p><ul><li>1、通知Observer：即将进入Loop</li><li>2、通知Observer：将要处理Timer</li><li>3、通知Observer：将要处理Source0</li><li>4、处理Source0</li><li>5、如果有Source1，跳到第9步</li><li>6、通知Observer：线程即将休眠</li><li>7、休眠，等待唤醒</li><li>8、通知Observer：线程刚被唤醒</li><li>9、处理唤醒时收到的消息，之后跳回2</li><li>10、通知Observer：即将退出Loop</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs scss">&#123;<br>    <span class="hljs-comment">/// 1. 通知Observers，即将进入RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopEntry);<br>    do &#123;<br> <br>        <span class="hljs-comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeTimers);<br>        <span class="hljs-comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeSources);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 4. 触发 Source0 (非基于port的) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>(source0);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 6. 通知Observers，即将进入休眠</span><br>        <span class="hljs-comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeWaiting);<br> <br>        <span class="hljs-comment">/// 7. sleep to wait msg.</span><br>        <span class="hljs-built_in">mach_msg</span>() -&gt; <span class="hljs-built_in">mach_msg_trap</span>();<br>        <br> <br>        <span class="hljs-comment">/// 8. 通知Observers，线程被唤醒</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopAfterWaiting);<br> <br>        <span class="hljs-comment">/// 9. 如果是被Timer唤醒的，回调Timer</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>(timer);<br> <br>        <span class="hljs-comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(dispatched_block);<br> <br>        <span class="hljs-comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>(source1);<br> <br> <br>    &#125; while (...);<br> <br>    <span class="hljs-comment">/// 10. 通知Observers，即将退出RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopExit);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><h3 id="runloop什么时候退出"><a href="#runloop什么时候退出" class="headerlink" title="runloop什么时候退出"></a>runloop什么时候退出</h3><ul><li>1、超过设定的超时</li><li>2、当前runloop中没有需要处理的timer、source</li><li>3、接收到exit信号</li></ul><h2 id="runloop在系统中的应用"><a href="#runloop在系统中的应用" class="headerlink" title="runloop在系统中的应用"></a>runloop在系统中的应用</h2><h3 id="1、AutoreleasePool"><a href="#1、AutoreleasePool" class="headerlink" title="1、AutoreleasePool"></a>1、AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="2、事件响应"><a href="#2、事件响应" class="headerlink" title="2、事件响应"></a>2、事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code></p><p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 <code>mach port</code> 转发给需要的App进程。随后苹果在APP内注册的 Source1 就会触发回调，并调用<code>_UIApplicationHandleEventQueue() </code>进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent </code>处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 <code>UIButton 点击、touchesBegin/Move/End/Cancel </code>事件都是在这个回调中完成的。</p><h3 id="3、手势识别"><a href="#3、手势识别" class="headerlink" title="3、手势识别"></a>3、手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue() </code>识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。</p><p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p><h3 id="4、界面更新"><a href="#4、界面更新" class="headerlink" title="4、界面更新"></a>4、界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h3 id="5、定时器"><a href="#5、定时器" class="headerlink" title="5、定时器"></a>5、定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="6、PerformSelecter"><a href="#6、PerformSelecter" class="headerlink" title="6、PerformSelecter"></a>6、PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="7、网络请求（现在的NSURLSession是否借助了runloop？）"><a href="#7、网络请求（现在的NSURLSession是否借助了runloop？）" class="headerlink" title="7、网络请求（现在的NSURLSession是否借助了runloop？）"></a>7、网络请求（现在的NSURLSession是否借助了runloop？）</h3><p>NSURLConnection 的工作过程也借助了runloop。使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="image"></p><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="你用runloop实现了什么"><a href="#你用runloop实现了什么" class="headerlink" title="你用runloop实现了什么"></a>你用runloop实现了什么</h2><h3 id="使用runloop开启一个常驻子线程"><a href="#使用runloop开启一个常驻子线程" class="headerlink" title="使用runloop开启一个常驻子线程"></a>使用runloop开启一个常驻子线程</h3><ul><li>AFNetworking2开启子线程，在后台线程接收 Delegate 回调  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">+ (<span class="hljs-type">void</span>)networkRequestThreadEntryPoint:(id)__unused object &#123;<br> <br>     @autoreleasepool &#123;<br>       [[NSThread currentThread] setName:@<span class="hljs-string">&quot;AFNetworking&quot;</span>];<br>       NSRunLoop *runLoop = [NSRunLoop currentRunLoop];<br>       [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>       [runLoop run];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>线上实时卡顿监控<ul><li>NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources（3. 通知 Observers: 即将触发 Source0回调）和kCFRunLoopBeforeWaiting（6. 通知Observers，即将进入休眠）之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿</li><li><a href="https://www.jianshu.com/p/890d1ba05f4c">iOS线上实时卡顿监控</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-动态库与静态库的区别</title>
    <link href="/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="静态库-Static-Library"><a href="#静态库-Static-Library" class="headerlink" title="静态库 (Static Library)"></a>静态库 (Static Library)</h3><ul><li><p>分发文件大</p></li><li><p>静态库默认仅将有用到的类文件<code>link</code>到<code>Mach-O</code>中(已类文件为最小链接单位)</p></li><li><p>ipa包小(为了APP瘦身，尽量将代码放静态库中) </p><ul><li>静态库中某个目标文件的代码没有被任何地方引用，则这个目标文件不会被链接到可执行文件中去(前提是不要使用<code>-Objc</code>和<code>-all_load</code>选项，分类代码经常被优化掉，一般都使用<code>-force_load</code>来处理静态库分类加载问题)</li></ul></li><li><p>APP冷启动速度快</p><ul><li>前提是不使用<code>动态库拆分</code>搭配<code>动态库懒加载方案</code></li><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个静态库只需要<code>rebase</code>和<code>bind</code>一次</li></ul></li><li><p>存在符号冲突可能</p></li><li><p>共享<code>TEXT段</code></p><ul><li>iOS9以前单个Mach-O的TEXT限制60M</li><li>iOS9以后单个Mach-O的TEXT限制500M</li></ul></li><li><p>不需要额外签名验证  </p></li><li><p>静态库符号的可见性可以在链接期间被修改 </p></li><li><p>文件格式多为<code>fat</code>格式的静态库文件</p></li><li><p>形式多为<code>.a</code>与<code>.framework</code></p></li><li><p>静态库不含<code>bitcode</code>时，引用静态库的目标部署时就不能包含<code>bitcode</code></p></li></ul><h3 id="动态库-Dynamic-Library"><a href="#动态库-Dynamic-Library" class="headerlink" title="动态库 (Dynamic Library)"></a>动态库 (Dynamic Library)</h3><ul><li><p>分发文件小</p></li><li><p>ipa包大  （前提是不考虑懒加载的情况）</p><ul><li>动态库会把整个<code>lib</code>复制进<code>ipa</code>中</li></ul></li><li><p>APP冷启动速度慢</p><ul><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个动态库只需要多次<code>rebase</code>和<code>bind</code></li></ul></li><li><p>需要设置合适的<code>runpath</code> </p></li><li><p>需要动态加载</p></li><li><p>需要签名且需要验证签名</p><ul><li>会检查<code>framework</code>的签名，签名中必须包含<code>TeamIdentifier</code>,并且<code>framework</code>和host APP的<code>TeamIdentifier</code>必须一致</li><li>Xcode重签命，保证动态库签名一致性</li></ul></li><li><p>需要导出符号</p></li><li><p>重复的<code>arch</code>结构</p></li><li><p>APP与动态库中重复代码可以共存，不会发生符号冲突</p><ul><li>因为可执行文件在构建链接阶段，遇到静态库则吸附进来，遇到动态库则打个标记，彼此保持独立性</li><li>对于来自动态库的符号，编译器会打个标记，交给<code>dyld</code>去加载和链接符号，也就是把链接的过程推迟到了运行时执行。（比如APP使用的是3.0版本SDK，动态库使用的是1.0版本SDK，能正常运行，但是会有风险）</li></ul></li><li><p>链接后需要包含分发大小</p></li><li><p>冷启动过程中，默认会在<code>main</code>函数之前加载</p><ul><li>默认情况下，过多的动态库会拖慢冷启动速度</li><li>如果采用懒加载动态库的形式，能够加快APP的启动速度,可以使用<code>dlopen</code>和<code>bundle</code>懒加载优化</li></ul></li><li><p>文件格式<code>Mach-O</code>（一个没有<code>main</code>函数的可执行文件）</p></li><li><p>动态库不包含<code>bitcode</code>时，引用动态库的目标部署时可以包含<code>bitcode</code></p></li><li><p><code>CocoaPods</code>从<code>v0.36.0</code>开始，可添加关键字<code>use_frameworks!</code>编译成类似<code>Embedded Framework</code>的结构（可以称之为<code>umbrella framework</code>）</p><ul><li>缺点：默认把项目的依赖全部改为动态库（可是使用<code>use_modular_headers!</code>,也可以在<code>podsepc</code>添加<code>s.static_framework = true</code>规避）</li><li><code>CocoaPods</code>执行脚本把动态库嵌入到<code>.app</code>的<code>Framework</code>目录下（相当于在<code>Embedded Binaries</code>加入动态库）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-同步方案（锁）</title>
    <link href="/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/"/>
    <url>/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>近期要写一个多线程工具，把之前学习的多线程，以及线程同步复习一下 </p><p>多线程的本质：有多条线程，但是只能执行一条，如果间隔时间设置的足够小，就给人的感觉是多条线程是同时进行的，时间片轮转调度算法</p><p>iOS中线程同步方案</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>Dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h4 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock - 自旋锁"></a>OSSpinLock - 自旋锁</h4><p> 等待锁🔐的线程会处于忙等状态，一直占用CPU资源</p><p>会出现优先级翻转的问题，如果线程之间的优先级不同，如果低优先级的锁先进来，把锁锁住，那么高优先级的线程进来就会一直忙等，但是系统又会分配时间资源给线程高的，从而导致低优先级的线程无法执行完自己的代码，从而导致优先级低的锁无法释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_SPINLOCK_INIT;<br>   <br>- (void)saleTicket&#123;<br>    /// 加锁<br>  OSSpinLockLock(&amp;_lock);<br>  //BOOL isLock =  OSSpinLockTry(&amp;_lock); <br>  int oldTicketsCount = self.ticketsCount;<br>  sleep(.2);<br>  oldTicketsCount--;<br>  self.ticketsCount = oldTicketsCount;<br>  NSLog(@&quot;还剩下%d张票 = %@&quot;,self.ticketsCount,[NSThread currentThread]);<br>  /// 解锁<br>  OSSpinLockUnlock(&amp;_lock);<br>&#125;<br>   <br></code></pre></td></tr></table></figure><hr><h4 id="os-unfair-lock-iOS10后支持-（本质是互斥锁）"><a href="#os-unfair-lock-iOS10后支持-（本质是互斥锁）" class="headerlink" title="os_unfair_lock - iOS10后支持 （本质是互斥锁）"></a>os_unfair_lock - iOS10后支持 （本质是互斥锁）</h4><p>用于替代<code>OSSpinLock</code> 的锁，使用的技术不再是忙等，而是休眠等待唤醒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_UNFAIR_LOCK_INIT;<br>- (void)saleTicket&#123;   <br>    /// 加锁<br>    os_unfair_lock_lock(&amp;_lock);<br>//  BOOL isLock = os_unfair_lock_trylock(&amp;lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    os_unfair_lock_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><p><code>mutex</code> 叫做”互斥锁”，等待锁的线程会处于休眠状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化属性    <br>pthread_mutexattr_t attr;<br>pthread_mutexattr_init(&amp;attr);<br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);<br>/// 初始化锁<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>//销毁属性 pthread_mutexattr_destroy(&amp;attr);<br>//销毁锁   pthread_mutex_destroy(&amp;_lock);<br><br>- (void)saleTicket&#123; <br>    /// 加锁<br>    pthread_mutex_lock(&amp;_lock);<br>    ///尝试 加锁<br>    //BOOL islock = pthread_mutex_trylock(&amp;_lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/*<br> * Mutex type attributes<br> */<br>#define PTHREAD_MUTEX_NORMAL0  //普通状态锁<br>#define PTHREAD_MUTEX_ERRORCHECK1<br>#define PTHREAD_MUTEX_RECURSIVE2  //用于处理递归锁<br>#define PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL<br><br></code></pre></td></tr></table></figure><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>递归锁：允许同一个线程对一把锁重复加锁</p><p>线程一 : 调用<code>saleTicket</code> (+🔐)</p><ul><li>调用<code>saleTicket</code> (+🔐)</li><li>调用<code>saleTicket</code> (+🔐)</li></ul><p> 线程二：调用<code>saleTicket</code> (发现已经被加锁了，等待) </p><p>当锁中间的代码遇到递归调用，打印的结果永远只有一条<code>saleTicket</code>，因为没有人能够走到解锁的那一步。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">- (void)saleTicket&#123;<br>    <span class="hljs-comment">/// 加锁</span><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;_lock);<br>    <span class="hljs-comment">///尝试 加锁</span><br>    <span class="hljs-comment">//BOOL islock = pthread_mutex_trylock(&amp;_lock);</span><br>    <span class="hljs-built_in">NSLog</span>(@&quot;%s&quot;,__func__);<br>    <span class="hljs-comment">// 卖票 递归调用</span><br>    <span class="hljs-selector-attr">[self saleTicket]</span>;<br>    <span class="hljs-comment">/// 解锁</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;_lock);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p> <code>pthread</code>是支持递归锁的，只需要把初始化属性改为递归锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxupqijd8nj30c205igme.jpg"></p><h5 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, assign) pthread_cond_t cond;<br><br>/// 初始化条件<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>// 销毁条件<br>pthread_cond_destroy(&amp;_cond);<br><br>[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil]start];<br>[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil]start];<br><br>- (void)__remove&#123;<br>   <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    if (self.dataArray.count == 0) &#123;<br>        //一旦进入等待状态，就会放开这把锁，直到别人发送信号唤醒<br>        pthread_cond_wait(&amp;_cond, &amp;_lock);<br>    &#125;<br>    [self.dataArray removeLastObject];<br>    NSLog(@&quot;删除了元素&quot;);<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br><br>- (void)__add&#123;<br>    <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    [self.dataArray addObject:@&quot;123&quot;];<br>    NSLog(@&quot;添加了元素&quot;);<br>     <br>    pthread_cond_signal(&amp;_cond);<br>    pthread_mutex_unlock(&amp;_lock);<br>    // 这里需要保证pthread_cond_signal在pthread_mutex_unlock之前<br>    // 如果在之后的话，锁解开了，发送信号的这个过程中有可能被别的锁抢先进来了<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h4 id="NSLock-x2F-NSRecursiveLock-x2F-NSCondition"><a href="#NSLock-x2F-NSRecursiveLock-x2F-NSCondition" class="headerlink" title="NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition"></a>NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition</h4><ul><li><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p></li><li><p><code>NSRecursiveLock</code> 是对<code>mutex</code>递归锁的封装</p></li><li><p><code>NSCondition</code> 是对<code>mutex</code>和<code>cont</code>的封装</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@protocol NSLocking<br><br>- (void)lock;<br>- (void)unlock;<br><br>@end<br><br>@interface NSLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (BOOL)tryLock; // 尝试加锁<br>- (BOOL)lockBeforeDate:(NSDate *)limit; //在这个时间之前等不到这个锁，都会睡眠<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br>@end<br></code></pre></td></tr></table></figure><p>可以查看GNUStep看到<code>NSLock</code>的实现</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxusubtzxlj30js0b8400.jpg"></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;<br><br>@property (readonly) NSInteger condition;<br>- (void)lockWhenCondition:(NSInteger)condition;<br>- (BOOL)tryLock;<br>- (BOOL)tryLockWhenCondition:(NSInteger)condition;<br>- (void)unlockWithCondition:(NSInteger)condition;<br>- (BOOL)lockBeforeDate:(NSDate *)limit;<br>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br><br>@end<br></code></pre></td></tr></table></figure><hr><h4 id="Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列"><a href="#Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列" class="headerlink" title="Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列"></a>Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列</h4><ul><li>串行队列，也可以实现线程同步，保证了每一条线程的操作都是按顺序的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">  @property (nonatomic, strong) dispatch_queue_t  queen;<br>  <br>  self.queen =  dispatch_queue_create(&quot;123&quot;, DISPATCH_QUEUE_SERIAL);<br>  <br>  - (void)test&#123;<br>    self.ticketsCount = 20;<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore - 信号量"></a>dispatch_semaphore - 信号量</h4><ul><li>信号量的初始值，可以用来控制线程的并发访问的最大数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, strong) dispatch_semaphore_t semaphore;<br>  // 设置最大并发数     <br> self.semaphore = dispatch_semaphore_create(1);<br>      <br>  for (int i = 0; i&lt;20; i++) &#123;<br>     [[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];<br>  &#125;<br>  <br>- (void)test&#123;    <br>    // 如果信号量的值&gt;0,就让信号量减1，然后继续执行下面的代码<br>    // 直到信号量的值&lt;=0的时候，就会休眠等待<br>    // DISPATCH_TIME_FOREVER永远 或者 设置成 DISPATCH_TIME_NOW现在立即<br>    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);<br>    self.ticketsCount--;<br>    sleep(2);<br>    NSLog(@&quot;剩下的票为 %d&quot;,self.ticketsCount);<br>    //让信号量的值+1<br>    dispatch_semaphore_signal(self.semaphore);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><ul><li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@synchronized (self) &#123; //objc_sync_enter<br>&#125; // objc_sync_exit<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">int objc_sync_enter(id obj)<br>&#123;<br>    int result = OBJC_SYNC_SUCCESS;<br><br>    if (obj) &#123;<br>        SyncData* data = id2data(obj, ACQUIRE);<br>        ASSERT(data);<br>        data-&gt;mutex.lock();<br>    &#125; else &#123;<br>        // @synchronized(nil) does nothing<br>        if (DebugNilSync) &#123;<br>            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);<br>        &#125;<br>        objc_sync_nil();<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>id2data</code> 方法内部</p><p>![image-20211229175537934](&#x2F;Users&#x2F;karthrine&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211229175537934.png)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxuusl6m2wj30cm01z74g.jpg"></p><p>内部是一个哈希表，把<code>obj</code>当做<code>key</code> ，<code>data-&gt;mutex.lock();</code> 拿到唯一的mutex锁，来加锁</p><hr><h4 id="自旋锁和互斥锁对比"><a href="#自旋锁和互斥锁对比" class="headerlink" title="自旋锁和互斥锁对比"></a>自旋锁和互斥锁对比</h4><p>什么情况下使用自旋锁比较划算？</p><ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发送</li><li>CPU资源不紧张</li><li>多核处理器</li></ul><p>什么情况下使用互斥锁比较划算？</p><ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2019/04/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2019/04/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
