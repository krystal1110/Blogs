<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS-动态库与静态库的区别</title>
    <link href="/project/2022/04/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/project/2022/04/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="静态库-Static-Library"><a href="#静态库-Static-Library" class="headerlink" title="静态库 (Static Library)"></a>静态库 (Static Library)</h3><ul><li><p>分发文件大</p></li><li><p>静态库默认仅将有用到的类文件<code>link</code>到<code>Mach-O</code>中(已类文件为最小链接单位)</p></li><li><p>ipa包小(为了APP瘦身，尽量将代码放静态库中) </p><ul><li>静态库中某个目标文件的代码没有被任何地方引用，则这个目标文件不会被链接到可执行文件中去(前提是不要使用<code>-Objc</code>和<code>-all_load</code>选项，分类代码经常被优化掉，一般都使用<code>-force_load</code>来处理静态库分类加载问题)</li></ul></li><li><p>APP冷启动速度快</p><ul><li>前提是不使用<code>动态库拆分</code>搭配<code>动态库懒加载方案</code></li><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个静态库只需要<code>rebase</code>和<code>bind</code>一次</li></ul></li><li><p>存在符号冲突可能</p></li><li><p>共享<code>TEXT段</code></p><ul><li>iOS9以前单个Mach-O的TEXT限制60M</li><li>iOS9以后单个Mach-O的TEXT限制500M</li></ul></li><li><p>不需要额外签名验证  </p></li><li><p>静态库符号的可见性可以在链接期间被修改 </p></li><li><p>文件格式多为<code>fat</code>格式的静态库文件</p></li><li><p>形式多为<code>.a</code>与<code>.framework</code></p></li><li><p>静态库不含<code>bitcode</code>时，引用静态库的目标部署时就不能包含<code>bitcode</code></p></li></ul><h3 id="动态库-Dynamic-Library"><a href="#动态库-Dynamic-Library" class="headerlink" title="动态库 (Dynamic Library)"></a>动态库 (Dynamic Library)</h3><ul><li><p>分发文件小</p></li><li><p>ipa包大  （前提是不考虑懒加载的情况）</p><ul><li>动态库会把整个<code>lib</code>复制进<code>ipa</code>中</li></ul></li><li><p>APP冷启动速度慢</p><ul><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个动态库只需要多次<code>rebase</code>和<code>bind</code></li></ul></li><li><p>需要设置合适的<code>runpath</code> </p></li><li><p>需要动态加载</p></li><li><p>需要签名且需要验证签名</p><ul><li>会检查<code>framework</code>的签名，签名中必须包含<code>TeamIdentifier</code>,并且<code>framework</code>和host APP的<code>TeamIdentifier</code>必须一致</li><li>Xcode重签命，保证动态库签名一致性</li></ul></li><li><p>需要导出符号</p></li><li><p>重复的<code>arch</code>结构</p></li><li><p>APP与动态库中重复代码可以共存，不会发生符号冲突</p><ul><li>因为可执行文件在构建链接阶段，遇到静态库则吸附进来，遇到动态库则打个标记，彼此保持独立性</li><li>对于来自动态库的符号，编译器会打个标记，交给<code>dyld</code>去加载和链接符号，也就是把链接的过程推迟到了运行时执行。（比如APP使用的是3.0版本SDK，动态库使用的是1.0版本SDK，能正常运行，但是会有风险）</li></ul></li><li><p>链接后需要包含分发大小</p></li><li><p>冷启动过程中，默认会在<code>main</code>函数之前加载</p><ul><li>默认情况下，过多的动态库会拖慢冷启动速度</li><li>如果采用懒加载动态库的形式，能够加快APP的启动速度,可以使用<code>dlopen</code>和<code>bundle</code>懒加载优化</li></ul></li><li><p>文件格式<code>Mach-O</code>（一个没有<code>main</code>函数的可执行文件）</p></li><li><p>动态库不包含<code>bitcode</code>时，引用动态库的目标部署时可以包含<code>bitcode</code></p></li><li><p><code>CocoaPods</code>从<code>v0.36.0</code>开始，可添加关键字<code>use_frameworks!</code>编译成类似<code>Embedded Framework</code>的结构（可以称之为<code>umbrella framework</code>）</p><ul><li>缺点：默认把项目的依赖全部改为动态库（可是使用<code>use_modular_headers!</code>,也可以在<code>podsepc</code>添加<code>s.static_framework = true</code>规避）</li><li><code>CocoaPods</code>执行脚本把动态库嵌入到<code>.app</code>的<code>Framework</code>目录下（相当于在<code>Embedded Binaries</code>加入动态库）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>总结</title>
    <link href="/project/2022/04/16/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/project/2022/04/16/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
