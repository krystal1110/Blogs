<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2021-9 ~ 2022-10 总结</title>
    <link href="/2022/09/27/%E6%80%BB%E7%BB%93-%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%80%E5%B9%B4/"/>
    <url>/2022/09/27/%E6%80%BB%E7%BB%93-%E5%85%B3%E4%BA%8E%E8%BF%99%E4%B8%80%E5%B9%B4/</url>
    
    <content type="html"><![CDATA[<p></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="毕业"><a href="#毕业" class="headerlink" title="毕业"></a>毕业</h4><p>来微盟也有一年多了，在这一年多的时间内，学到了很多东西，2022年9月26日，中午吃完了团队老大的散伙饭，回到公司，就得到通知，下午交接完，开始休假，然后商量赔偿的事情 </p><p>这也是意料当中的事，今年一整年都围绕着这股气氛，从4月再到6月再到现在9月底，每一批都裁了不少人，从最早不赚钱的业务线，然后再到边缘业务，现在基础技术也基本上不存在了，虽然心里有预期，也有赔偿，但是心里总归还是有一点不舒服的（人生第一次毕业~ O(∩_∩)O ~）</p><p>之前的同事也有被 <code>hr</code> 背绩效，然后签 <code>pip</code> 绩效改进协议，等于是默认没有年终，逼你自己走，<code>hr</code> 给我的理由是 无关绩效，团队现在更注重业务开发，不太需要基础技术了，虽然我现在也兼职写着业务，随着大批量的离职，业务需求也降低了，所以有了这次的毕业</p><p>休假大概会到29号了，之前家里有事情，请了不少假，不然还能白嫖一个国庆，赔偿也是 <code>n+1</code>, 满半年算一年，反之则算半年，这算是互联网的标配了吧</p><h4 id="摸鱼周报"><a href="#摸鱼周报" class="headerlink" title="摸鱼周报"></a>摸鱼周报</h4><p>这一年确实收货了很多，加入了摸鱼周报的联合编辑，定时定点督促自己学习新知识，也结识了很多大佬，星神，飞哥，竹立，晨光等等，都是周报的小伙伴，经常会像他们请教问题，感谢他们的帮助</p><h4 id="小伙伴们"><a href="#小伙伴们" class="headerlink" title="小伙伴们"></a>小伙伴们</h4><p>在 <code>wm</code> 也认识了很多关系不错的大佬，轩哥，张总，罗总，猫咪，飞飞，闲暇之余还会一起约饭，讨论技术，虽然在我毕业之前，他们就都已经毕业了，现在只剩下罗总孤军奋战，感谢他们工作上给予的帮助</p><h4 id="学会交流沟通"><a href="#学会交流沟通" class="headerlink" title="学会交流沟通"></a>学会交流沟通</h4><p>一直觉得自己的iOS 技术落后业界水平，从字节分享的很多文章可以发现，我们的确距离他们差距很大，由此会产生焦虑</p><p>焦虑并不一定是个贬义词，关键在于我们是否能积极应对。今年认识了很多非常优秀的人，这里绝大部分人都是 iOS 领域中的佼佼者</p><p>在遇到比自己强的人时，一定要敢说敢问，我觉得说这个问题一定要重视，可能你自己觉得理解了，但是你说出来，别人会有不一样的看法，以及在说的过程中，你会发现某些点，理解得并不是很透彻，至于问，一定要有不要脸的精神，不怕自己的问题太过于简历，或者观点不符合主流而不敢发声，往往问了之后才能更深刻的理解，要学会与强者为伍，遇强则强</p><h4 id="打算"><a href="#打算" class="headerlink" title="打算"></a>打算</h4><p>接下来打算好好放松放松，总结一下，自己做的项目，工具以及知识点，复习一下八股之类的，之前写了很多笔记文章，由于没有时间都没有上传到 <code>blogs</code> 上，趁现在有时间，整理过后都会发到 <code>blogs</code> 上</p><h4 id="感谢小肥"><a href="#感谢小肥" class="headerlink" title="感谢小肥"></a>感谢小肥</h4><p>最后要感谢我的小肥，知道我被毕业后，第一时间安慰我，虽然我心态还好，还提前买了 <code>Mac Studio</code> 给我当生日礼物，谢谢小肥肥 ~</p><p>2022年，对于互联网来说是寒冷的一年，但是我还是觉得，不管如何，我们都应该抱有希望，努力提升自己的实力才是硬道理 ~</p>]]></content>
    
    
    <categories>
      
      <category>总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SwiftUI基础知识</title>
    <link href="/2022/05/16/SwiftUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/05/16/SwiftUI%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h3 id="SwiftUI基础知识"><a href="#SwiftUI基础知识" class="headerlink" title="SwiftUI基础知识"></a>SwiftUI基础知识</h3><h5 id="状态绑定"><a href="#状态绑定" class="headerlink" title="状态绑定"></a>状态绑定</h5><ul><li><p>声明变量: 在View中使用@State声明变量</p></li><li><p>引用变量: 在body代码中通过self.的方式引用变量</p></li><li><p>转为Binding类型: 通过$前缀转为Binding类型</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">StateDemo</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> isShow: <span class="hljs-type">Bool</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span><br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> counter: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Button</span>(action: &#123;<br>                <span class="hljs-keyword">self</span>.isShow.toggle()<br>            &#125;) &#123;<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;点击切换显示效果&quot;</span>)<br>            &#125;<br>            <span class="hljs-comment">//只需要在State变量前添加一个$前缀，就可以将State转为Binding。</span><br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-variable">$counter</span>) &#123;<br>             <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">ZStack</span> &#123;<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>                    .blur(radius: <span class="hljs-keyword">self</span>.isShow <span class="hljs-operator">?</span> <span class="hljs-number">10</span> : <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.isShow&#123;<br>                    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.counter)</span>&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>为什么在注解后加 private?</strong></p><p>一个@State注解过的变量只会在视图的内部（或者视图内被调用的函数）中访问，所以需要声明为私有变量，以防止被视图的托管方访问。这个声明确实有必要，我个人在实际开发中有个视图内的@State变量忘记声明为私有的，实际预览过程中发生了预知外的错误。</p></blockquote><hr><h6 id="Binding"><a href="#Binding" class="headerlink" title="@Binding"></a>@Binding</h6><p>双向绑定，用于父子视图的双向传递。修改子视图的 <code>Binding</code> 值，会触发父视图的 <code>State</code> 改变重新渲染 <code>body</code> ，修改父视图的State的值同样也会重新通过 <code>Binding</code> 传递给子视图，触发重新渲染 <code>body</code></p><p>使用了 <code>@Binding</code>，外面的变量和里面的变量是绑定在一起的，操作子，父也会变。操作父，子也会变</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SubView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-comment">// 子视图</span><br>    <span class="hljs-meta">@Binding</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> subCounter:<span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-variable">$subCounter</span>) &#123;<br>             <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;SubView:<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.subCounter)</span>&quot;</span>)<br>        &#125;.background(.blue)<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataFlowDemo</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-comment">// 父试图</span><br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> counter: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-variable">$counter</span>) &#123;<br>             <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;MainView == <span class="hljs-subst">\(<span class="hljs-keyword">self</span>.counter)</span>&quot;</span>)<br>            <br>            <span class="hljs-type">SubView</span>(subCounter: <span class="hljs-variable">$counter</span>)<br>            .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="ObservableObject"><a href="#ObservableObject" class="headerlink" title="@ObservableObject"></a>@ObservableObject</h5><p>通过 <code>@ObservableObject</code> 标注的变量 能够传递到下一个视图，有点类似于传入多个<code>@binding</code></p><p>初始化方式 <code>DataFlowDemo2(observeClassDemo: ObserveClassDemo())</code></p><blockquote><p> 需要被绑定的变量 需要加 <code>@Published</code> 注解</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserveClassDemo</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> counter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataFlowDemo2</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> observeClassDemo: <span class="hljs-type">ObserveClassDemo</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-keyword">self</span>.<span class="hljs-variable">$observeClassDemo</span>.counter) &#123;<br>             <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;DataFlowDemo2 == <span class="hljs-subst">\(<span class="hljs-keyword">self</span>.observeClassDemo.counter)</span>&quot;</span>)<br>            <span class="hljs-comment">//此处引入子视图1</span><br>            <span class="hljs-type">ObeservedSubViwe1</span>(observeClassDemo: <span class="hljs-keyword">self</span>.observeClassDemo)<br>            .padding()<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ObeservedSubViwe1</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> observeClassDemo: <span class="hljs-type">ObserveClassDemo</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-keyword">self</span>.<span class="hljs-variable">$observeClassDemo</span>.counter) &#123;<br>             <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;ObeservedSubViwe1 == <span class="hljs-subst">\(<span class="hljs-keyword">self</span>.observeClassDemo.counter)</span>&quot;</span>)<br>            <span class="hljs-comment">//子视图1中在引入子视图2</span><br>            <span class="hljs-type">ObeservedSubViwe2</span>(observeClassDemo: <span class="hljs-keyword">self</span>.observeClassDemo)<br>            .padding()<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ObeservedSubViwe2</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> observeClassDemo: <span class="hljs-type">ObserveClassDemo</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-keyword">self</span>.<span class="hljs-variable">$observeClassDemo</span>.counter) &#123;<br>             <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;ObeservedSubViwe2 == <span class="hljs-subst">\(<span class="hljs-keyword">self</span>.observeClassDemo.counter)</span>&quot;</span>)<br>            .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h5 id="EnvironmentObject"><a href="#EnvironmentObject" class="headerlink" title="@EnvironmentObject"></a>@EnvironmentObject</h5><p>通过 <code>@EnvironmentObject</code> 来提供一个环境对象提供给所有视图共享访问。</p><p> <code>@EnvironmentObject</code> 就像一个单例一样，你可以直接声明 <code>@EnvironmentObject var environmentDemo: EnvironmentDemo</code>就可以直接获取到</p><p>初始化方式 <code>DataFlowDemo3().environmentObject(EnvironmentDemo())</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EnvironmentDemo</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>    <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> counter:<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DataFlowDemo3</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> environmentDemo: <span class="hljs-type">EnvironmentDemo</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-keyword">self</span>.<span class="hljs-variable">$environmentDemo</span>.counter) &#123;<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;MainView:<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.environmentDemo.counter)</span>&quot;</span>)<br>              <span class="hljs-comment">//注意此处不需要对子视图传参</span><br>            <span class="hljs-type">EnviSubView1</span>(counter: <span class="hljs-variable">$environmentDemo</span>.counter)<br>                .padding()<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 这里采用@Binding 实现同样的效果，但是需要父试图传进来counter</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EnviSubView1</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@Binding</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">var</span> counter:<span class="hljs-type">Int</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-variable">$counter</span>) &#123;<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;MainView:<span class="hljs-subst">\(counter)</span>&quot;</span>)<br>            <span class="hljs-type">EnviSubView2</span>()<br>                .padding()<br>        &#125;<br>    &#125;<br>         <br>&#125;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">EnviSubView2</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@EnvironmentObject</span> <span class="hljs-keyword">var</span> environmentDemo: <span class="hljs-type">EnvironmentDemo</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">Stepper</span>(value: <span class="hljs-keyword">self</span>.<span class="hljs-variable">$environmentDemo</span>.counter) &#123;<br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Stepper&quot;</span>)<br>            &#125;.padding(<span class="hljs-number">80</span>)<br>            <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;MainView:<span class="hljs-subst">\(<span class="hljs-keyword">self</span>.environmentDemo.counter)</span>&quot;</span>)<br>                .padding()<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="ForEach创建视图"><a href="#ForEach创建视图" class="headerlink" title="ForEach创建视图"></a>ForEach创建视图</h4><p><code>.id(:\.self)</code> 部分是必需的，以便 <code>SwiftUI</code> 可以唯一地标识数组中的每个元素–这意味着，如果添加或删除一项，<code>SwiftUI</code> 会确切知道哪一个。有点类似于 <code>UIKit</code> 的 <code>Cell标识符</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-type">VStack</span>(alignment: .leading) &#123;<br>    <span class="hljs-type">ForEach</span>((<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">10</span>).reversed(), id: \.<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;<span class="hljs-subst">\(<span class="hljs-variable">$0</span>)</span>…&quot;</span>)<br>    &#125;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Ready or not, here I come!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果数组中有自定义类型，则应将 <code>id</code> 与类型内的任何属性一起使用，以对其进行唯一标识。 例如，您可以创建一个结构，其中id属性是 <code>UUID</code> ，这意味着它可以保证是唯一的-对于我们的目的而言是完美的。 我们可以创建一个这样的结构，然后像这样使用它</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SimpleGameResult</span> &#123;<br>    <span class="hljs-keyword">let</span> id <span class="hljs-operator">=</span> <span class="hljs-type">UUID</span>()<br>    <span class="hljs-keyword">let</span> score: <span class="hljs-type">Int</span><br>&#125;  <br><br><span class="hljs-keyword">let</span> results <span class="hljs-operator">=</span> [<span class="hljs-type">SimpleGameResult</span>(score: <span class="hljs-number">8</span>),<span class="hljs-type">SimpleGameResult</span>(score: <span class="hljs-number">5</span>)]<br><br><span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">VStack</span> &#123;<br>            <span class="hljs-type">ForEach</span>(results, id: \.id) &#123; result <span class="hljs-keyword">in</span><br>                <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Result: <span class="hljs-subst">\(result.score)</span>&quot;</span>)<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h4 id="HSplitViews"><a href="#HSplitViews" class="headerlink" title="HSplitViews"></a>HSplitViews</h4><p>使用 <code>HSplitViews</code> 布局容器，将其子级排列在一条水平线上，并允许用户使用放置在它们之间的分隔符来调整它们的大小。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>   <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>      <span class="hljs-type">GeometryReader</span>&#123;geometry <span class="hljs-keyword">in</span><br>         <span class="hljs-type">HSplitView</span>()&#123;<br>            <span class="hljs-type">Rectangle</span>()<br>                .frame(minWidth: <span class="hljs-number">0</span>, idealWidth: <span class="hljs-number">200</span>, maxWidth: .infinity)<br>            <span class="hljs-type">HSplitView</span>()&#123;<br>                <span class="hljs-type">Rectangle</span>().layoutPriority(<span class="hljs-number">1</span>)<br>                <span class="hljs-type">Rectangle</span>().foregroundColor(.green).frame(minWidth:<span class="hljs-number">200</span>, idealWidth: <span class="hljs-number">200</span>, maxWidth: .infinity)<br>            &#125;.layoutPriority(<span class="hljs-number">1</span>)<br>         &#125;<br>         .frame(width: geometry.size.width, height: geometry.size.height)<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="LazyVStack-与-LazyHStack"><a href="#LazyVStack-与-LazyHStack" class="headerlink" title="LazyVStack  与 LazyHStack"></a><code>LazyVStack</code>  与 <code>LazyHStack</code></h4><p>延迟加载内容（即，仅当内容滚动到视图中时），则应适当使用 <code>LazyVStack</code> 和<code>LazyHStack</code></p><blockquote><p>⚠️ 警告：这些惰性堆栈自动具有灵活的首选宽度，因此它们将以常规堆栈不会占用的方式占用可用空间。 要查看它们之间的区别，请尝试上面的代码，您会发现可以使用文本周围的空白来拖拉，但是如果您切换到常规 <code>VStack</code>，则会看到需要使用文本本身进行滚动。</p></blockquote><blockquote><p>使用惰性堆栈时，<code>SwiftUI</code>将在首次显示时自动创建视图。 之后，视图将保留在内存中，因此请注意显示的内容。</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">ScrollView</span> &#123;<br>            <span class="hljs-type">LazyVStack</span> &#123;<br>                <span class="hljs-type">ForEach</span>(<span class="hljs-number">1</span><span class="hljs-operator">...</span><span class="hljs-number">100</span>, id: \.<span class="hljs-keyword">self</span>) &#123; value <span class="hljs-keyword">in</span><br>                    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Row <span class="hljs-subst">\(value)</span>&quot;</span>)<br>                &#125;<br>            &#125;<br>        &#125;<br>        .frame(height: <span class="hljs-number">300</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="ObservedObject，-State-和-EnvironmentObject-有什么区别？"><a href="#ObservedObject，-State-和-EnvironmentObject-有什么区别？" class="headerlink" title="@ObservedObject，@State 和 @EnvironmentObject 有什么区别？"></a><code>@ObservedObject</code>，<code>@State</code> 和 <code>@EnvironmentObject</code> 有什么区别？</h3><p>在任何现代应用中，状态都是不可避免的，但是使用 <code>SwiftUI</code> 时要记住，我们所有的视图只是其状态的简单功能-我们不直接更改视图，而是操纵状态并由其决定结果。</p><p><img src="https://jaywcjlove.gitee.io/swiftui-example/example/advanced-state/demo1/imgs/1.jpg" alt="img"></p><p><code>SwiftUI</code> 为我们提供了几种在应用程序中存储状态的方法，但是它们有些微的不同，因此，重要的是要了解它们的不同之处，以便正确使用框架。</p><p>使用状态的最简单方法是 <code>@State</code> 属性包装器，其用法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@State</span> <span class="hljs-keyword">private</span> <span class="hljs-keyword">var</span> tapCount <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>        <span class="hljs-type">Button</span>(<span class="hljs-string">&quot;Tap count: <span class="hljs-subst">\(tapCount)</span>&quot;</span>) &#123;<br>            tapCount <span class="hljs-operator">+=</span> <span class="hljs-number">1</span><br>        &#125;<br>        .padding(<span class="hljs-number">100</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这会在视图内部创建一个属性，但是它使用 <code>@State</code> 属性包装器来请求 <code>SwiftUI</code> 管理内存。 这很重要：我们所有的视图都是结构，这意味着它们无法更改，如果我们甚至无法在应用程序中修改整数，那么我们将无能为力。</p><p>因此，当我们说 <code>@State</code> 做一个属性时，我们将其控制权交给 <code>SwiftUI</code>，以便只要视图存在，它就在内存中保持持久。 当状态发生变化时，<code>SwiftUI</code> 会自动将视图的最新更改重新加载到视图中，以便它可以反映其新信息。</p><p><code>@State</code> 对于属于特定视图且永远不会在该视图之外使用的简单属性非常有用，因此，将这些属性标记为私有很重要，以加强这种状态是专门为当前视图视图使用的而设计的。</p><hr><h4 id="什么是-ObservedObject-？"><a href="#什么是-ObservedObject-？" class="headerlink" title="什么是 @ObservedObject ？"></a>什么是 <code>@ObservedObject</code> ？</h4><p>对于更复杂的属性；当您要使用的自定义类型可能具有多个属性和方法，或者可能在多个视图之间共享时，通常会使用 <code>@ObservedObject</code>。</p><p>这与 <code>@State</code> 非常相似，不同之处在于，我们现在使用的是外部引用类型，而不是简单的本地属性（例如 <code>String</code> 或 <code>Integer</code>）。您仍然说的是，视图依赖于会发生变化的数据，但现在您负责管理自己的数据除外-您需要创建该类的实例，创建其自己的属性，等等。</p><p>与 <code>@ObservedObject</code> 一起使用的任何类型都应符合 <code>ObservableObject</code> 协议。在将属性添加到可观察对象时，您可以决定是否对每个属性进行更改都应强制正在刷新正在监视对象的视图。您通常会这样做，但这不是必需的。</p><p>观察对象可以通过多种方式通知视图重要数据已更改，但是最简单的方法是使用 <code>@Published</code> 属性包装器。如果需要更多控制，也可以从 <code>Combine</code> 框架使用自定义发布者，但是实际上这很少见。如果可观察对象使用其数据碰巧有多个视图，则任一选项都会自动通知所有对象。</p><p>警告：当您使用自定义发布者宣布您的对象已更改时，这必须在主线程上发生。</p><hr><h4 id="什么是-StateObject"><a href="#什么是-StateObject" class="headerlink" title="什么是 @StateObject?"></a>什么是 <code>@StateObject</code>?</h4><p><code>@State</code> 和 <code>@ObservedObject</code> 之间的某个位置是 <code>@StateObject</code>。 这是 <code>@ObservedObject</code> 的专用版本，其工作方式几乎完全相同：您必须遵守 <code>ObservableObject</code> 协议，可以使用 <code>@Published</code> 将属性标记为引起更改通知，并且当对象改变时，所有监视 <code>@StateObject</code> 的视图都将刷新。</p><p><code>@StateObject</code> 和 <code>@ObservedObject</code> 之间有一个重要的区别，那就是所有权 – 哪个视图创建了该对象，以及哪个视图仅在监视它。</p><p>规则是这样的：无论哪个视图是第一个创建对象的视图，都必须使用 <code>@StateObject</code> 来告诉 <code>SwiftUI</code> 它是数据的所有者，并负责保持其活动状态。 所有其他视图必须使用 <code>@ObservedObject</code>，以告诉 <code>SwiftUI</code> 他们想监视对象的更改，但不直接拥有它。</p><hr><h4 id="什么是-EnvironmentObject"><a href="#什么是-EnvironmentObject" class="headerlink" title="什么是 @EnvironmentObject?"></a>什么是 <code>@EnvironmentObject</code>?</h4><p>您已经了解了 <code>@State</code> 如何为类型声明简单属性，该类型在更改时会自动刷新视图，以及 <code>@ObservedObject</code> 如何为外部类型声明属性，当更改时可能会或不会导致视图刷新。这两个都必须由您的视图设置，但是 <code>@ObservedObject</code> 可能与其他视图共享。</p><p>还有另一种可以使用的属性包装器，即 <code>@EnvironmentObject</code>。这个值可通过应用程序本身提供给视图，它是每个视图都可以读取的共享数据。因此，如果您的应用程序具有一些重要的模型数据，所有视图都需要读取这些数据，则可以将其从一个视图到另一个视图，或者只是将其置于每个视图都可以即时访问它的环境中。</p><p>当需要在应用程序中传递大量数据时，<code>@EnvironmentObject</code> 可以为您带来极大的便利。由于所有视图都指向同一模型，因此，如果一个视图更改了模型，则所有视图都将立即更新-这样就不会冒着使应用程序的不同部分不同步的风险。</p><hr><h3 id="总结差异"><a href="#总结差异" class="headerlink" title="总结差异"></a>总结差异</h3><p>初始化 <code>ObservableObject</code> 时，应使用 <code>@StateObject</code> 而不是 <code>@ObservedObject</code>。 您的视图可以接收其他视图拥有的对象，例如 <code>@ObservedObject</code>或<code>@EnvironmentObject</code>，但是数据的所有者应始终使用 <code>@StateObject</code> 创建数据对象。</p><ul><li>将 <code>@State</code> 用于属于单个视图的简单属性。 通常应将其标记为私有。</li><li>将 <code>@ObservedObject</code> 用于可能属于多个视图的复杂属性。 大多数情况下，您应该使用引用类型 <code>@ObservedObject</code> 。</li><li>对于您使用的每个可观察对象，请使用 <code>@StateObject</code> 一次，无论代码的哪个部分负责创建它。</li><li>将 <code>@EnvironmentObject</code> 用于在应用程序其他位置创建的属性，例如共享数据。</li></ul><p>在这四个中，如果不确定从哪个位置开始使用。您会发现 <code>@ObservedObject</code> 既最有用，也是最常用的。</p><p><img src="https://raw.githubusercontent.com/krystal1110/markdownPic/master/tuchuang20220808180222.png"></p><hr><p><code>SwiftUI</code> 显示白屏的原因？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span>: <span class="hljs-title class_">ObservableObject</span> &#123;<br>  <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;code&quot;</span><br>  <span class="hljs-meta">@Published</span> <span class="hljs-keyword">var</span> age <span class="hljs-operator">=</span> <span class="hljs-number">26</span><br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ContentView</span>: <span class="hljs-title class_">View</span> &#123;<br>  <span class="hljs-meta">@StateObject</span> <span class="hljs-keyword">var</span> player <span class="hljs-operator">=</span> <span class="hljs-type">Player</span>()<br>  <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>    <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Show  player = <span class="hljs-subst">\(player.name)</span>&quot;</span>)<br>    <span class="hljs-type">NavigationView</span> &#123;<br>        <span class="hljs-type">NavigationLink</span>(destination: <span class="hljs-type">PlayerNameView</span>(player:player)) &#123;<br>          <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Show detail view&quot;</span>)<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">PlayerNameView</span>: <span class="hljs-title class_">View</span> &#123;<br>  <span class="hljs-meta">@ObservedObject</span> <span class="hljs-keyword">var</span> player: <span class="hljs-type">Player</span><br>  <span class="hljs-keyword">var</span> body: <span class="hljs-keyword">some</span> <span class="hljs-type">View</span> &#123;<br>      <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;Hello, <span class="hljs-subst">\(player.name)</span>!&quot;</span>)<br>      <span class="hljs-type">Button</span>(action: &#123;<br>          player.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;456&quot;</span><br>      &#125;) &#123;<br>      <span class="hljs-type">Text</span>(<span class="hljs-string">&quot;点击切换显示效果&quot;</span>)<br>      &#125;<br>  &#125;<br>    <span class="hljs-keyword">init</span>(<span class="hljs-params">player</span>:<span class="hljs-type">Player</span>)&#123;<br>        <span class="hljs-keyword">self</span>.player <span class="hljs-operator">=</span> player<br>        <span class="hljs-keyword">self</span>.player.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;213&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NavigationLink</code> 会预先创建目标  <code>view</code> 的实例，也就是会调用它的 <code>init</code><br>你在 <code>PlayerNameView</code> 的 <code>init</code> 中修改了 <code>player</code>，导致 <code>ContentView</code> 刷新<br><code>contentView</code> 又会初始化 <code>PlayerNameView</code> ，赋值语句会再度导致 <code>ContentView</code> 刷新<br>周而复始</p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-Router架构选择</title>
    <link href="/2022/02/16/IOS-Router%E6%9E%B6%E6%9E%84%E9%80%89%E6%8B%A9/"/>
    <url>/2022/02/16/IOS-Router%E6%9E%B6%E6%9E%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="50a9d6b6103030d7174351571cb6320a7ce8ddc147156e3494cfb23038c1a9cf">30b1ea5aa7108d130862beaedfecbfe153ff63c4b10e9547f907ccac0b01bb559f071db3cff7df306e191c2035e75a21143c719ed1c252878635ca8967048cd77ab3dce5d0489db9cdeb5b88b5a754e693672ea7dfc7b8b49fa5dc4bcdd62d22e66fc38a7652a57496fe15820b29c8b611cf0fa0113b4f7c2ce6813c98862157a464b987822c100e6127d139482b0e787ba3b1d0b9980de3e1b192acdec4f919361880d6c3bb08466b71adfb8de6618f11e06240b01d9922ec1d3c6911a2277b6fb50d85ab0302d93d1d787be2f43af8aa2ad3e08dc189bb2ca287ffea1ec9cac19a8741fadedce83a92bbe6e04f5f1663f9a76fa1664e2f97fe426b469a2963e8a577258bc97fff1738742b7dd400a8ea489ef211cefc7525e92c6baf2ffe2604ce106152e59cae575bc1da4f0a55a690a5242281a6034f4f7ad58b32456c8b3a5f12f001a2a48d530823772798eb85be757e8cac5626bb9bc3c4e03ed63d295c95a1e92e7e54d7f7a7e454680ef3350bfa55e6d310c0ed8c4c67caaad23515d758bd99e615c8f4a91b756c43d6762888a76a4690e2cf9a280a39f7999a894ac1c4317665ebb25e4a4b2f0295b8f72686c03b0bb4d3d394a8a4520c789938c0fd9f9300237a44345e5c2b04c9be7ec570df6fcd5d061d070605236f8cb2456b65c162ced9ff58fa97d010aaf99909fa8ed76682c7a9a43559e235e43b9953c8a72c26d075a8849d85bd4d9110ac0da62789fce3e4acc0b53c1235f88dc900c2cdc555d7bb4edb609f0d73b18873bda848e6fd561310ec6029cb944244e8a4d58ad30f342e72ec7872b50beb22f32523c0f0459045e2c2476f389f24703e8f4178cf1d5beb58571f77e8fc2de102459641532f7d1d6fe8dd3fa928ad56ef7e27406f3c93459859f69c7b536b2113c0f30f8a3cb17f6a4c6ce8a469a71a20a6a4ccf3f7f97a480621179bf49b5742a4ecb3f6eb0160c80c5eb929e9ab62ef6baf96e0d8be3a85f09005cb3c93dfb217e663de54a1a6becfc06ca57d64aa1ea0ba6eeb0c7b57e02410674ade13075399937da9e6529ccdd138e4a6f604d9b6450222b64053926b665c6c5d2558abf44692285e72efcab3d13382a03ece666a44e61ff14c6b5dad10faea8aadea548a344959237527eb514ee5042d55eed6b4970d2942d39b45d1f7c77b8b0928631cb22f1c0bdf54a6f7ce4b09d759c308824e6b3f2e791c76a8d4c5a12abe5c4d04d24abc13c897df8270d86030e27f05213e67245a93358afbf8692b53e316e2bbe381d81e022ec66215357fbd934a937ef3623d53d66d33bb95afba2adc86587198ebe173a62ca7e1869f5c2c2710a442d5606822b9b7432a4b303caecc879727615e181b79e60451738dc854ff9105c8c4577ed2bda0d9c988a60a7f64792cc44e2fedb8a8576a67d9900e5a0d7a791d3e6e8cb220da8a9cc9fb5d2c2e0a8d7387d4331b40a5db92613d67d7770c4ace7a57c8a829e2876c7208199987d04c1d3fb711b9d3d4f5c381869715a29de2876f81531709039362b9b38b0c1d748d39338108752423cdf58d42c5353576767c58ff9e3a6103c83750d577ca3f13cf392a5321d9f17d08035a843717da1a4b0d11b65f655febc842e3d03005c982547904634608ef971f6ce5eb9896c4e52bbd1d1807ff34244456384d873185cc744546541a1f5d6717dfabafccdae39f9b01d616af5cb243dfb3322487044ea4a600fde1466d836f078d32a9bcac8249a9311745b43f8e27bbc3181b8487fd115dbdee9f399af8329df40b01925d10c6b72a89b87b4e374e9a2790a50c16796993167429c3d591228604d424ed8d9067fe92a5363eeab3167ac548aeb47d7a40bc2fe1521bc0ca5d7c308a063955642765c4fedc05853a41460b256e5b4189a89b91d84c5b5a1dd1510427c55d12ccaac75cae47838638c115ec2bb99fc360d59de490630cb751ef289b015f05592a5cf68de3e34efa93aa2bfc8376ffd62c3278b8333b35df615a4612e741fd2994f32275b3a2a519c8a84745698fd2ca5ea30d7cde1da84fbdd8671553bdbfa7484d11440ab0183ec9d54f39c6bdcaee394d4647d539873c9d14f58525ca8c2c55f2808dba096641182a69f87632fb2a0f06e80c8d10cfc8c0aa3f5e29a4ee1831990a2a76cc3830c28688eca193c0f4efff409a2d54490ae90bc77bad55ed119adca5ddcaf92b477a1caf413f18dacf3891fbd33552f524dcca513970c99d01f6067b9e325938ed86eb8fee4a43af76f413255f23a5089e17819e266bff8464a771020693a43cf3971cef547e4e8b1eae271244ca36894d615f910f2c5a3bf95c6840138f0c552e39b738d6b3c00d6da2f928022e431d2b11337ad3541049f4b24c19c2d1b5711fa0a474c0ee2f2058721d1f33ba793f7c066db1011e62caac8f8137058783cf9fb5a6ad2ee845d5c379fc071d2ba32a8da0c1eff6ef61d5febde1fc5aea5abe417421c4fba817ad5710294f4d6b974637a5fc4053741624895cacabbc0beec2100d6fd68680a064dc1e6296ceee72aa23cf14cab13007cdaa7d15b20df17327a5e6fc9f14357833a854126db7bf94aa0c5de124443c0ea35d1b2a9e6a8c780a0d90eab9be0c5249bec745e53c80d8adf37772fae20af9473046b1188e00ecccea86b9825dcc9d1b4ee070a30d9d1f5c4f3e132ad69370739b89ad3b02936528234060c3f7f305758f3d15edbc5480e7cddc44725674da99feec93a81516567aab91ad114f1926225165a5850c991a61e1ef66b51fa52dc3211f926cd238bd7e1a303ad7232e482e9d5a256a9c3fc3b6b826c298b7d77797fae1ec6292566e54f8037f703aee66b9f9cfc07857abb891abaea1f4975dddd0667c4f4060fbc3602517da5ed4648d3e767eba90efa83fe065d4ffdb5cfe8f709b27f3f9b9b06deb1d1a3a62b007afd432052feecbd4a688d08349af15c44d79188d19dbbe2f8334cc69e9dff935bf3e84d36c57d7b105dabde06c6032ab7e8edbf7b5cacb1b41275065424664d7cc39eb25c14bd5352c025d62e497aa2e07f9ce345cbb1b6e71d84d0fa84390eb2037dd40b668d506a35fca28d527f8fa7ed487857cd56cee37631e656d912732dd428ebe2e60629ad25777eb3f713fe53a08c6791c7d3677609aa6ee7c4bb02cf112420a5efd5e48b29dc7ae4dba391b1f02feb0438006e7de723d5b2eb5c973b39f5b56f9bb18530ff424bf0e99aca502fc5b2319f3b017564e9013265f96a6248bc197c9952209d903cf3e038fd03c84929d2f8dbea3d51807e63b40a2c1a91527dacabb30b623536d227cb2ebbc11f52e405aa2a5dd74bbf8c0f2a413d2a686044bf83bb4649f95f76e5b911a830b65d57509e86dbc910b78e7f87dd150f147c779e125ef0e6cfa58be94ec81697696c9e5369222cfd7847cb0961087ee9d392bc188e51360f870d1c043cefb521f7cf90bb0f626c91971f40ef87d0980209f11780366d283ea0054849ce97923d7ceff2b1a8df582adb199f8b2e3a074a4d8d9c1a2074354e062322e8ba2c0fd87dcd4fa7d560c0b456e68a52628a4327b00a96320edbc7e28d7649a7812a32bca1a063c6ca63454c7236bca11e3ead4c860c47002cea520b64050b83bfce92b2a9ca63991eae5e5979f6da1fdb41d7c920fd8671d407f8d4017ac1f2480911886c586cf9992473b8a094d40df6853a7c26babaf6305529fe7da6500a0d3b254e2c2eabbbde76087c59a3e1d736472c22c31f55fce241a103f3deb55d6dea0668ebf0f46302ca0983158a4b44a8ccc19707843c21f5fcd770ec064789e869171810ff8b2b5ed3cc7609b13fbe83e50f75b86473ff68bd02b505bc2a1b2c28310318c91ec5e1400e904a2bc4177626c04004b83a5c793332c8bc2d26f91ec4f0907728fe8f6c253ae24f287f846a2fae68b35f5cb01482a1d1ba8a0fe0e3e1ce81b0d8784f121c4c017a99e33a4a076abe46118c861a48b7a80e997d499de84f4c8ea7c658450d6f6753fb8395d948a46d048722eda7c11667c3628f316ff53a5bf2fcbc475edbc3bbaeb1f970f1d984bac6235296ab9b7904162b3f92ec13b17db528eaffb2c7a604581834e22ac05cf22eef64cf87b8ec537516a1f2dd52cb0cb7f54356578055958c0d1c0990798e55916ff2e999d9d12ebe7dac67b033e0a4ccb1ab70770e7ff36736bd001e18de0879d666b423b10b41e8b3fb1b38639574822ff7aff21ecbc33b2cdf776a0523b9b365f2053ead74743f3e5cad938310f48204af4ae7ec7c4b92e126a2c63ad2141fd198738bac967546babd9bd3b57f9297d8e7d7ce93119591e08810301f55d2982b4eddcd79f345f8339fe47e163c79c35801b74d001c8831733fb352ef0f92ec47100dee9b9427b3c666c255e82d45f2f4762061605650c465b7da65f206e88d16de5370a3a251d3e10ea01793cb4fd277a3fb89fbc872c3ce873149ee1a27b4f2ea103f9eb93fb9270c2747f9d9131ac4d7e0f50663febcb12b024fe116ef49516837a910ffcb2967a0bffacfa6262e8f72f20414bfd9fcf0bac77180a9ef023e23d11029d5e0ba247130d2465ec517a410d50abec75d80651dee2b99b3934a212a70cc74c2263528721925cf7319c72a16fbcee62c4f085aeb6e6a184add2b1ae09f81b6a3c49347ab5668897fc3fb52bcfa1ed873ee6f3401b64fa72b1bafc8c3cfce5eff4b757397fed02d63595c69f27bfc71f608ff71099a1dd4e254cf9747e45d25e0c81f3ccf2ae5b51a4feea86c3b42720d1383aee1bb07bebfe9f3c972c9693dfea76173668e58bb33a3dff68db81f127ccfdabaddaa9eba999499a6dceb50d1d6d70564d78ee2cb255a292088b292e691791b62b028b1545e698e86c2ed0fbbf5012d746fdc6d411db5b5a3a038303851c8994be4d92346f50b7ccfc81bb8247deb504f019c2097cd9edbefdd170f913ed5a18268b1942186e53a7f475dffaab167f7361b3dc4928dd3a71fb0dd226f13c149a4285992979252db05059a4fe9ab3c170</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-ld段位移</title>
    <link href="/2022/02/10/iOS-ld%E6%AE%B5%E4%BD%8D%E7%A7%BB/"/>
    <url>/2022/02/10/iOS-ld%E6%AE%B5%E4%BD%8D%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="TEXT-段迁移的原理"><a href="#TEXT-段迁移的原理" class="headerlink" title="__TEXT 段迁移的原理"></a>__TEXT 段迁移的原理</h3><p>程序的构建过程包含 预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接 等 4 个主要阶段，完成之后就会得到 Mach-O 可执行文件。</p><p>通过 $ man ld ，可以发现链接器有一个参数: -rename_p orgSegment orgSection newSegment newSection。使用该参数可以将orgSegment&#x2F;orgSection的名称修改为newSegment&#x2F;newSection。</p><p>可以在 Other Linker Flags 中传递该参数。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">-Wl,-rename_p,__TEXT,__text,__BD_TEXT,__text<br>-Wl,-segprot,__BD_TEXT,rx,rx<br></code></pre></td></tr></table></figure><p>其中 -Wl 的作用是告诉 Xcode 它后面的参数是添加给 Ld 链接器的，这些参数将在链接阶段生效。</p><p>第一行参数会新创建一个 __BD_TEXT 段，并把<code> __TEXT</code>  ,<code>__text </code>移动到 __<code>BD_TEXT</code>，<code>__text</code>。</p><p>第二行参数是给 <code>__BD_TEXT </code>赋予可读和可执行权限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__const,__RODATA,__const&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用 <code>-rename_p</code> 需要关闭 <code>Bitcode</code> </p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h5 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h5><p>Crash 的原因是执行代码时找不到指定的节</p><p>操作系统只关心段的读&#x2F;写&#x2F;执行权限，并不关心段或节的名称。即便是使用了<code>-rename_p</code> 移动 Segment&#x2F;Section，各符号的地址也会由链接器修正好，因此段移动后程序也可以正常运行。</p><p>但是如果代码指明了要读取 __TEXT 中的某个 Section ，那么这个 Section 就不能够被移动，否则代码就无法读取到它，就会导致出错。</p><p>首先，dyld 在启动阶段会检查 <code>__unwind_info</code> 和 <code>__eh_frame</code> 这两个 Section。如果移动这两个 Section，在启动后程序就会 Crash。</p><p>第二，Swift 相关的 Section 不能移动，否则会引起 Crash。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">__TEXT,__swift5_typeref<br>__TEXT,__swift5_reflstr<br>__TEXT,__swift5_fieldmd<br>__TEXT,__swift5_types<br>__TEXT,__swift5_capture<br>__TEXT,__swift5_assocty<br>__TEXT,__swift5_proto<br>__TEXT,__swift5_protos<br>__TEXT,__swift5_builtin<br></code></pre></td></tr></table></figure><h5 id="链接失败"><a href="#链接失败" class="headerlink" title="链接失败"></a>链接失败</h5><p><code>__TEXT</code> 段迁移最难解决的问题是链接失败问题，是由 CPU 对寻址范围的限制以及 ld64 链接器的缺陷导致。</p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-启动优化</title>
    <link href="/2022/02/08/iOS-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/02/08/iOS-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="启动埋点"><a href="#启动埋点" class="headerlink" title="启动埋点"></a>启动埋点</h4><p>启动终点记录方案</p><ul><li>iOS 12 及以下：root viewController 的 viewDidAppear</li><li>iOS 13+：applicationDidBecomeActive</li></ul><h5 id="分阶段埋点"><a href="#分阶段埋点" class="headerlink" title="分阶段埋点"></a>分阶段埋点</h5><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1spfcisjuj21080dhmxy.jpg"></p><p><code>+load</code>、<code>initializer</code>的调用顺序和链接顺序有关，链接顺序又是按照 cocopods的 pod 命名升序排列，所以取一个命名为 AAA 开头的 pod ，可以让<code>+load</code>以及 <code>initializer</code> 第一个被执行</p><p>需要记录的点有: </p><ul><li>进程创建的时间<ul><li>通过 <code>sysctl</code> 系统调用拿到进程创建的时间戳</li></ul></li><li>第一个+load&#x2F;第一个initializer<ul><li>通过 AAA 为前缀命名 Pod，让 +load 第一个被执行</li></ul></li><li>main开始</li><li>finishLaunch开始<ul><li>一般<code>didFinishLaunching</code>当中优先应该执行监控APM，所以用监控APM的初始化时间作为开始</li></ul></li><li>finishLaunch结束<ul><li>当方法执行完毕记录</li></ul></li><li>启动埋点<ul><li>获取<code>CA::Transaction::commit()</code>方法被调用的时间</li></ul></li></ul><p><strong><code>CA::Transaction::commit()</code>是通过 Runloop 来驱动的，依次的时机为</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1spp21exjj20t3059t8v.jpg"></p><p>可以通过在 <code>didFinishLaunching</code> 中向 Runloop 注册 block 或者 BeforeTimer 的 Observer 来获取上图中两个时间点的回调 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (@<span class="hljs-built_in">available</span>(iOS <span class="hljs-number">13.0</span>, *)) &#123;<br><span class="hljs-comment">//注册kCFRunLoopBeforeTimers回调</span><br>CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop];<br>CFRunLoopActivity activities = kCFRunLoopAllActivities;<br>CFRunLoopObserverRef observer = <span class="hljs-built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, activities, YES, <span class="hljs-number">0</span>, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;<br>    <span class="hljs-keyword">if</span> (activity == kCFRunLoopBeforeTimers) &#123;<br>        NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970];<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;runloop beforetimers launch end:%f &quot;</span>,stamp);<br>        <span class="hljs-built_in">CFRunLoopRemoveObserver</span>(mainRunloop, observer, kCFRunLoopCommonModes);<br>    &#125;<br>&#125;);<br>   <br><span class="hljs-built_in">CFRunLoopAddObserver</span>(mainRunloop, observer, kCFRunLoopCommonModes);<br><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 注册block的方式获取</span><br>    CFRunLoopRef mainBlockRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop];<br>    <span class="hljs-built_in">CFRunLoopPerformBlock</span>(mainBlockRunloop,NSDefaultRunLoopMode,^()&#123;<br>        NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970];<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;runloop block launch end:%f &quot;</span>,stamp);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取首屏渲染的方案"><a href="#获取首屏渲染的方案" class="headerlink" title="获取首屏渲染的方案"></a><strong>获取首屏渲染的方案</strong></h4><p>**<font color="#EA7500">iOS13（含）以上的系统采用 <code>runloop</code> 中注册一个 <code>kCFRunLoopBeforeTimers</code> 的回调获取到的 App 首屏渲染完成的时机更准确。</font>  **</p><p>**<font color="#EA7500">iOS13 以下的系统采用 <code>CFRunLoopPerformBlock</code> 方法注入 block 获取到的 App 首屏渲染完成的时机更准确。</font>  **</p><h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><p>如何保证测试数据的准确性，通过控制变量的方式：</p><ul><li>关闭 iCloud &amp; 不登录 AppleID &amp; 飞行模式</li><li>风扇降温，且用 MFI 认证数据线</li><li>重启手机和开始下一次测试之前静置一段时间</li><li>多次测量取平均值 &amp; 计算方差</li><li>Mock 启动过程中的 AB 变量</li></ul><p>防止启动劣化，可以做以下准入条件</p><ul><li><p>新增动态库</p></li><li><p>新增+load和静态初始化</p></li><li><p>新增启动任务</p></li></ul><p>上述都可以在 <code>git</code> 提交时，写脚本进行检测，最后<code>Code Review</code></p><p> <code>Xcode MetricKit</code> 本身也可以看到启动耗时：打开 Xcode -&gt; Window -&gt; Origanizer -&gt; Launch Time</p><h4 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h4><h5 id="当我们做数据统计的时候，需要注意的点是"><a href="#当我们做数据统计的时候，需要注意的点是" class="headerlink" title="当我们做数据统计的时候，需要注意的点是"></a>当我们做数据统计的时候，需要注意的点是</h5><ul><li><p>**<font color="#EA7500">发版本的前几天启动速度会变慢，这是因为iOS13之后更新APP的第一次启动需要创建启动闭包，这个过程比较慢，之后就会有缓存了，所以我们需要判断APP更新过后是不是第一次启动</font>  **</p></li><li><p>统计启动时间的时候，需要把手机型号，系统也一定统计进去</p></li></ul><h3 id="找出耗时点"><a href="#找出耗时点" class="headerlink" title="找出耗时点"></a>找出耗时点</h3><h4 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a>Time Profiler</h4><p>**<font color="#EA7500">默认 Time Profiler 会 1ms 采样一次，只采集在运行线程的调用栈，最后以统计学的方式汇总。比如下图中的 5 次采样中，method3 都没有采样到，所以最后聚合到的栈里就看不到 method3。所以 Time Profiler 中的看到的时间，并不是代码实际执行的时间，而是栈在采样统计中出现的时间。</font>  **</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1tbziz0g5j21080lhdhq.jpg"></p><p>Time Profiler 支持一些额外的配置，<strong>如果统计出来的时间和实际的时间相差比较多，可以尝试开启</strong>：</p><ul><li>High Frequency，降低采样的时间间隔</li><li>Record Kernel Callstacks，记录内核的调用栈</li><li>Record Waiting Thread，记录被 block 的线程</li></ul><h4 id="System-Trace"><a href="#System-Trace" class="headerlink" title="System Trace"></a>System Trace</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8635a869aa06443c9ff91ecafb09d024~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>既然要精细化分析，那么我们就需要标记出一小段时间，可以用 Point of interest 来标记。除此之外，System Trace 分析虚拟内存和线程状态都很管用：</p><ul><li>Virtual Memory：<strong>主要关注 Page In</strong>这个事件，因为启动路径上有很多次 Page In，且相对耗时</li><li>Thread State：<strong>主要关注挂起和抢占两个状态，记住主线程不是一直在运行的</strong></li><li>System Load 线程有优先级，高优先级的线程不应该超过系统核心数量</li></ul><h4 id="os-signpost"><a href="#os-signpost" class="headerlink" title="os_signpost"></a>os_signpost</h4><p>os_signpost 是 iOS 12 推出的用于在 instruments 里标记时间段的 API，性能非常高，可以认为对启动无影响。结合最开始讲的分阶段监控，我们可以在 Instrument 把启动划分成多个阶段，和其他模板一起分析具体问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//耗时统计</span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(BOOL)animated &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     统计这段区间的执行次数,耗时,等等,更加直观</span><br><span class="hljs-comment">     SP_BEGIN_LOG(systemname, category, name);</span><br><span class="hljs-comment">     systemname:自定义,可以用bundleId</span><br><span class="hljs-comment">     category:在timeprofile中统计分类时使用,相同的扼categroy在同一个分类下</span><br><span class="hljs-comment">     name:具体统计名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">SP_BEGIN_LOG</span>(custome, gl_log, viewDidAppear);<br>    [super viewDidAppear:animated];<br>    [NSThread sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;viewDidAppear&quot;</span>);<br>    <span class="hljs-built_in">SP_END_LOG</span>(viewDidAppear);<br>    <br>    <br>    <span class="hljs-type">os_log_t</span> m_log = <span class="hljs-built_in">os_log_create</span>(<span class="hljs-string">&quot;custome&quot;</span>, <span class="hljs-string">&quot;gl_log&quot;</span>);\<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-type">os_signpost_id_t</span> signid_1 = <span class="hljs-built_in">os_signpost_id_generate</span>(m_log);<br>        <span class="hljs-built_in">os_signpost_interval_begin</span>(m_log, signid_1, <span class="hljs-string">&quot;asynctest&quot;</span>);<br>        <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;打印的第%d遍&quot;</span>,i);<br>            <span class="hljs-built_in">os_signpost_interval_end</span>(m_log, signid_1, <span class="hljs-string">&quot;asynctest&quot;</span>, <span class="hljs-string">&quot;index%d&quot;</span>,i);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1tvc3xt5ij20u20h8769.jpg"></p><p>这边因为我在<code>viewDidAppear</code>中设置了睡眠2s，所以上图中时间是2.00s</p><p>其实我for循环了10次，也就是打印了10次<code>asynctest</code>，最后的count为10</p><p>**<font color="#EA7500">我们可以结合swizzle，os_signpost来达到统计的效果，hook所有的load方法，来分析启动时所有load的耗时，hook所有的UIImage加载方法，来统计启动路径上用到的图片加载耗时时间</font>  **</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe2e95368914aabbd06594917b16a4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><ol><li><strong>删</strong>掉启动项，最直接</li><li>如果不能删除，尝试<strong>延迟</strong>，延迟包括第一次访问以及启动结束后找个合适的时间预热</li><li>不能延迟的可以尝试<strong>并发</strong>，利用好多核多线程</li><li>如果并发也不行，可以尝试让代码执行<strong>更快</strong></li></ol><h4 id="man函数之前"><a href="#man函数之前" class="headerlink" title="man函数之前"></a>man函数之前</h4><p>我们来回顾一下 main 函数之前做了什么事情</p><ul><li>加载 dyld</li><li>创建启动闭包（更新 App&#x2F;重启手机需要）</li><li>加载动态库</li><li>Bind &amp; Rebase &amp; Runtime 初始化</li><li>+load 和静态初始化</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ufro38k8j210802yt8x.jpg"></p><h5 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h5><p>减少动态库数量可以减少启动闭包创建和加载动态库阶段的耗时</p><p>推荐的方案</p><ul><li>动态库转静态库</li><li>非必要动态库转为懒加载形式</li></ul><h5 id="无用代码检测"><a href="#无用代码检测" class="headerlink" title="无用代码检测"></a>无用代码检测</h5><p>基于 Mach-O 的静态扫描</p><ul><li><code>_objc_selrefs</code> 和<code>_objc_classrefs</code> 存储了引用到的 sel 和 class</li><li><code>__objc_classlist</code> 存储了所有的 sel 和 class</li></ul><p>二者做个差集就知道那些类&#x2F;sel 用不到，但<strong>objc 支持运行时调用，删除之前还要在二次确认</strong></p><h5 id="load-方法迁移"><a href="#load-方法迁移" class="headerlink" title="+load 方法迁移"></a>+load 方法迁移</h5><p><strong>+load 除了方法本身的耗时，还会引起大量 Page In</strong>，另外 +load 的存在对 App 稳定性也是冲击，因为 Crash 了捕获不到。</p><p>例如一些非必要执行的方法，可以放到main之后执行的，可以延迟执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span>&#123;<br>    <span class="hljs-type">char</span> *className;<br>    <span class="hljs-type">char</span> *method;<br>&#125;;<br><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JYProtocolRegister(_className_,_method_)\</span><br><span class="hljs-meta">__attribute__((used)) static struct JYProtocolInfo JYProtocolInfo##_className_ \</span><br><span class="hljs-meta">__attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,JYLoadDelayData&quot;</span>))) =\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">    .className = #_className_,\</span><br><span class="hljs-meta">    .method = #_method_,\</span><br><span class="hljs-meta">&#125;;</span><br></code></pre></td></tr></table></figure><p><strong>宏提供接口，编译期把类名和方法名写到二进制的指定段里，运行时把这个关系读出来就可以通过objc_msgSend调用了</strong></p><p>DI 的容器需要把协议绑定到类，所以需要在启动的早期(+load)里注册</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (<span class="hljs-type">void</span>)load<br>&#123;<br>    [DICenter bindClass:IMPClass toProtocol:@<span class="hljs-built_in">protocol</span>(SomeProcotol)]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过<strong>宏提供接口，编译期把类名和协议名写到二进制的指定段里，运行时把这个关系读出来就知道协议是绑定到哪个类了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * cls;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * protocol;<br>&#125;_di_pair;<br><br><span class="hljs-comment">// _DI_VALID_METHOD 这个方法只在 debug 模式下存在，为了让编译器保证类型安全。</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DI_SERVICE(PROTOCOL_NAME,CLASS_NAME)\</span><br><span class="hljs-meta">__used static Class<span class="hljs-string">&lt;PROTOCOL_NAME&gt;</span> _DI_VALID_METHOD(void)&#123;\</span><br><span class="hljs-meta">    return [CLASS_NAME class];\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">__attribute((used, section(_DI_SEGMENT <span class="hljs-string">&quot;,&quot;</span> _DI_SECTION ))) static _di_pair _DI_UNIQUE_VAR = \</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">_TO_STRING(CLASS_NAME),\</span><br><span class="hljs-meta">_TO_STRING(PROTOCOL_NAME),\</span><br><span class="hljs-meta">&#125;;\</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>__attribute((used, <span class="hljs-built_in">section</span>(_DI_SEGMENT <span class="hljs-string">&quot;,&quot;</span> _DI_SECTION ))) <span class="hljs-type">static</span> _di_pair _DI_UNIQUE_VAR = \<br>&#123;\<br>_TO_STRING(CLASS_NAME),\<br>_TO_STRING(PROTOCOL_NAME),\<br>&#125;;\<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h5 id="静态初始化迁移"><a href="#静态初始化迁移" class="headerlink" title="静态初始化迁移"></a>静态初始化迁移</h5><p>大多数静态初始化引起的 Page In，一般来自 C++ 代码</p><p>迁移思路：</p><ul><li>std:string 转换成 const char *</li><li>静态变量移动到方法内部，因为方法内部的静态变量会在方法第一次调用的时候初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Bad</span><br><span class="hljs-keyword">namespace</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string bucket[] = &#123;<span class="hljs-string">&quot;apples&quot;</span>, <span class="hljs-string">&quot;pears&quot;</span>, <span class="hljs-string">&quot;meerkats&quot;</span>&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">GetBucketThing</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> bucket[i];<br>&#125;<br><br><span class="hljs-comment">//Good</span><br><span class="hljs-function">std::string <span class="hljs-title">GetBucketThing</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string bucket[] = &#123;<span class="hljs-string">&quot;apples&quot;</span>, <span class="hljs-string">&quot;pears&quot;</span>, <span class="hljs-string">&quot;meerkats&quot;</span>&#125;;<br>  <span class="hljs-keyword">return</span> bucket[i];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Main函数之后"><a href="#Main函数之后" class="headerlink" title="Main函数之后"></a>Main函数之后</h4><p>最好需要一个启动器来管理启动项，所以的业务仓库需要实现启动器的协议来表明这是个启动任务，里面会有启动任务的顺序和执行线程</p><ul><li><p><strong>全局并发调度</strong>：比如 AB 任务并发，C 任务等待 AB 执行完毕，框架调度还能减少线程数量和控制优先级</p></li><li><p><strong>延迟执行</strong>：提供一些时机，业务可以做预热性质的初始化</p></li><li><p><strong>精细化监控</strong>：所有任务的耗时都能监控到，线下自动化监控也能受益</p></li><li><p><strong>管控</strong>：启动任务的顺序调整，新增&#x2F;删除都能通过 Code Review 管控</p></li></ul><h5 id="三方SDK"><a href="#三方SDK" class="headerlink" title="三方SDK"></a>三方SDK</h5><p>例如环信等三方SDK，如果非必要，可以推迟加载的时间</p><h5 id="高频方法"><a href="#高频方法" class="headerlink" title="高频方法"></a>高频方法</h5><p>如果启动过程当中，会调用很多次的方法，例如读取 Info.plist 里面的配置等等，可以加一层内存缓存，这种问题在 TimeProfiler 中时间段选长可以看出</p><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>锁之所以会影响启动时间，是因为有时候子线程先持有了锁，<strong>主线程就需要等待子线程锁释放。还要警惕系统会有很多隐藏的全局锁</strong></p><h5 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h5><p>线程的数量和优先级都会影响启动时间。可以通过设置 QoS 来配置优先级，两个高优的 QoS 是 User Interactive&#x2F;Initiated，启动的时候，<strong>需要主线程等待的子线程任务都应该设置成高优的</strong>。</p><p><strong>高优的线程数量不应该多于 CPU 核心数量</strong>，可以通过 System Trace 的 System Load 来分析这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">/GCD<br><span class="hljs-type">dispatch_queue_attr_t</span> attr = <span class="hljs-built_in">dispatch_queue_attr_make_with_qos_class</span>(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class="hljs-number">-1</span>);<br><span class="hljs-type">dispatch_queue_t</span> queue = <span class="hljs-built_in">dispatch_queue_create</span>(<span class="hljs-string">&quot;com.custom.utility.queue&quot;</span>, attr);<br><span class="hljs-comment">//NSOperationQueue</span><br>operationQueue.qualityOfService = NSQualityOfServiceUtility<br><br></code></pre></td></tr></table></figure><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p><strong>用 Asset 管理图片而不是直接放在 bundle 里</strong>。Asset 会在编译期做优化，让加载的时候更快，此外在 Asset 中加载图片是要比 Bundle 快的，因为 UIImage imageNamed 要遍历 Bundle 才能找到图。<strong>加载 Asset 中图的耗时主要在在第一次张图，因为要建立索引</strong>，可以通过把启动的图放到一个小的 Asset 里来减少这部分耗时。</p><p> 每次创建 UIImage 都需要 IO，在首帧渲染的时候会解码。所以可以通过提前子线程预加载（创建 UIImage）来优化这部分耗时。<strong>可以在启动的早期开预加载的子线程启动任务</strong>。</p><h5 id="Fishhook"><a href="#Fishhook" class="headerlink" title="Fishhook"></a>Fishhook</h5><p>fishhook 是一个用来 hook C 函数的库，但这个库的第一次调用耗时很高，最好<strong>不要带到线上</strong>。Fishhook 是按照下图的方式遍历 Mach-O 的多个段来找函数指针和函数符号名的映射关系，带来的**副作用就是要大量的 Page In，对于大型 App 来说在 iPhone X 冷启耗时 200ms+**。</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1v540rn8ij21080arq3p.jpg"></p><p>如果不得不用 fishhook，<strong>请在子线程调用，且不要在在<code>_dyld_register_func_for_add_image</code>直接调用 fishhook</strong>。因为这个方法会持有 dyld 的一个全局互斥锁，主线程在启动的时候系统库经常会调用 <code>dlsym</code> 和 <code>dlopen</code>，其内部也需要这个锁，造成上文提到的子线程阻塞主线程。</p><h5 id="段重命名"><a href="#段重命名" class="headerlink" title="段重命名"></a>段重命名</h5><p>因为 iOS13 以下，App Store 会对上传的 App 的 TEXT 段加密，在发生 Page In 的时候会解密，解密的过程是很耗时的，我们可以通过 链接参数将TEXT段中的内容移动到新的段，ld 也有个参数 <code>rename_section</code> 支持重命名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__const,__RODATA,__const&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype&quot;</span><br></code></pre></td></tr></table></figure><p>这种做法的话，需要注意移动的Text段大小问题</p><h5 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h5><p>以下图为例，方法 1 和方法 3 是启动的时候用到的，为了执行对应的代码，就需要两次 Page In。假如我们把方法 1 和 3 排列到一起，那么只需要一次 Page In，从而提升启动速度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80b153b8b17848bda954cab6cb9ae93d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>链接器 ld 有个参数-order_file 支持按照符号的方式排列二进制。获取启动时候用到的符号主流有两种方式：</p><ul><li>抖音方案：静态扫描获取 +load 和 C++静态初始化，hook objc_msgSend 获取 Objective C 符号。</li><li>Facebook 方案：LLVM 函数插桩，灰度统计启动路径符号，用大多数用户的符号生成 order_file。</li></ul><h5 id="动态库懒加载"><a href="#动态库懒加载" class="headerlink" title="动态库懒加载"></a>动态库懒加载</h5><p>运行时通过<code>-[NSBundle load]</code>来加载，本质上调用的是底层的 <code>dlopen</code>。</p><p>动态库懒加载除了启动加载的代码减少，还能长期防止业务增加代码引起启动劣化，因为业务的初始化在第一次访问的时候完成的。</p><p>这个方案还有其他优点，比如动态库化后本地编译时间会大幅度降低，对其他性能指标也有好处，缺点是会牺牲一定程度的包大小，但可以用段压缩等方式优化懒加载的动态库来打平这部分损耗。</p><h5 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h5><p>Background Fetch 可以隔一段时间把 App 在后台启动，对于时间敏感的 App（比如新闻）可以在后台刷新数据，这样能够提高 Feed 加载的速度，进而提升用户体验。</p><p>那么，这种类似“后台保活”的机制，为什么能提高启动速度呢？我们来看一个典型的 case：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fdb6f6a52b146ed868a51824553b681~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><ol><li>系统在后台启动 App</li><li>时间长因为内存等原因，后台的 App 被 kill 了</li><li>这时候用户立刻启动 App，那么这次启动就是一次<strong>热启动</strong>，因为缓存还在</li><li>又一次系统在后台启动 App</li><li>这次用户在 App 在后台的时候点了 App，那么这次启动就是一次<strong>后台回前台</strong>，因为 App 仍然活着</li></ol><p>通过这两个典型的场景，可以看出来为什么 Background Fetch 能提高启动速度了：</p><ul><li><strong>提高热启动在冷启动的占比</strong></li><li><strong>后台启动回前台被定义为启动，因为用户的角度来说这就是一次启动</strong></li></ul><p>后台启动有一些要注意的点，<strong>比如日活，广告，甚至是 AB 进组逻辑都会受影响</strong>，需要做不少适配。往往需要启动器来支撑，因为正常启动在 didFinishLaunch 执行的任务，在后台启动的时候需要延迟到第一次回前台的时候再执行。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://juejin.cn/post/6921508850684133390">抖音品质建设 - iOS启动优化《实战篇》</a></p><p><a href="https://www.jianshu.com/p/d9dc0bbc8535">os_signpost</a></p><p><a href="https://blog.csdn.net/ByteDanceTech/article/details/111878196">今日头条优化实践</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-启动流程</title>
    <link href="/2022/02/04/iOS-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/02/04/iOS-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="dbbbe14b5e36b8c2581fc22c7c54f536315e74fb65cbfae06af1f16ae82e9f0c">30b1ea5aa7108d130862beaedfecbfe1e48f6cd697c63f242ef13d74d2289dedeb29de38eb7cdb5ca46a16db0aba8e9875b9df0296b0993f9441cdd9db0285846e1dbe371efdbbb67200a614b858c1df76a329337cd2ec4f813b915cfb84960dedfa213ca89970489a7f91e4674ff1002a535d30cd2fe90b6d668b1dae9bf30dce75949d7c9a508097b4ba62e49c50b3efea0c922b35d25b980cb5f584383f3bd75a598f75c5c969824af2da333d695fd72aa9621312cb4505b89b8cc15fbfbcdc7e35cc0600d8062ff2bec1f491c3d13290da19c3de431b634c4cf5904135fb86104b723c3a326f2568a3b8aefe27702c7269d955d065a0b3ada9417910d13dfa57974b4309f72797b302fd8a3275dabb627e694912e3012c58620121ff5840960a7d1ad5ce9fa010f6c8507b6de86808b8e0705123128c55ffa9e7083e33efd8fc515d71124082ae523234bb68a2aebdddd46c9fc684c1851375460a633baa1ad5818f7d469fd959a361ddaa91a173dcb77cf00d8b0da0e37c9fb836f64661c501b4c4ec5dfeafb0fea5d380e602f7889d7ad5e902b3c8a7e7924c980cbe87ede415a38241b833b067b1848d205ef6ca6799ea9ebc0720deeb11f50253902ad7befda21d6799f7d4cf4d575262dbce64f1abfeabb7a09c2e3ba114ecb4b0f982f13bc2816249610f52f31fa59058cfdf89b94740f5c4d4448276c09ce9b68118f2d88480b121d807e1dd4109f2b3f142a3c597115358554b7b92588240f79007db51ecee1b916f045c3c76e36ac0329a604ee9caec15d596bdee44113b36f2156f59dd583ca04a622dcf0853cdf08d19fa0f4644d61c53f9b490c3a9910cb3898bbb52da284c9c04352388a9de56c3d5129db9caba5f811ba2eeb21d794750c5b928fde34ca654c93de754b3606925fdb0913ffb10f2559022cec7446eefdb8605e006a48320f5bdc38585a6bfb409ce3ebd17c1a7d35dfe5b27e6f884e9eb5a6842076df959a41397b1eeec81d378e39d2aa54241e6ffc9435b56fa5cea4466c4ba0f548c0fdba76bea3ad2ce25a5d289ac7e28e3d2f680238e58d421650c04efc0c68bc7fc6947cb21d9f76cd6846f477b4e6345ba368dc0750128003f6298e2a2d454f2a1bae1d86cc3ddc8a5a55b54d8c6c05a10ca577eb75c58dd99f396755175793075e3ae792f4e3471b09976ec22eea3a58755ddfbc818982b2df540a47573059d8e4793a13342df50dd20a18284e463e5e3b392c69dc4e939441774c449d703e1c9736c5677dff2fafbe6e9a45907e0419d060663ca65ad666843a64055d3c70ce06741035ac6e90a2ae1608a6520175aeb30b183ec082cb78a886c0387b1c7c27e59ea6f53807c417b0c59dae33ed98580b7f59fd72574cb0a564553f728781ec5717084eb0a19f53720459c6547eabecfd005c7f55fba850cb75143eec43d3e27c0270f47dad3e32078347cd69292f96412743280cff6e1d9febc367a52645031dfbf1f11876a2967fea738f270ffc99ec8de2ec593f71a23ec3494fe1e01f57986104cb8e64d9bc484f586eaf62d7f397df6b67db9651fa407f9ddfd970c6a46faf2317b3543e58b47036519b971b98c29b58fa70ad68c99948a79025c20b3be557e211ac699012129b597da0000849cb2347c6b1df73a72b859804af38ea226ff76511fd4aea4c8f7d24fda36669b4b6971f0e33bcefc0e4a0809dc63d6006eee74c1f7f7c856fa9727ffe7e11efb92f21f66662b6cdb2f424c3f9c4e904a92e4a15c0433ee13151c6ea6787fc06d8f04f289281ed8b960118ae4bf03ade67fc4b1a28967a354f5393f7ebe5db31f87a4b62accea0ad4c27d6d33bdd0158ba6877b0e972c2776127bb8006606536e41fe4a60892082fa95c557966a64a08b22c79766c34f0e852fe96f75e297816c194cf862715d42205d53ba2c0a9d88baba98b60077da9afc5679b9c8260ed8f613912c5eced808af70e633360f9899b3024e036378ce988c1c8fd81e4320abff3059b24e2a75ee23c5d858cb05fdf58e8b456ec0d768d311d52d01c9d1d4786c3afd77f4a5d9fca9bf7b8953bed6b66b6ce6569d14a34d45ce53ba4c64ef4efd97349fb75a0b760c8901318ba74984bc3a22c906073454888a78eb798cd51cb15b73d58a081cb10e1f62b07feea0d407af9cccad5f28a15978f7d560719534be13fdff0e8e8eeb71106eb22171a8bb26423376150df55c3c0c0d78b627c78a836ca0706e9d82aa678deae8ef7ad1af7c4dd77cf13c4c0c86d60968b15e3389e1915532bfcfd545b22611216543e92a59dedcb17f2bed6907fc044d29eb43f24fda694030019e37274cb5eddaacaa6db1c8cb11d78b0f309a883d8838be57b0de2c2f60e19d54d210a0353fce7aa56f08d4b945d0c562eb7f4527d2aecd3a2bfa197289da470de5648ffcac99b917162e168471346172757b9c81ae39da11ea1d7651eeccd0398d0c74b969a817d4f07239b2d4f3bb3d53c59d4a34efc6f6044e10843b5088a9d4cf458382682caac35d0d6a1b9930b5e098a81d5431f7da6e676b7f78d8fd12bef52dcd26c1232ab54d310e197b46ce47c16f64a36a4e4eef961fbf00b7796e9bf28a08c600a2cf61a08b03d9f569bede63155f7878457b2d7491d5fa135650b05bdf0cce9a949ce14df75002ac1bbf71f2ca91bc0a8bc3135ae422a00e0a9a47d66662ae0b3960162db6fc973633fb25a14a9105c806fee9361f91f4a20fbf540d0892a17cb1cb6136fedbb7fe9711601d8481023e4ca9779edb3ed284c0d6a4186b885eacdb3f5c0d459c9c1138af0fc707e5218add21a02f3aadefbad994a82a64abb47a201d8c729b16d7a66f0aab9587301c65cbdc0a1c8826033feda24758549aad7ec2b44d6b0bbec34eedd486b108610a1c185e88835e5c6f5ed1c27c00263128e147cec376d1aff2f29295d3cf07afb52331fe9f9d5b0d3d82d084481942ccecb094a76aa7dd39ed227095c20894879867c3987a7836ba916c3add29c89b5077caae8f47c1421730e961c768522fef354377b14108aaac97ba461e2b57da455598d64e1de2e53cf1a038280627dca1aa673a4573af191d669a0a589ffae0f574e5032c1d4391f7968f3e33bb262e2877238bc83470393aa30aa04011279bbbea5a50cb7a086d29d8b0f1dd8fc2f893c2596f7787283f62a094bb28288105367ce743bb3f4ee23bf6f2fbb0c9d010645f6573d39b4abb19b14eae9150af939a4985911512f1ca8c4aa665b473ec5f4157cd00b58c2d9e62703ce9facd764e4368e825f6035fcfd8710e40c1e08aec997bceefff57d6dc5b750b5a0aa729e3837f9138d03dadb16aee4e4a787c457478a7ed237e2154c6ce2355c71aabba79da4442392dce1561e61220618c29ea84dfa785d2be571e1b79cb6c8cee1b9578547689a7627656d6b3c523bbd698aa3aca789d404973b30701e11945e4508e50206a99deb7265821cc27e168cfa8d7db4703053434791626507b3187ea36c2cfaa1b0ec16562192b7223f52e6f2f6e6753295782b8479ea6182fe1c9634635d7ac56ccf67ce144e6bd1b9754b29a3eb4a978893a44718519fa417d1a170b0a6d09c3f398b381c4151d319a2ff0779b5b21c7f239aeefc79a27a48070f33a29d5c2764ad49b829e8b5b30bbd26e4c034948bb0696c7a0621c08fab193b9c5ff7e68d66d62f75bf7ca73d118ed3d7b84e76b1aa59a69212e5df07d28455f50fcd3fbfed434532f6798ca540758f96a41892cfacb6ac824f2b5e936969d71896b1dda1b5efbd04575851fef0b7ab9be5c8978237db710651d200ff1ff6ec19227cf3259423a23d58cc1432cc3014d28e61e087df18c8adf16434064dbd9c6f07208dcf8bc85a4d1484b806c1aec69839dd03e9a6caa5412876a5414e2406c735cc0ad2f03c27993889045bb26724b0ea7e3ad702a2406981639027567f5bacf1e7958fb08513a45ad90b12292bbea767056f33745c564747a8d49080447771ea8feeb1f44421167e1f2ad7fd2021ee16a087f39d02611017f21827c8d0538ade2be79d2ebf262b9eba637b6311e8d8a1e6f340cdb2561f88a5952bfcf0a636db571a21f1f14ebbcb2e2d03f000e8720dc057e7d7a186ed67a01bb3c78ca0404e392456b00104f781ec15504adb090c8c27299dfebdd12561492ba23f6e2fefcdd1095dc05fbf6f8dd2574aa1476981f519e1855e180d2725511f0a43cd0b8ff4e7411019e8d1a52c3808e7277eb21db10e236a0b7784322d3c6eb77c87ab073cbc0cb26c2dee8b101c68d3edf39b9ddfc6f836d8fd629cb49b4fe7201d24970794bc8ed3879a3a4278d51effdb86b06100c34ff3fcdf6f12d56ad3080ebe8904beaa9d3a2024aeca03071143e7fe4dc11c302861a281f92c86c9656cec4988f0d2fe5464ea3732d97378e0f2e5dfd75e3ebd65b3e473b6f428379fe691a3a383d3b48f21882c64a1484a123281e257cb8327786b98a4f2a0a3bea979675a205590421d07fdac1467bcd59e7b78d14bde73991939ba0965ae9425988913cc82da6e5874701772d9c2b8cd2470098b4730b329a1480808beeab74ecce33b1c5b3f63a41ce74e031a2ad8e24eb6920d3e97228a17a70be295b2229ce912d8457da15649c8351764d6323c5c9ab547650df30a70394a2fff7774ee77716eaa53a639f0f6f8fae04fe2f1b57946ff85d05d91bb921db49fdbd7193a4e5b5a4ddb33ba193667e00c5f1ca3e1bf348f8cd22bd030c28c846e9cb9204a817dfe2e9ce6db1906a26aafff3ebe6c40e1cade7400b94cfcc5cc05924fc249dd1e7d3b1f45e8e40c1467b520b21ffc4d094cab707d327b35f64c15d9cdf3524b810ee1c6407988a7fbd90459b1c27ae7454e14927b23d42c387c6b0fb8078b94fed2ad57d904da53b6c123755b8c466b97b7e6e0a884d524e1a4bc590151f7dfe72328a711564face6f3705ba8d3581e0935a5533c20d2f93795cd074fd5274694c33f9f5a24af2e67c0ad2396421856afa99ff8cd4a752f36cafa13600053fc3dddb55639e3181e7ece139c020603a3c05ce962e775feba3041afe390316893d0950bf98fd84dabdacba5194d19ad8a2b2e197675b17998722f84ed5a305586759c539d3eaf0c9bcea72a9216414e7a9961b01d805f2b2e084e83cb47c146d9f2e1bfcadcbd576ccbd12c122114a838aaf81b5d9a1c512457062b86c7ff81133b842cd3590d05a1b86b19fce2974a82e5dc97f3ee0223c1ae0b30067829502c343c58132d77260732a9d26124ad3f87f9acf7b232a869c5fa9854de09d6642b2e444a0cf7cd08e65e3b83b6de0a44d1e745d493dfb5a5a50dfa4464fd1581a253c83e6cd40c190c2fa6af0384d65645dd7ecc3d1d39396722d32b99673caa191881825d058895189877c056923b6a941af8c1e70f8bcdd8023ee27ebbc1985c3939fb36088910dca4a37b33d8901eb6c98d78beb8b6af340ee427f5b726871bd3cbe14c870c9184be348efe56a03701ed0287f192a23e1224efcdac8c9b3dd011c6cf54b77545d96a568c433889ec6343a706ad4522f389c779d2d041bc2753e753b77179b0171024bfc336acdf534006d12f62194e8136bc765d6dbdd6c0ee826c777ac350a30fd5f201aabbf86dfac4d819495e184a9cb8a1a3bda58f4bd5e50379eb543c3ce367367556431f4ff993633adc585fd5aa91ad79e353e455dab1221d6c5eebead76a3d97d34a9b4beed3161a0751a086fa6a99252dbb474e58c807437c08f80ef70b38268209cba236c47d61e9c73195fc2aeb004dcd6405e3199c02edf8febf0eee0b5f09b0cd19d38ed27ceb472425b6866a8b2cd5c6e52ceef9f871a4d0fe9e8fb317c5203f35d964dd5221085217b12fbbac55b089b7327b00245f1b9e338e31200083c89012e96d6330c7af03dfbd308c8142078f0bf7ef21e9a12120fe7ae3d63a6e1dcbc7bb969027705bcf12f202e1a6d8bead905f41a7c1c829eec6c5e688fa5ade43a9204272313a29ab8492d358be5b02017042e222ed6f590acda02f073c5f39470c53fbb7762415cc23393648e67d2c093f7c1f400bcad01c645c4049652f5b1cbcd62c89cf7e54f8722b2da700128810a185a6340d02ba9be573a26b8a87ec8d99deaab6baf0c30b8d6c42cfe001fb1136ae0b585a47af9fe5fb870285e5f85a58774ee043e4e88a8723f93fa5ff3a00011faa2c80d953371b82492924e13443ea7137905f21f6068236c65b1d5bb451864bcc766312786ecba107756c4a0e9636d02c33180d510550a10d6ba3a296d6932e3ad059b7825cd56fc19910df6e14d13afb2a2fdab639f2cfb2e4688e462a3e31d416692bd9250d6323eecf2ed9cf5a90287b35189d79d6fe1a982dbdd1f9162587d9b592d1aa4659ba4b2494c7c60a68b2228132b763bbabf1e2cc89e9eb66dc8e9a35611f340166c0418b6ee75d0612b1e519462107a6d67fc28b920cdcd8c7ee59db6f061e5a8f35d2705f021a6b83836de7d70ea388597b059e0d32b5078ef3ff5f026eb54760387fdd3306a797dbc25a8beca77e6958b7aed85610648ad0a3fc629e78f8acb463dcb1d5eb4f825e64d7c3265a7c6c09255a03f3a0fa964656c83dc7c1978c826ab96803aae36c3629dbaba6351eea6f7ab3fda47a58b1843f557ca4b82b5693473b8332bc7ff5e157bb6d209c7e800d45d78333156124bda1f8bebd3d035f4142561f58c20fe3aaf9cff090e8b395999bb8eac6f30eb583f4442a15cdb68e751af66a129935b416e168431621884c36a5e7ec501612801208dd55fbee290df6763906232b53151c2295ac9fa918f448fefbb03f09c2d7cbeda9e1ed8ebb244e97e5385b48e6cf9c67889366aa07e0f0abf2fa5e1c63ae14f0b29c0731d574dff0d926f723668f7ba19315f3b0e0952eb5d3dd6d109f9b68d56b6eb0c46bf7ae0bfcdc924d1456c7ff53ef594270f9b7fb63e1ee21f9b06d1d4282aea5ff06c7eef2c4d5c3cb96e3f32380918249457e5b80fca2de6b408a7c9ea045181bf0077c795e700ea777b4b193c4ebe5ec16c71417bd274cb1ee497ac7293cac522e3fffb166f856c5a1fc815df332155418da32f3003e2789dfd72a50be995c3ee4e117b7c545d39a9fd378777ad175e54c43b87d580e8f20cdbbce04cd2c1a31f2c22d4d79e80d8cbc921d751cb767bb88e3c5e446f162090513476615ceac7a4fd6fa42587175891b6d5fabeb28ec083b874b92c308ed196d75d4aa4b093fea719f2e219c908406fce2886d78a0a6322c71022ddb9e5d1d7b4f9a29ad4612f04fc66c213522eeab5d116fba21a1694b2359f11ba095f86e8ebd964403d3fcc3bacdc9efa67eb12fc8ff55e98f51d24beecd8f999b430c8026ab79ce85e3ea35c33f49a2b5e92c045f877a5e82397ec4e42dea28ba3faa2aebc546535b34d8cba5ab7b20e1dfb465ce9d4e08cd91ae99ec39f926b4c075fb2cf64f14216d2dca9243bea7f2cef923971469a9f87e72a84478e226451c9db689f17164b1911fd6d054b5c9f8f9581af088273d964fee3d80f1349c5c303e6e1dcaa51a3337a5e8f37395ba3a968b9bc407fed2cef3dfd9835dcb3adc2fd67019c8269449c7a9e8338ef3cd3c98219cdedbc8aa8cc646b3985a589e9f0b0bfebfa3a1f9d0aee384f59a5535d0c9c8b071e34905cd89777132b1d4e1274ee39ac060d26c159f3068295e935f0b7be41336afb86097ccf12d1d2ac5b73294abb10ce495ad70e07a09caa8b2a1b725ce3a4b86aca966eb26575122fc6b6632c5110c51b1a84f7a9107e28b4905536ed8084d74a3a62900984b5c12a33a5765c472ff12dd4190195cb059f50cc110958b23963159fcce40890bc963bd1b0a5dcf56f2802d39779d61a5eb5fa974554cb015b1d155462d9700b2442431309378b07872e8a655b262d269637a0b453209faff55d768509c2812a467984edb6e01d581b2ef06f9942a4ae7a6c657b5f2dbd816abef2a08f5ffc9fc8f62f5671009589b3ff61ba338f69fe3eb4358ca0194ab69879e40e5dd0f013954dae625913bd884de3268a70dfe5813cfa2121f893acab9bcb5dc1674fdd469fa654cd809b1122bbaca039a7b39bea544944392433f588f420bb2199a3d406e5bff3750ca772ae35b36c3e072cc583a7cfff0e278f555e740e69ae82aeadcf68b6060924191990da75f75ad786166eb9f5de97570f4805920595d23b047f2d48f60c542d794c3e019c48113af503d946489ccda7c8fae95a236680a2f04ef470d6379cdc89e62d96909db4d079da636897a28a5e2455aea70c0edaa11f11c63befbb6468230be689afc6b07e330e9c8743ffa38ee6ce84b6a5a013ce049c59291378bf84f782f751399ebb2cb8e16ccab4e6b53df4b3961c27216a5e801f7170d8c09f23a622f449cda6e27c301f8f561db91f63a0f554fc76104ec7ac57af7627bd56ed19d4f87acd8a29f9607abfc0804232139bd24cae79c540be8db20725ac8c8aa6ad0c85d0bca55bc44cd0d9d206f18a92238458adcab1205ebd74bf8bf7e1baf470c9bddf903ca35f0f19661e6e16c7a923b340a1cf65fe683ffbb0d8de6f574a11c04ad85b1534b6458ef28773dc5601da40033064c8fca1b91e5d33e1aed2414f1ade2cabd1579cf6bd31bfa8bd203b7806510cf757456daabd070523bb73f7476a5f906a9873aca7675e48d20801d9f7e1214df636d8c113afcb7ec569dd8a7eb5c8fc2de0752d8b9e021c0c45d7a7b2f9725e28c77e0a8437cea85a0986d25a5840fdeabb3242a16f65461d83777c85f0833f807398b347f23e769cb5b4fc8460cc46437251b8ae8d383f59223bdde7c893d9b5671b9afe905ccdd16626aa9ab63d3cdeaeb901ba823961089c6925ccc696f223c15bfb47c8546bd26eaea30372e0af2b03894562a256f01d482ce70bad61b2638f6dad09599301e28950f568a3739de941931e3cfe182e0f7ad93d3b9eeefb3306f9c3a425f58da0cc5d6aad450a7f5a6ba1d2c039c32fb7c20bf4ac324dccc725fca4c9a4b16a18d410f7353745538616713e3a152479b6ffd213b671e51d8dc580fd2ecbd7b7fcda3078eee25d03f8a8705f76618713fcb34e3e1a571bfc87630e8059bc798bd890df2d38f4930ba99eb1fe7142633d77e6b0bdf62e0ba08254534eb0dabd39aeccdb50da242dad124ee90a76baac51785e1259b5f6053e2a341f4956b13f194ae30ffa40f7fef7b469db3fb0075b6d93a963fb87670bc609782a978c8edd9739f23332a0699044c8e2242066ee5f1eddaaa8f3b65881a960c271d8dd1fe89aa2e4b50054e9af8f1d3446bef3f4554630b7478c9e902a66918d6f9e94ed38a33eb84debd459ee28e29867a090de0cca9395cf5fc0069f331cce377bf3734df2322ce3e26c7903f0f5848455ccbd23c837da2579b20877dc28089f89d545ce4c2b9ac680e7d71b7d69324fc51290e4005b7eeec5ef4a8dd20d43f9e7ffdd4515ab1efc34903567fa2e3c3096f9d5dfca4bab115f7bef9a0a84fc918e5bc86fb718782468e1088beb122818d193ad841cd71e12df83dec9262d17342f200f29cffc9668a2b6259a42d9674e8e55ff33bd5eead46e179914b9e97bdb7cbc811632d96b37f67e786c0ac1bdb3f06ac043478eea67b0060aaa91faaed03e26b4ae83c046c27d3892f8f1735a7a1ba3f988faab9361c5642c913110a2197fded2cf652ad38f5c96a6016489cc6de04c24e4af1f7ce3b5a86f844c79d7e3d78acd88436359d8e38787290716ff1488b100d084ecaa1ff71ff705fa68feaa162cca1440d5486ead096e3036582e5000dc441e5d8c46920a57aade36e2f669dc8518694ae175443d22abd45a3740b2d7e5652378c6b9e5a02ec6347a9e230fead684bd646741cf1e376614ca51fa62d7af1dcbf222df3a5f5c7c942cd2b37551914be2f8dba28b99d39fd82e031e73b9ffb2a4f9258d9907a036a79080e0942fdd0878b83a0f3774cf8eed601abebdc06df479a516c525a0084e773218b666173b2966d81d3481d2ba00494aaf5a2060f53802e476f98e17605bc8f04d08d7983e6bc3abca89e947d1320494b628f0a64a29f5cbc61b80c13db93348ac464af92183e3718431ae18f226d419794f6d62b703cb268e8c35707df835e421eeaa315d6fdcd5b8c55fac6f6d61a3939cd9acdf386f64db984fcdd67b8b5bba54eeca10b25e2018170aee51a4e95d5c2600968f7f983a61a97f2da297a1b8270e1cb0abdc2266820f397d6be8e128a38f4cc8d84bbb79dd4ed09e0f8db52d37befbc8390846bb467306dbe98f94e219ac4357e5926d99823e051a5a312e39e375a8e2ba817e425a9f69a91166feb1f2c678e314b1dd42f1891b8d86ca6b2d76c5d11e7ded649d28cdcbfad7d1b2d26b2de3ead5dd39c8f42fc83977ccc4073e0f782c02e17b4515fe66418638d4ffefe81492e6c474c47d131e9d0393a8b9f542317de244896bf74f6eddc2f3b09c8125e38985fb8d2eae7ba10239ce16dc470c3d57e9a352e8ff0d96b2330ed5aeb90645bee54551f3cc9b383aafb5b5df4425cc5faf3c51a61fbc35e8e349174c984ea04831e45210e23003a1d6dfda25713b95c96672bb00f478dd497bd32ee23e8c66cf74c6fe0e2884eb09d9b209873605e0394b9b18a721ed95f70d5652714f23d2e486d832be4ca343052130c0f65c39a81e8f5eafca528c856e99034d3537949eaf4bfcd5c8eacb090b01ffb0f783f7ff2d939b5a67b1dc7d8f7d5737347af45a2931a50101ee81c4c40ede7d0c5692e316a59c82a9d83d6ac7364f566d11be25fd84a52caca91b95baf0c7b29694959167dd0198d5507b84c12d5d10a3a1bcc5bbe0ff0727a9b5f806c17ed5f496fe7c254829b832322424b41f118905dd20c3ee7b0053a4b59eb2418ccea3a2aee65ed4323d0f6927145d4a3b4ad3265008cb025066e917f47577cb44128a886d0e7d2e0112febe9e86075808896dcede0657dd98eeeb5b51260e0f5e37ee321208dbff2819f7890240641aa9bd9efaf2b3d357331b709079ad8f04a5a008246a86689925541313b3f1cbf485abc5fdb1ce641e30cba6da3fc3367b842dfea6b184b5aaf4c3c643960071e71b45911dfb983744de7a82541c3404f13cf0b06c3d56e551b52005733ca69f71a9a9cbd4e6aad6b86538630b57a67321318e2524f4700ff6f7f685c6fdabb8fd81dbeb834e3cf01f3e5fea08b17c86e966ae424fa829e7b7cf30cd93d59789172bdd15bae9c2efa3182126ce5a91c95ac2263561ef433c91800ad32bdb46bd6fc09899578143c2030ebfe1ceeda69a2428e1510d044e0b07ebce5d0261a46bfc524cffc6a8bc1dfa916a517a67a25a77f824e1a4eda793f00ccca3db53fe5f159dbedb483906afd544b5924b74157e3ab3e81d6b70a5e46609ad50d50f20840c12fec48c0b8377e0a82e9b2212f9f034d4f90a7649d6a69c1232a2ed372347126800134f601e797bedcc8b4d1a61092a9fcec186eb7c0c0159b2d6fdb5ad882d555dfece255e7784b0146c9ee2bf7ed12f03b2fdb4411a48002489dc8343dc22b509fdf44334cefe8e24f140e6a563f3f9a873fcf08e1724f40ebda1ece8aa805bd605c5a92bcc081abd0875b7c14fbdec1e048a430081fa12de196ba955a782a4040ef309eb2ce6046a5efc0616b09bd975741e6668728275fa793a07b2f3bd5db97ad4ff2e2df6696270db10663256fd3b0a274313c8162e03e61c95af85cfc74b4370f1fdcf32ab20df70cee909882362ac9687ddeb39e64d33c9a5ff49b26499df741460e62002fa92e4825d9413fbe286d5fd5fea899d4594c052d1319f6edadc13f84eb507850ef92e0c931f2975e0a3a3b2583157494428b07db791946914595818ec17c5185a05c2a62149e64d44a7f1c11ad280fa364ede8e44aa0d606600d76c3673576b4fd174aa3a31bf64c109c2d531868d787f4a179283a88469a2ff2903dbaa0f278970c8de07edc68c025a736f0377cf6dcb1a7495c4c50d236be70103df0e79cc2df2fd090237db64c4e27fb4e55d1ebd2a16b1c81b24f63974da2597b95b33588102082b44798bca3f1ee5e9ed8cbc014e37c5f870b97ffcce93bbe212ad93b9a52b319c77295743b291f3bb10df6a8ebfac98bce7fa406604b62fcf857b4fe27a36633d2e48d318fd48a839bb4dc6e3a563bd5d3360d3fe6b2a018f72ae0b0369de407e0ba327c3c99416204ab119af0daca578524a63519d728ab0aceb5f32c4f823cc5b914ebb2a99747097da6cf7fae66a618601d3fe15882ffc95de3a4b649f113af96e42e0cc71c79a036b16c851521dfe78efe40448196d22a7a8b12534c9af59358a1f17c6a3421509e4844eb5ecaf57282e18e60b42a12c837303c250de7c5a270520fcade7e6ae6251ddfed6bb31f10980a0871edc9f681d0ad3095c4083aa4707989efd5b864de203e2d99df086cfecf47f7f137346c9e01419650d0eb64db0a49fc57532ba5fb7ee4623c5866f3da78ca6034e89a5cb5eeaf8de70c57d9705d795b51bb12600aa81eae60edb661e61b156685905e91a40ba1750857e79d550b4ecdcb8c078b0c630c209064fd71fcc86e8b39a5326339a3b9380bdf31ccd399231d784d8f62756f01c52b3cf3e3776fed2b1cf3d8db41d4a17a7c45b4e067239d5e5177556d0bfce1d8a92b09bc38efe696a46aab4418523b0938d8d95d633b83411986159aeea97781e9bbe547a9a7ca03371aa742fc82faa64a81f51c8e4ba6527fe263d96f12cc34affbbf007ddbf89570ee1285418f9e4c4f072d4f1291b5cb8071289a4a68980d27927a6ea546db46c608c5dfad67a4cacb53cc4c0eec8677e74cc7d1cb1609c1e9c312ed03381506de351dc879eb3e0bbe135d58e824b6bd1706df86cb3f79dae924004ce65b5d72caae686e25363f12ebc53f422d7172e15f77d9c85bb78cdaee4c530df3bb65f33341920c6a7aa0f96da334368d12b4f2f573dcbbc29152ae7562237a62367da7f91ed807212d38f4beef2bfc9720aa351c98f0c09436462a60be780166fbad6fc52f5f5ce8e64a783781b87018197669755da0edfee79c6caf432d468f26105797b34655e94c6b2cfc381eb32937c4547736d097202ddd5025d6fcdeed4b2b5fcc9ff2a2ff1f7e5e4b7e57ed9e6f0fdaa653dc71e007d58cf572f013a82628389a585b630f323a8e3c293c584a039f5f6f6039d83456bbcad8fea6f5aaa7c5d2ec258a0e36bd2cab676466f102487a3be27af0bdbe43afa45f6e01729d2b14325d059a0ce5c5b87398525c0d92c8a29509e129b5119aae28d1870da46a78c25a95ae2ccb95be73212ffa7b63ca751dc9fa2c4247f49ae7efb403d457c35b36e9c14ae5fa298b962dc7ff4c6c28d032347dce20762c82e43a671112c084be1ca4a973f2caaab68a3d5e6ea4a10eac976dcee581b5eae046a1b686f8ec2906526e523291118b5569f7128216d7ed9331963981dd3c53eab186bc5bec71ab6c6183e956b21d6c77591b4e43b72eac4fcaed7f7b01dd4836add767f54f47f4fe296f775d219aa51ab08f5d2876e8632ce8cbb77a5d1f95132607224b5b68ebe97225226806c6859b8a87823ce1b3a189e670362a7396d223f6ada2d51e696ea3457eec227af9397b6ea190a73bc850e6ccd48eeff031a36cf236cbd5e016796d1c8dfe537deb48a225643677f1feeb81b1363cb0c2c083a1bfe164e510edd61c11f2bc06dc921f4ab241fa4307cc7a792028de7c0d7df50fb623961fe4658fe5ab05b4033814cec8a0b9507e948e164e4e626a6b2d0b0b4dd02c872169219579c458f3a59d2d862a7d782a01330e5f8bb34849e110a0d8f96042eb0dc265fe5cfc222f3a6bce1c05d75c24bd66799c27a59ab009e422ebe1b21223657a68b5d7ffed11210e176edd5e5a52a9c4adda9f4b277bf37b32d608e109a821509637289d6a23a588e51c4ab6810ae31e5530d9066e4a26abd9b431835f4c3ccb81d4cad0f1746ae60d9cf17386f952611950e61ada95f120d15b0629bf7d1ded87328dbe3bbb926737dfef8eda494c01efc5441012b5b2609f1b95a5aafafdd060f00dd4179682a2d487070c7e085b32e30f633c3e993cbda0fdbc6b89fdccd8a814f3a14317038071542029da85158494cfa2f3707326fa52d33461268bced17602c03b869b82a6461803d8d10eeb5a96a7e306fb66f018d514e1b6cbada17e2dda9b738332b00b64a7e93c7740fa4cc0d57a08594044bc320dcf5664081c390d3e47655e19dcb133a4a9f8a5b67617db385660c0b4edd8a507874468a11a767e06a4cca3e531dcb5fe7a87a1648bc5926da4d77a99c066633b3789f8e5722d5991fb3acd082b64d7729d7e697a8952c34602fb3b0fcb3d3b289a8959e192aecaeeb0898489413a7309acfdb1aee95af4d0cec5771dbbe3e68e56a757ced520bbe549a453f76f954ca300447f34391e35279ce68bdde98a188e883cd00c00bd7ee5091ec7035800caa3131b6dd2d8c081a0d1a4c1b05a3b62c569aff8ea1ec113a308dd19bdaf2d2ab3af64f15b7e6900e24b5ea5b25df12c0bb2b1322bf51c4392a470e3b22371f5262ebd10d9168c5c4206a4c98dbc54719bc6b24882297fa823c89724982b7065a6149427b9a13fa05ecd083729027d16ed80da8b16c3d1965d10ca072b4a656cc14bddbbf3868949f7725f4ece67bd206077fe7289d02147d7b84cae87b2d0994da54823522b168e3f8fe0801c0866b8a7c9bd7b8ffeca8d24676a68fdbaa1273b15b57b21f679692970f63ce0d880988d7db9983d1d31e24abe80ae60b19ae1101bfc5482a982ffa8f01f27f3c80129e6b058491b182be98c9ba2857d3a2246143e997523a4f82ce214b64af31caeb2055c7eec6fae6bd3a7072444236679c98caed9263b7b8b2f425f8385318ad98208bd53738a97a66c6d79cd07e3d745363129b404db320db2982e00a6361140461f783f727188523d1f21c5f17e30151c7906de54b55d385888ce89956c8ee1199630912d9b352bf34c3982cb1539260510976cad9be97a082246812e52e9f7d24172069885ad8c10a784d4548a7976fde665a37642e1786ea8f1fe4cc286ea7c17734e503aa0e6203eb9cea094b115bf8d6423b7421d3edbd907dbdd20ac6a21767cc7119af0880cd54ac9af5ea3fe7f7ee52deba8cef2d0b971ac303d0f2b87b125e5cbb4f6b685eb563c8452886dbc2b216b2040f0a9d84d1ceac1413bee8119e47ebc347a0bbbc9d38da416ac4c8063fca0983802fd0e2e16a8c9237eba70484bc3c37bf8172e3e0ffc26e26dc8e840a78187784d8e4ef860fcd14a3ee5c593fbe1ed02d6552e277fe0ec276b9b66904226365300fa2679c7a2f70085f043110223aed433dacf07825b90d77f28fa35802c8626096e709637c2e848ef5a43d5f8689305dcbce776fd3863c7ec29338e454fa9b16946e58ff184521f84269044662e4f7070ca9b285c7642697b27755ed74a264bd09cf4697437465b38ccb665436e636b233602fa347f53ecbf622ce85dfbbd738b2647ee4ef79448214ec9f292281c5271effaa6671a7f211d10e9c67094f907a448e600fb10ebb28d69fad8ee60cca81474ab5e9f6cce647ee7c872e735489c3d0f70968b32a0ae5018382ad87e3409fbb067f7079fe210c84d995dd80b3a12b7b1d4f9d8d0d202697098486432fd0fafebc11c7886e84fd698543fa970588e7bdbe589d56bc8934f321b0af8babed33a2433224cc8f44d725377c0933e6ecb5c0638501678580243dec3ee253c0f05210b844c21965853d7b4d04147923c823d2569d1017ac56159cf45fc4f92f6f9d3a38a1df024b1344082f8bf9c4ff32bcf566ef5a49f7a96a07e31a13d247c1dbcef7376d0a76b055b9782784aa0d20a6f4b202a33f9f06d09f33cd2ba77c7e532e03b8139365dd5299700bbda77d91d93e780bad4c0e6b8c380132067874ce7b3647547978496cfef89deade06a894bb8145cb10bcaf8e93cf10afcd0e10b632aff900cdbc04e362f68de2e055164009d9e5ac554364c7babf1b3bc36d4f83d7f607dfa99f8ef95216b5ca84dd1eb523fae017b4bcb8e6cfab0667c243685b7ab0de68b3050746cc81e1f4ea5abfc8dfe7a50877086109e4798b96590648368459b240ec33503da2ca690d7950a17f3dadfcc8f09376df67b7418821deb4aa906924af710d91fb093298265d14a0c729717fce07bcab5a8fdcd64550c5d638b2703ff6bbc41be4d6ff76492f73a174808a826bbd3d82d8bba23f59bc09ef740602800286a7f588af70b2b3b3424152f11211d94b3ca7fc7e8772403358fd70c8a598581be0e27124938b43168221b36f1468c2c730e11487b96cd69f14d3ee927091f17faae12ecd0484d37f3a61532cedf3d7d6c868bec3f26f18a7a68f1bbf78159996979e7d433aff503516845eace4c30ccafb9d97fa41179ce3218e18c9c28125a88e5161308d278d9c52e54765c3646a4f660d0a2b208fdb010ad9fc43d19673ad6fb9a8b9665fc7929d39a8a00ff086bdc83f68527685625a0c3e628707e7807b41982b988d259cd5630b34f221f859b2672b4c1b5e5172d2ecd55a50d1189656ac5d5e062d0a9d0ffda85f08ae42fdd65cb600313a93f32642c7edeb7cef7e38653ff16cfae2b36c723b9b0bce86fe7abd3f81c27ed9cfb146dd077839690122bbb026cceea7a748cd5f0618c056b7d34587503196dc37aa03501930ce25a50b40a75b37f777d1fdc8696556e5e5b89d5b61bf62ca162e9054237014bba26b1d65a60abf2b4d0f8f51ee9cb06533df1bf2d39d89bb54ecf9f8de1824f0bcf71dd81cb24375f268a0236c265d5e9515a405c2bc7fcfab119423299e820b243c959295fe6c1c5de1c234f98ad1e13fc5f61f9ff2b9649b4df029f61047d20e147bd8185dd46fc25f7addef434016f923d7a2928984cb36c3ef02e14407dd34fbbfedb612771e8a9f3b64ae513c03eab802b4e04b59526f5ce5b254af8d49e7ff4bb800540b189d633406a3f6e1eb733996047a8fbd457e760c823d8c7464c5a3b526b567f86c6c5ee63a37f19c38f0deac9a526df87c890b71435677cfeb525ea96185ed4bb033f45747a0fbab996772818f3a3a960d0ded4315a6b481d555616a64c8a89c478dee5f2e272f96a101d8e79ed15ba67a6048d818a6d02e0ae3053d8a8a1bbf7fa69c596b3017111ee4c4e554ecd4ea87580c4ca3dc3e3ab6412a87eb3c2c349df1b1093d17814fba1d86dafada662048cfb5eddd3f82b209a476c5e775f22e10b8d58c048867d3fa144e99617d1da0667c992698f11dfec904d88283f7f62c6e494eed35da4ac80cb80f95f813c68e90cc40faeb190f3c5d1447968b88b8b2b1bd9740dd0b027acccd8bbc595cad5be8e4e435a1135c551ba8ddc19c2c715a70b0fe416cc974a40712f62c87fa6b43ea2c5bc391b82109d97c9438e1cff1decbd5a592ab1a4927f51c693affb78bd7d89a35dae6dfb64bf07d606c83d2a7cd1a85d4ea56773f06aa00522ee6e273adfd1ecb65700411fb63c081be934f4b930aea69d9366be899630f1ef4e38a41d9ffa29e7f824691d8941de4b4db498ccfdd62034d6dd2aa624a0e9f45cf8af164633b055a977c1fb7f975ccdbf7e32e5d3e6c8f8e09da8617d70b1c66d5d272e98c683e17aeddd84b5424478c1a8f80d68aa9d0af4f70b18679b7554e7532ecadd63f07a4e61a6d2673f3279d9f89eb9ad08e845f71e4d7b24ca1b16eeb5cb134b95b9a3027bbe0d616065688aa1ec2183c01737827559681c8265e7089fecb3fcc3a1124cd0aac49846823aa547ff142096e8f6fb538f976d5e3ada9878f2e6258ec83729c48154eb8515ba2b84b5bbdd3edca2ff5d558164ba465f11c92d4bf14230b799a49a87b56b49955de667c0f085c37829c77b5e2e470df46c12aba4e7f587bdf1a17db80cbfda05e89a6a9d9457bcf2f47721e90a9f31896880ec9305555bb32ca6d614a837aef0ff70ac534f0cf14645cdecf05bba313fcaf7eda5b76865d0a7fb2ff5eb77af83af42e64de0c27b8e514febc211f4b79aa9f9dc7454163a0c7b6f9fc207d90399dd60369c6b7a7742b9f9499afd3ba9698efdfdd6f0f2bac0708f4ed2c0c76565edff446c206ebcc0a6dedf5cf17d4b09de1388f8f56a27c029bae6ba8142c0e0815e326a7ac3f0d1da3c9870940283a8f8e4860cd09cc86b63c687edd6b7893d1f798f68d3ca224e7945e8e5b552ccb41b71c4b013c93a50fdb6c61ca3b246f46b13579d8fead279e68958e867b9d1396f4ebda9373ca8a27557ff39c45903bc59bbb1579da66b35453a157f0fea1abc26cfc101933277fbe0098366d896d9e7c684573f9dad651c039c25267515866d2626f2142b0bc20c72ffbf92c22a5632bd642a7f4f29e92f6d1a4df1983abdd407b59bf03ef6f84bd245eef1ed8050afd8b499d11f22c52a386812346bf5a9a2f9eac5775ed34afb7751097547d84893f4c70b980e11c4665fc976dfa15a9b174886ad7165e2a690344225a23f2cf64805abc1062dc9972d86a7d890ace537d9c015ef0884f0adcf1ce7efcc404f06b48d47c5e07291d6bc5a7348f4324e3901c81e948b9bd6c73413c98c2e9bd3d3a92ff0cd9f52d4c1f8619baf84eb6ec562f1764953c021bd0634ca779a5338ff1aa089c11eeaa42e120b9610dec330e1d11f1a0eb720c0ae47b21bf166b4e3b41a474f4ee9df0f81d88931aebc3aead9537fdad107c1ae02fe8dbfe9b1595b795353fb100917e62a90a8f37dbdab8359e0a860057a1018987ea0b9e99e564dec0c7610567ddbd83707725258761f1ba7be4a188a0d740cf3855e2feda98d9b0a98870a7d70e279166575df90a223546728d5303eb181b76540d42dd81b4b7bfe130b01f03a7ee3c5f153d08a3b329f9bb7a3f1e548c9104e5c4dc39d6db7f3bddc17efd66b14447f26969156ec3c87fc6d5f592f207ee2c40b373f323897372a4ff2cf9ca925c8d47517eb5752fe6be139413a559a042b95bc36ca17ee0c0188922e6cab514f85934c410e659e428109b603e164913fbe4604a7daa80d0162f7f5a194476d19719cab9dd5d88ee6da77103e4ac5220fc26d16bdda02cc0455161246fba5c83ee52ef937d382dccb2f8b93cbcc595213106bc40769646315b0e1b57cbf62b1eab935547e4d5d647e0bc315e1e6df1bc996a981b20af321f651fd93017b8716b861f1714f5682dccec7a4e16daee8fecbd1c143ec803d48533c75352d4b6eeaf0c693766bb8d5fa763cfd66d81e47b49a465e533b8247401ddfb8abac0a18597c87b1cfb69b35d1a5f8b233a0bd2325be5398136fb825177752ef94390b9aa1ab24fe7b3aba348fddf32e119e4b2aa6fe576d17728db55758d4eb5be2ddc4f41efd83b9b2fcfdf425bdf7a0a334b5c38751d92f8f97a711b529fbe2897f56e0637a4c1671a9b85d62240ff9f87ba7c44b5be4a55aee4b3f1efe1ccf3f180c806274e70afaa1519ea491d97bed2c238ca7c18f56481da326e53eb496d119b79905363e6bb3b61ac74a4ebf3596a0b1edc12c62e5c907eeb430dc52ebc423db0a6d1b25d705beae063f6fbceba492cc73464b141988f93f97c4c48f241b3a88f02c830a65c55fa43e7be2eabab2a3594286381762a3e50347358c820725ac18441c0adc0fc4f9b2a9c4037c46c39351217bd82be6a837bf1bf1913bdf299df1752fe01374a7f9ffbd1fa7dfc58dec80ad834712f89a9a0698c59797f4a883d1b7a6bbc0cced14a2b2b734cf72cadf2c8acfdd1491ee496a6dee862805f25e19fddeae52c6f1b006ff657a9243584da12f46cc8bfac2d7a6eae95f84b1bbe12f80b9c20893559da98932a995a53e0517b0a46ca5a744b60e125d98efdbeb5891c18036711202a2aa742cb8fea31775bb1301787c9e3595454607386c9fa9c0d57e3f7c1ec177067e5813c49aee46b34745e6c42bc1ffc23c28bf82b7d38e3c18f96cf66a9de5223240271cbb39ac11959737c53fc0879b6655f6e8705d44a4ac1b630f343682d3b06b63e2eb37dde51b10637a7acda5e41d9fa458cb3e1a778908338c2d1dfc9aaaf4ced28a147cf575659b2dc14e1b771e2accec61556d4cdbe75e3687b0e354a48e492fe926c074a9844e488c131ede18cf094e81cf3eef90a487abb60bcfc1666dc2d0f1f86f449945883cd44129dac6f721c23f90d43f256bc06f8e4f3c7d1f3fde8f2593af5c6beb50e08ef978a4e34e63dcde8ac95b5044be12891494c34404c7d862373fad565084a86dc5d94e3b8876df38bba0db27675ee29be691c33978fb70d6bfd9a28f4342865e805e250c6cc806a7b375dfde75c92e5b958f4b1804bd596b03a0109399767475f7ea01f187cc7793c044f385ec325d5291980fe1ed4b2256e47a45525703f3e8aac8ae59a2b5a6e2a24457aabd1beacbe8135d0aa48ca340c897d23cc858f9d85be78ac6d66840e8b43b88b88345df0e4fb0b42105d01bd5a4852e3abb9114e4000c2554f0a3e9932f8653622479fb6cf94cca35d99299fb89b82fab7d773a6bb48e98f318c32eaf6c36b38d702e50fe74e7096559caba6a0722c31774553106662c6cc56abac0f312ca455ec3c8fe372bad9bfa9fa18a422d8511d18e1bee33186af0b7638ce7afd4f181662f1189a47297df6fe9ad24fd19c8e474daad9f440c3275a8de0db684527df6ed249d51e885e91357896b386b917c5a561464fc4157a68f5616edadf16692ea8634da77b3f9073e106ec8b7922351ac519abbfeced970c2444a37adfc959bafb87b3fa002fa84794acd728e686428241f27d16232da592bc136274b6ec8dc62a5c9ac826754c7cef08c1abde514c0ce329f47aff0cead01fe6559725e7936ee4babd9ce2afa57e66f569d2dc8548cced82eedd0cdf8030cdfba15d54baa44a9b41198ce0202e0f9e08899ea85e7fca180152f46d627d92ea7726074996fcbe5ebd0931775bb70ef5a284d0e6fb7fa1616e715552d6660a91a4cf3d0a2ad252cd632cfa38c8e580603766351fff247656fe9b994891de4e6fffcb200f8d8b6ca9f1dca594be8279535332be50aaf78527fbd2ad0d5e855e159f47bfc8ee43dc7e15d98fd827db6f3a553da907b9f1565f91a4144cd629de8129049e9067b75f28de18f2a3c5f8bbe47504c77df48145eb62cda2cef9020486c93d6f95c84d40cee6bdb4ad99504f164be0836c2f7db120bce7bbd5f28e658f6d37685e16a7e8274037a00862c86450328811c04f9eefd69e21eafe90fe8662187dcc4939bfc4368f228fa1f4fefd6879b8a16e70a47d7bb0842fbff4727963a0db7126efc6fc993734f368a485bf45428de089f5f3f97836e5dd259b578f7f96f52cda6138fc560ec759e1a270b552d658c8b45ded6d0c4d57f0b92b44d950384675b0d4a9ee2a024b9909904a1172c2ce47a251538dc5b5f4673eb6f275e241a661a15e4a913a107dcdf5d63ef93a694023b80a3a483ee57a500900e0e5cd585fa9e64be56e846c24daf7cc0c674bcaffa5fea0473a51988307344d85e9a3f397f0e6fbb023beadf17cf58db212fab9199c0977a113fef2c717f6dd6601d29ac73e842ba8562be52f8044b8c3adf3bb8f9efcc22c2d126b1a703b7a88ef48718978fd629d33820181022da0648acb968f8f4545ab59d031f786d461b2e929cc65f4c81d999181f46f2812e8ab233cb4861c220b968dec36cd09837adcbdc2c273e7a0018a9a81b0db093635b0eeb48f167ef8b90e1631591f7be2dd2327c74cf0611c8ad9f1f4869840f7f252d7dd3916b234443e7986ed423dadb4462ec23d80a5fa54c20b439b3a962bbcdf7b813ec56b56c985765fa3d9faab659e0c899056242313e687a5a9e9c29925aa8e207e045d1c84af260a4b52c90e9c2942601adfbb5ec9f45a5e67a83490f68a63868d3e73ff005ed5a7e50343006d0a9e3caac3729a42577225a0483e861b33f4ff2adb8cb7e06a3cc69ba12edbda9f882e43ca69e645ae4d85548bbb1130f0c797fbac078258ef7445e0eaa2704d12acbe9c3639e0c831d7418e0828361cf6e4d05a0b1d07e72b7fa86e075cb89d91c0cc8d2b346965e71f615d01c2de41ade982e30aeb4bf75bb3c019594f5ed3c1d71b90c32c9e304e2f3583c8dd401cd78b4c80c60bba14ede6866b1c3e16e295cb9fec90c6275bfd8791a2742a3f01d6f6fd3ca696184b78febb00a2d78f6ee0c69c4f5c02a3e00b83ec0cb14eb7e0668d107e0ce9b0564791ab678b401484c97480a91aec62f3688630f2b59bddb570a3a7bfaaad4005b28310749dc3fa2cbc92871307137ce520c18364e466dd064cb8103663aa80c0ea9f9c372f0273a2ad09a96393e2a52c9c87d8f1d787b54de8881cdddca695b0df7a1d151dd9f49e23508250edff4736e2abd7a54407f850c10fc920a19281a14921091dd7385f67d0e47e1db5b469367f01ec534e29f7254ed1000914dd440eecee8200519f3bac350671321da7c0cb15d202748dd5a129b09034541787c4fd5eaa6306ff04535cf7125e8de44d8912de19c5003d25aa429f54aa632f7dc908f42beeaefed9400dfabcfff77c59d5b69bd520668c20dc1e80cf556fadfef8bf1b5dbceb8a716552857f16e54d41598c2eed429b7a7c1e3df2253e60acc4176c4842452323b8e7daa6d53b2f7908f1b9a23c9ba5372379a4732235e9e0b38d898361866e8587a17e2d70f858c9804314d2df24f2299f62cf3e6a9c3419fc904b10d5af3b1efaee0e82057f153f8cc7985530767b884628a2cd347bf1bbda71c948ac5b41692b0dcabd66b44823c48ce878f414ef6f05f7235ea79b4a2dcd897dde5a2f6f172354cf68f335417da425245836a1866455f6097afba911a5eb13265c5b87489d36ef8578b99701a42ab74e998875c09121d5ad848e23c48011a2dd55de074ae6a35aea90c6303db158cb27f7433262fbdf34898a01bfab1ea2d1c8a55b5f4c3e39ca54736b070f1559f385e75a1c20eba284813646aade5e943c9b2f6cf807595a7095e4b70e857c2dfb82f2526dfa973bca90d281259b938e5379ee9c9509fccf806bf90cd49cfd1a41ea448250bf4861850a5d336b5684422db49cf9d59258cd12bfd1326200a69180c9b53135bd96bcbba3a3772f7b6b449104901f5bb21e1301456e418a81713c65252d98f66bce83478b9ee8ee4895c9e83337fa9f0b5179d5b2a5df11a44762a03e7c5fa86ebb88bc5c1ced53a87f7d23470c0501bac1d34b1dbf791fa84ffbe21375d88fe94588a820abdf0a793042ad999230aa243ce03df087a05f07ecd4a28d2c42e27fe4cde95ebd5a720f92c190aa3e50ab6341340a38fdd1429999e20f91976a5b5d8491ff5a034727cc77183729e4174875464f6415bec77efd85c7c6a235ddcad5ad3df97de21914badc3bfcad11e5b34fecd86e473b23860a5a7b5497328e0289c1e95f5b5e215e896ef13318ff7d1645058761971cc422af854b12a8ed351ec954f4a83f5275b18e24f80ab9f5147779168730828d58672ea98c16dd4017506f2bcf724d72a844bb7018b9babff623b29f8ef5e48413f7f7986def36b2518077c69d3ef2063c029d153459c89588d0c3988a0fb58ef3b03f17a8874a0a458db9400349b618f40240402a9a7f25895250a361c3cf568deb5f1801a9105daf964b90a956848bed9b26c1fab5403dc1f2cc887c3e18155f7a4107605939e9eb7db94c24bff0038961a12934f0a96c5a36727420333aac9cf78a99634c8d02a5f69ea9476400a88845fb44819ca25b09ec097db34ef5e048c82148d8d995d8e453ed5bff9d4b7bf8be178a6497cd9b967974ed08d84bdf34422677e82fdec425d2ad1699e7fcd114f897f9a1eae7f980737bc24eff35e10077ab6d2071d184f7454ffc424102dcd86401efb83fc82a7c1d0747c1e91408a4242e898d0d4eb0c4f4cbf492025e2e532199b425f3b3cb541208129d0b0830817f01182cf5da24fe7493886834cbcef73d5659d9b732881b43a0caa3e4116b642c728d6e249388d71e875f11f5c84fabdadf70deb0c4d9e84692f4c962da813d735fd722eb0e9b4a8899be6204e31eccf48afc9fd71369f1489f5b4df62ff90737abfb49a6d2283195424c3e8bfe8e34bd74fdb78255bbd1a5e32af52e4e563d3e3f7fa18ae9777719afcc103fbd649f5b52ce3e59e08ad3b48e2b4ff4cd4b15c2325e2b0734a66c12bf8cae5ddba289e93099d9a47dc36818e9d6061eb8655e95005bb86dc289e47bad400171fb74d4fca10b46febbfa823eafd3ef9013b87a3bf2f1877e00528e4f04257ccda961d931b59534933c2afd5f39a07d886c8cfc07eb84e95c670c76d7b2a4f6270ab4959d2a2a67a952375a9871084bc212e609e4080794bbbd9b8296a8ce4d1234e4058f90ef538615cd9275e7252b727a45313dc50d17258195ff38cebaa514e9eda1d0296e252605b59c800fdb85820eb00c949f7b4a084ea4866df6997e94b1cbd1587ce1680cc6a0228ca66c31300746260257187d1a6587098a58bc8f8388ad655595fd68dd03b22fdb20696b138dd5a6fcc8aa728cc598cd2bcca1e05d3a6cf655eae7c8cf5ba0c6ff3d65869af8753080f0a2ed9676c7a7cf385375dc47920a82ab039b2a3824496d66a4b795c7bf15e86a5385da53841ee99dfedb43e8fdf1d66887d1c2d572a5607c20c0d1e0909d6347ce87146010cb2c88287bd75d1261c54dcbaec1c03e92dd96d01a0bfb1a7217b093ea2bc9a08a2480332a5622ac39d7a7b28475aeffc1f904632204830eb3468c12e696956be0a90559ee77d363aefae4fa2ccad4dd124cf42eaa449a9e2d261556f327bb578446539998f997d3e9bb41621bd694a3c13df28536977cc54996fe004698cfec9f491847d3605abe07c6403728d28643485d747adbe6549e929c701227501a4898da634bb40a102cf8da3ed36516d2ce98db8e4fc5267930cf1db13311b10a4355d08e2406e8a055f19748321aa3068cf9522c2da7fa7773bc5049adfbaac734c00ea617bec2d543a8c137b816aa1d5de8a8068eb25b4b64d65474425356af81fe16fc6d7ecafc135782e4e78a93a75cb86608611f06491bff59463d2821e496cf3d4693ad4a8db9778aee280222e1f1eddeeb9b59c5079a5d74949e1256eb2bb46af7624075e8a01f76b22216da63ab7631d56d22387cb8ea0c28fecda2eb176120066a9d23c8f7f8f7e437616c98aeb56ec11267b72b5b7f497332dcf4ef9a6ac20f01a61fc42c51e3d5067a0f2420b844f754edac33756c3a94e9cccdf4ca8121b29eb86a64957cf5ce60cf016444bc0d0f76454ef6aadc946e4d09ff2a17964c192e9cb62c3cdbd6327b13524093c0166ff54d0b9eb7bd09f2dfc9e602c83575f6a60f6ebc7a66b19ed8fa583b3d209e1e18e4d36edd0b3401cfb6db73c1858fd0ec9c6e537150bddb31fd33e13d9f473a65b325eb440a1ce6a2550e39c73f85824b04b2240695c33ca1a49de7fed807b940680d84d13f77da34be214cae163d34c7504c125526d8cf0c428ef2b33f9dac08de70efc8452733ad133187a0c6cf9ac694c20a47cf7ae9b16bc0324258c364dbe0152678c8da20ca89286d63fdd3a89ba5d55db3979937154538a88ea7534b466a461b6c05393a3d60ff849b2174c304ab0a3a8678bd04fbfc6b6b66585c59192cc6fcc14c371241a48b5d3d211f9eab771bde72dcf6e5ccc7c38134d0adb9cdc18b41e878fcd63cd9d66c3f3518393570d66a92652a6b7ee16f044162f13f86b3f73c3539396b79f6dbe713c3825ed2fde153eab23e6f83260458cc7753014296fb95018a7d8a858392f3acc0f20e7d1572a3bf4693a4a2d1b81a01fec7c7c40352e5e5e8c8f1d18b77927f1063f00eb515d431008ed5e35685cbd317df3ea56c34cd15c2bc19017dfcb0190204ea02923e6eb54751127d6049e7c2ed391eb23f6d3937a0988313ef3263aef00ef31c4693e80123c1b348512feafea8eae8d89b775e42c0aef752b938a1f19b525d745df331461ce558b3384dbfe09f1aa622f2de5699fb990ee5213f974864d5fa118f9aa99d5fd8997c65f7b89e96b077ce3296019ac0f7602c3ea6a43835e6e43651f2f7ec0162dc3871a7e692683c54c55368474731a2fa1b5f0f08f7cabe20da65989acc9bda5d2f17934ccdbcf2cd5d2f5958e1360ab3e93d8feef2383c6f404792c9ba168f7b78a16b1c0f253e5bae7038a990f5c194c0477d5e0a87f13750575ca68a80b948f14025ba2a79a076320ed1b914ef44b32cc0db6515a37bf4ced756e28e75f19ce5a0af63a59017df7ac21566deccaac2e509d64400f3ba008d34e242e43e6dc922dfd0e1dedcf276f14aee6c89b3d19c9d9c8e47253468b7112e24e6faf6273cc3b9103f881c2ff390f4917c805c45012ad09f182d3b8129352605bf372be3fa35a937f7e906069f0c9d83ae1cd3de61451702430702518ffa1093f04c99241ac78b8f0e7e42e34f6474d46173abbd340de894245ba7869ebbcf6f91dcd09f4c6089475bf25125e769a6e9cece91512ee552f66c521bb36722577ce82eb5f8e41af4a84f3fa1ee00c915c2e38c0edf09c33f63d2311a3126f90cb5408b7264e4c65650e22f369cfaddd040d1168047f15e39eff9dcc9812ecf457aac66ed75051adcbae9218b59e2f3c23c92dbd963d97daefcefa5eb47737a9b0217da0999c1bf75f26b8957c5a2a140c828d553d9f761ddfad697daafdc4cf3b18fa2f4d8f760f9ce705562e4ae6c94c0d4c8043191367137a6901673bccb4f6fb7ea9c859b0c8edf3846c69d379e4cb15a18577aad26059aee1d278b32337cd0e1e6610bea7312c07142e5ccf09796bacc74f7f7752d47219834cefe0b7b7a9b11c4becf2d5bd48354848d6301a4e561f3b7f27e92bffbe1f0a76cb6f215f1f63592da27b23ac1604d4b8bdab1105084b3949187b5303b2a1cddab255fb9004cc19aeb20ab5bb734c8d872dc356b0a4bc0249a317ef94389fda4919d9218caf1804e68b96c1752e3c7419d77fa64e6b4b673e72e7e2565fbeb7051a70a0eaf358660d2be228ccc12ca325533f6890fe691561e725e52743fd7b4fd8e772fa8d4aa3ff7e397f877feb94fc582013187594317c190e7ac9591f369330f964db0dca1ff82f2f01984eb97caa3a35d2b13c431b035484a8c89c8c225a4c36870ea21fa3c3a0755b49904fb6fc0988d76ceaf4133a6d1ff3b2a83fbdbb7aed820cadf5714501c98d4db079a37bee9e502a81ca233b3e6ffc4aeb4f34226fa8321aa85885c5b21b45cb9ab43171d2f19dcedd3cbd4b85d39ca8e9ea279c91ab63c1174ccc645f7b5037b2b058d5fb053a0e76631f27595a028bf0a65c4e0a04be8db54192dc1533cebb0871b4d2773136873fb0c1ac1a82dbc8ebe844bb3fac653ffc1c119bfbd7d3aa00876aa00eb1a5ebc91f961f84d477ea2611defd88ab1ce1f062de12fd943e5957807189b9d6c2b5ec95fc933d1cab228ef1af6d7378dc2fbc3af2e41a524649a266d83b1889b02da2c1114edb3dcb245b0ad1f1b20066d30fd2e69fa100220d6ee5992fb377530e9b4080d59bf4b6395fdc406ec28720feac34bb1b0821f76c0fd7e657395d87b4241ebb38c1f8b2b777a5d4d62ad85ab86c017114260b499b0d6fa926672844e2965b7f0d74503a7b8b48733c766ce6ff4eb46c73d32269cdd68a1865963894c4c7eb31d6ed676828836cc0d94aae53ee8283a72c28d7c941c28610893c66b75e1558c0328d583b6f4296bb0e716fe396ae07b73d645800b0bf13d7fdc27b0c3be529d9211e79d974b9cd649398fe992d749c519c31e5976cda68b195e6b039314ddf092b6d0e021ec679989855999346447c749c90da56fd3bea1c3ef3a01d379f27f43bb54dcb6fe048770573d7c08946fe4d2dac52038c1ac7f363db02cc1ccf8765c2d7af230cee546a69ce684184e5356c541c51276a5d55a96c8ac7a2bf8a2b8ddc75655044820a5b9663d9c0996d34eef6bba52fe559dcb7bfb073f2b8595fb2d5a60b317730d5d30a21b43832bf3d7690aa0f3b22169f7e15ec734687901482e79449ea7afce0a241cb31ca92e9f715950e7f48773577f4c20bf7564775bfbdc41d3a7a09f768ebb49483346a8e597e7ec527a583748ce7ef4c1cad93674f2a316bc04eb57de80965eb9151f86f6afdf23c0c16efc77f9b0c730c080a956da19344bd757ba1c5f116d23849096d7096ed52da54ee6dab743ab13c5925cf8d5161550a1f05c932d208e03b2f84b7019f0d9d9e135b9c4b45057f22cd2fb29c0fffb2f2aeac659cde1e423b1ecb1a67ce79e36a27d0435e52c12b64b5f02b5b026fe8d771cf12d815fb5d5dcf7e63f27168186a57a00dad3e048195b28b06ffd6df01dd05d83d187dc619e64c72607b0f8ee1bacc4b3efbd70848999277e55491d41465b6a82f967ea16d15833e46c63df3739c7e54db5cf71a882e37963d08b6814e33727fd31c580a7a366c50d7360c6c9ca2b1f117c080081aaad45301aecc129e9629e007db9129e9ea357c09684688be3923a20ae96c9366da557374eef6075d9a93703a04c255524765ecddab768f07bf9741f7e92584add1ff846a6c33afdd249995d85fb719256915d951ee412882ea95fcbcab4c2fd6de7ed9f5c98b5afecdf7ce5760ed135d1e9525dafdcad7928a7cb260add05ccc65cfee7249cf7f980dcf052369f004e9b858b4be39fb03841b629377d54d2c885d8bfce0e7cad1068c51482f4b94c4e9f8628d14a49665aafe0536ccc1defe274bd4aa2cdf5751d0b79a9639ae0c68f4e882ac0bdef2007b971a48138bf133890f99ec260b2bf9677daf6688a348c9b3068d890af974f438c2ba7efd97ef7bc9cbc40a3e681044c1c83cbce12767e4e69dbe8da16eeb6ea51a23c5c06bf7023a94ac95236da6b116a1ef4172ff15d2100c58cb75e54dea547c520ee1a4cc8693f9a4d8db1d02b54364d3b8ab024195d79294ae9aaf3de353a2e268a6ac7e9d1c8fedbf6595e2ecb142b71c0dbf65a28248ddef29abd461d044b0628974c78acd4edd7a315270cca742b6af1a06062744a097bbca649e5004108bd396a43d6c0ec7a6b04334cb1b3538e418aff70764758f8effadb3c93e755513957f4876715af6045f2168bcb83460fe1eb57cac27a4ddd55084e48cfcf88442bd9f2010067aa9af4b1c16b2a3abe0276588c25e790afc238bf6522c8be4d1cf87e97cfa35b59443d26dd85cefcbe38a8038a1b080b5c24782b566aef73ac27ad461d226c0d53764fe7e6e2f58f3f09ea4c1f260c944aa60f5362826423197bc67d9c7a0f8770cad215ade3ffcf5ff290f07566749b82347182c58ed35118928de6f77829a95c41dacacf964d2b4472eb6d0c6e72ad6dfcbb866d4ac89494a471e4f18833c1957a8f9234d95201802d2f2c8b55bb36cc5241454087134787d966811ef1cf742735dfacb4de4d2eaa69c3b7ece43710e00cbaf5a4df52f234726765d8e540dda9b82995869ef3f45eb6eb7fb650b1d7c0fa3713765ad8643c7e18833c4681b7012f1ae02f07b989827e29c156f4ca6c9dac7f509cc94d6406a42d214a291b7f3e44a004061a03a098fdd5fde1d379f6274721bd08489af9d66a24ffc98c85600fba6b24bf841876f560b6bc54b5011b1d9b1989c7d97ed13cc79010e026a404fcda7b708f78b685505343a32b5652ce023caefd47ce04cdd4dc4c2c34e3dd1039a1de06ed64ed1b942836622ea5f17e0f70452832f0a4310490f14a4cd41c877fa88289590e329f3e876938bc1a0ee9c5ca271c5ecd46eb785f4425d10f81c77d4758114427dde482bd8d9c4feb42fc1830d3cae58ee991dfa382188f46fc96db67f76db453ddac97f03b39a48cd1772f0ca89c922ee06ac4abf155195b65bb0d9792ba4c99762c99bfd9e26eabc62dd7235b3e07e04fa8334cd6667f13bca87974ef45937b955aefce81418c2577511bb9e4c36027cdf3cb5e587cf5836da6266eecc9ee94ebee55de77a6951d69c32d006d6e26b6e620773692814aef3a6c32e7af20107674993c8d5c0e1203779afc07537a0cb2ca2eaac3803b06a8b805efb8a6f9b6a7b89d6ce4338f560bdc42547cd4e27213d678d13369d9426a69985c500b1e925073f7e9c243051bc13bcc4f6ea49684053becbb275d1325d9e7f68ef736252fed9a3968c81af794a82734c64bc886b75592858b67074df55d5264205cef0ba7c9689988196e6d28f0c4d1ce9df6dcc34d4bb341f1123240b1c5d7c28bc26943e0f096495175b64dfd4defab6ba1d5e6a6a06af4dd775ed477061eeb5f8598273ae7a90a7b867703d438b63ddf8d22a747ab8f9f6bbe10bf76f0b0a7ad9c7ebb79544f11cfbc72dde0c73c17edc70327634a7bb1fea411b8cd416e59a383069af173eeefe272dc6696180ada53d294ba50ae8b463401a8fafb761f5ac9b965ce5087c5d9fd3c267deb3c98f9ee4652eeaad66c7c22a20d366be8cdc5c6f15c985501cdfa2d3f95ebf3b9a5023af9efe99eb73ac6b43177728fe3f2684697edf64f3811ee0936bce42d38f3d8ec8bcf82715fc839bd803899b4b769218bb6c04d623c44181c0b7e3e3e8cb0a7df97ea46522ba78fbcde84b10fc0cb1639cfbe03bc9fd2a55bd2f7f353d61b36b7f64c80465e47c1a94edfc1bbff853223e2e7a5babb6628ec84d7abb65e4f8070f2e3eba9c1f68d7447357524e0b75bccb784043306405d959bfcb79e3cdfb1cad99e5fc71cea1e52f7755dd49014254928ddc177031ae106b7ecf43475577fe1f0eeba28e0fc53294ce9db80f353e2e010b606293204db75f377f685ec354bb5d9473c09d0bd0db83a01cefebe455efc3f9e7b0736db3c2206619d0024421073f3230f8bfd7a0ef771fb877c248f43cdaba5551a68865f1947cbc8474affda16380ec9661dcb48fa771476e8062f547c45e4013a60561761d7e2d94fb2ff163f875d617f2eda3e8e3d0a4511034a4f777507f7d1db42d6624a7e77a8f6d853644dc623db734c4cdbe215bd6d491988c9bff5b60c8d6194dd81e40b9b1e8953549f5f432c5677d069eb19e8ef56d7e530817b65d55860afe7f2721464a778a088abfad1a2df1edbcd73a40efeff060da61c0018019ff15d9749d1c094be0f963e3773fad82c477454a47192ea53c161d307feaa2f835ed32bb717c3a438c81c22ac5ce1ae4ca9b8fce0b8b1ef07774a7ea275b8f8066507b6d371982ca550ca53b52d193954d0b265a2a1397e9418b55694426d47e3cf495213a9f85b943658a0eaefde98dedf7241972c458045bfa0d5e891addf22bba6256ab9ec1c69ead06eb7eb6b6e95d36940353386178eaf1c49d4b1ca85e3cf1b844320a1705cb673f71c053225de4f7c52a43bdd72986a8c0c1d0378f5c2ce63547afef07bf74c2510b67ea441a52ee12f2d2744dcb6ccd278928585a902c5df727c39caa55f0e28c95f1274541efaae5fb769b324a438fd6d2d931cb8e6fade68ef1c8ce354d7c8ac777b42ee064cf711f9f2d83eadda97408289674346429eea6eab84f3dbc8792fc7cef864d91381093c8966e69f33376108092b06616bb43a8a699d63fd642479ac53ae9b9151a9b588eb4e9891f324f6fcd3d0f5eaaefbed5eceb3bdacb73edb781332271909b5a24088bd400376fa8b3add334658af3177b71f0b107e3ef381d428fbcb53aa0c32c3ea64de3ee90836b73e74befd3be893ff6919926ecc61feed44398ee6fec2cec826abcbe8c16d6186b4cb0943b4be07fe6e7f054013f4d6e60887c7a5efa9ad2119aa8a2ceb2f139a33ffcf1fdecd92be7992fa18945b21c83d949247ec0e87031c11fbfa610cc23adb41dd193d3f7a08510bcb41a2ef57d745b1c94f2ea3cfffd9f5d02025590a76ca856a6e8e13086ce892be042b4204208154ffd9ad1497a11b7fe559c964ae792c7bd798105a45bd6920c721825952f16fb38b3ea8cecdcc2e05718e4dafa49b104eefe944608306f535a87e3fa0c310fe163d251cedb234fbef755499e184048c97bb0811d6d5aae3940da811e7bfd843df5c0b1f77098ecfd41303f9205b63ffbaa8a186c62b24e70aac83183049bab34c6e005129b252ff6f8dd6b7a3e2340e1b47b45dc11c424955aca7acd08940fe92cb43034d330b53701133614f194cdeb92db5f90d740576d2b6cf768bdc76d62f92efc4029e54fa6108045c66cc227558cd54712194be561c166e4dd89d3d2c2cd77edf92ba248f7f1db7ee5b696518dc2e3a17237ff2e03b899a9ea679a9370516801abde965f10b34021f2169c1e731f0210b4c7b4bd3dea5bba4383fa9e092e5dc754213af1d66794df142add02b844f740423e1e251a8e3feb2846346e8cbee7db99fed535f0411f030fb570722a9f76425caabff3d1f0c922afb62b36358bc1afd713b2c1ccc3ea0b798d372daddad590ff2f919e3566f3b91d384418df84d85741eeaf3045e904a6bd29702396404d310d64ee4317d5700dda957e8f3c12c31bed5c1aecaa1b653f0d1db20b1588b50c417d4c7b34359420878e603ef23fc32ae831396f517cd6d4cb7bf764f0507a25742f42a651cba20c47f58ddb5d7be4b1f354956c677edd495c94c0c0915a8a449659eec252af246973d31e36fca2d66f04f3ea2f62a21107e792270452c2b856cdf25fa1e80afbbe5942488fd33eaa9202ce0498fa84353935ec5af96c12bfbb4a531170f9ca6a0ccd1a6a4412c0e1f0b84f57bbf0346f92eeac69ae66ea54dfb142a1a1287df3469a4ea607cd1ca28a69be0b057aca5218adb172375d2f7bdb927dfd5c06a0715d2686185d5a70eab346cf5861f8f40ce581a8d35b99571d97b52a5c32a64239db5b430d899f0a175e0ca3128d3d204ea0af1e045b7ddb25d839d0ac903050c4a2b23b5c7d0e8e6c1be76c755053708971527a6e8270527913ef7598c4249e0cf1655c95c122fa5bbc87be18ba209ff60ff8f420499cf1a8b42f3922ece1f98a03e62a28dcd97de6cd6942ba1b265ae29c164753a445952d060d2b54c4e79e940320e59d168f1814b307a87f64bbe983d4ea5b49749daaf93885fcabeb153a42f54c87340ded13ad196f5db855da6cd17a520b9a0259478cf0866fa4c421f8cb79860fd2c97a9581fdb8a1a7cd97098a85db945694286c0f76cd3ece2079c958be85781d5297f19a2180d9a4a576864833e1b3a311ded3f54d2b8892e9f4c5a5ae03eea51b4cdbf4d74e3b4ada9c846bd53a7a3cc595335168b18faaa807802ab87599fae9b9870532816a07f5fab1df178b08d027e562801368155728f1912116a57b0e137742765d19ff8c70e8fa4104177c6431f59c5fc74d5a7d9e18bd4688c960d1ff6ef791421dad7adaca367da3c8ec4d4a02f564e947f5c6de436cf04ddd0c88a7b8b6ce0cf6961b7e27d048bfcf1e0fa6e2c7a6479e825dbd266007aed72639f14f92083c591af94277697700fbb8e692b6c536bb947bf79238d353b2ddf84c2207f8e3582ea6bbfe953e9bd527dddb8b955ad128f625d2ef2cff40dcb09dd24bbeff4d321fdd393ddcc0935e68592d3bac83d8f0e2832a034ad575712da5647f50948ac1e325c92b96232c135003a0e4668b5a22c1e52212d6cbd32691328478900023c50c210e0b9933f413eadcdde388b50e488bdcf2b801e9741c0d80458fda422b3468cc8695bf3a6470983bfa407aff155cb76c4eff4bbc1802a11fa00a6752675ebe58a15f4ea6c7e8e78af25c5c4235c74ca61486582bcbdbd952657b345bd818c00b6f83ecb772421be2fc5b4f0241472f1c1f916dadce187f4b9115ed57418d051b05b58eeb64b6d04abba82a3f36fa5302cf69eacdaebb513cfd66c7cc24150fe793d98f323b8692b59944bdaa86b155958de68858f74ed00ba4c52234b6441decaf4e513a586036c8d2afcfc954da6cb22f162bfcb3d810079b5fee61c6ef92de992f3e313e57e27c4899e5906120a4e846cadb6008ed8867cdaa54faf3b1007ae0d488a91810620256e51120bc47303c855e9d0920c702f8e991e6f8f19bc8bd6f4c4a1efdbecd19d1304b0cd75ef246bd1fafe45e99797d4f87d52194c595620e2c243b7c63ba765c7c5c9d30af65928e20eabdbd5d1c4447e891f5dcaf3d334f8e54dce8f5dd8ade2f95ca953f854080860107a2f0db85f17985a075dd7d9ada7256653bc2ba7c1eea2ed2459c6847d3d54635931098d980047007e303c2994e9bd8adc0a2e44e24df88928832b12428a3d4fb3119035505976007a9a0e00ce787ca8443898cfa1ade491594c1efcd68fefa61619aaab6b19c6b9bb170aa10e6fb580e97f68dd3f0fb4afd6011440110586f781ae7541b0ccd9e31f5e47ec56cd9fc5800a8c5c553e56b21ffaba42658da3d21ebdfa39785b7a1a35dbf3ed7b546a222fdd0d027b8dbff4f617e9a0ac0d2ef9e9fcfe69c82d0910e6c09fd9f1fb107f3b12406d70c136d591dcef5e09a10a1bcde0043a278dc0b3226ceaeb991b8de872f2d8c44b4758010fdbb9bc416bab27291821c526d415219744ea45c6703595f38a40eb4c10ca48711cdd2b78dfba3048f54c4c827c7c063cb59f955eda4e82c82394cd2ac891ea50ddf17823ff5efb2a194ed42f94418968a94be877d079fb2e8f725ddbd92667210dbbb9d16d4b6d0c5db24bae3d8c79b4290e8a69fbe563243e28cb8c174b227775342cd91feec7c08bfbb687cda709770cbfc789b8f469a711c76cc64b7996150c0f30f09ab226d1972f35aaedfd2c0ec5954cdc45b2e81c5397162bbcf1fda480a536efd750510348b0369cdc34888797ca20a127f59feddd70d79041343e436104caaee714168b9ea3e60202daf1499fcfde9d8e3b2fb0da96c62bebfaedb8839d6c03c7149f7e3a930be151b316f24512202fb0b22c7b28d99830607da648f876502d2dcb6a37bb01fa09dabbfb43900d481da99b1d24de3d068dcf13f6032693931a0abd307047da72b8c688d2abd6103e3e4d60edf6242f06b60d08ff4bbdc4fcb43b9205013c3785da12d56dc78cf55f35f7008b7b431702627bcc6a4a19777557f9f60aaeb746419aff73e8cf56d4cb2951e4ec4e120b41339806666d52e0e2ae461b1fb54aa052e2478fcae1d1199f798574e2ad8f589afc277b402900255b557a1cbdff10f927a303553c32343eb3e62450f07b25dda85f24e9c0132e79b5904bc078ec4be1f4910789cf50aaec0958f440adedd977ce1b52e8015eb061c42876bfa0c6aeadb96dd9f56564c2fdb13debffcc62777128fca2e92b80cf24c1f9939dd2e6a2392bda77119e39a5d7ae48a25ff9927b5c87bdc710a1766214b3eb84d1dca7a67959be3ecf4f285f97e37efef6b89a818d11718c3ddffb03554b77d0bbffbaae02589f3160d13e0a11bdd8691de02b0e194bcc236403c260afb0855471f898a78e64868ee2d8d04b062070a44468277cade3f48fb5e7cc6cf1fc8f1cc308b9193f9cc471fca2a362852dce3ba409092dd04898c50f07b4d9d1e0813ed020eed32e612d99d543c4f4eb86da2f89daf94de26bd0cbd13ed071069fbb51e73cc0681faf74ef80fc18e4f42d347c510f209cbfa5d8889c3a441fd922d335ce37150b263e011698b9201253dfc675d10c85ae479ca8c7979c25b866bdd7f2dd3e1eedf3b236fcf34abd1e17cd92755dd24ecef82158dafa75e1764d6bdb6579697018304bb69116c4e870bc499c8f61385dc4a18dd68878485cf8ccf029688fa1c1d222a90944240b94959e3b51e0aa5ddffe5e6cbf4845cc354f91f7c4bdb865849f8ecbac2ac4e176bce4ce385e41deda2e30a5d91522340cbad15f667b5b097ff843a6f65a79a215d5dd4b50a3609c12038b39a143600140622b1e5ea85e457a3ad3405e761a6d9e923e60b938f4f4c19e25f0b65cdf0a8463d1b5e92b71dce7c7c0174d177cdd48b80f899c92a9808d81bd02722cba41dca45b2836d32ca18a7cbc5352c5ed7be38c5feae02c8357adf69ddb4e509b7e4893e015222f295c430d2c6c1732a4928974b0d67f8628d555bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-系统C函数的hook</title>
    <link href="/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/"/>
    <url>/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/</url>
    
    <content type="html"><![CDATA[<h3 id="fishhook方案"><a href="#fishhook方案" class="headerlink" title="fishhook方案"></a>fishhook方案</h3><p>通过解析<code>bind</code>、<code>lazy_bind</code>、<code>weak_bind</code>可以获取到元组列表，每个元组会告诉我们符号和指针信息，指针信息包括指针位于哪个段以及在段的偏移</p><p>在iOS中，我们使用用变量或类似<code>NSLog()</code>等外部函数并不是直接调用地址，而是在经过bind 或 lazy_bind后才能得到真正的地址。bind或lazy_bind后真正的函数地址记录在 <code>nl_symbol_ptr</code> 或 <code>la_symbol_ptr</code>中，通过符号表可以找到每个函数对应在<code>nl_symbol_ptr</code>或<code>la_symbol_ptr</code>中的地址。fishhook 就是通过查找符号表，找到记录函数指针的地址修改函数指针从而实现C函数的hook。</p><p>bind是在加载镜像的时候就就已经绑定，而lazy_bind是在首次使用时才触发绑定。</p><blockquote><p> lazy_bind是如何实现在首次调用函数时进行bind的呢？</p></blockquote><p>假设张三和李四是同学，老师手里有个名单，这个名单上记录着要参加值日的同学。本来今天应该是李四值日，但是由于打印名单时教务处老师不知道李四的名字，因此打印了班长张三的名字。老师只认名单，因此老师找来张三打扫卫生。但是张三只做了一件事情，就是把名单上的名字改成了李四，并且叫李四来打扫卫生。这样老师以后如果再吩咐打扫卫生的事情时就直接找到了李四。这就是lazy_bind。故事中老师就是我们写的代码，代码只认地址。名单就是<code>la_symbol_ptr</code>，上面记录了值日同学名。张三就是stub机制，它只是起到了辅助作用。而李四则是真正的外部函数，需要真正执行的函数。</p><h3 id="动态库C函数hook"><a href="#动态库C函数hook" class="headerlink" title="动态库C函数hook"></a>动态库C函数hook</h3><p>除了<code>fishhook</code>外，笔者也有一种C函数的静态hook方式，相比于<code>fishhook</code>，此方案不存在耗时的查找比对操作。下面我将介绍这种比较特殊的方案：基于动态库的C函数hook </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dv8sqwtvj20xc0fjmyr.jpg"></p><p><strong>Step1</strong>: 首先在主工程中定义一个同名同参同返回的函数，这样在<code>ld64</code>链接时会认为<code>func1</code>和<code>func2</code> 中用到的<code>NSLog</code>是我们自定义的函数，这样就不会跟系统库的函数进行匹配，<code>NSLog</code>也就不会被标记为需要<code>bind</code>的函数。</p><p><strong>Step2</strong>: 在我们自定义的<code>NSLog</code>内部，我们调用自定义动态库的中间函数<code>MyNSLog</code>，这一步是为了能够调用到真正的<code>NSLog</code></p><p><strong>Step3</strong>: 由于动态库中我们没有自定义<code>NSLog</code>去“欺骗”ld64，因此动态中的<code>NSLog</code>会去调用真正的系统函数。</p><p>到这里可能有同学会问，“难道动态库的<code>NSLog</code>不存在重新调用到主程序的<code>NSLog</code>函数的风险吗？那样岂不是会死循环？”</p><p>不会的。因为动态库是具备编译和链接过程的产物。经过链接时，在二进制文件中就已经写定了<code>NSLog</code>  <code>bind</code>到系统库中的<code>NSLog</code>了，因此在启动阶段<code>dyld</code>不会“违抗”二进制的命令执行到主程序的<code>NSLog</code>。</p><p>但是由于侵入性较强，仅对部分需要<strong>同步启动</strong>用到的函数使用。<code>fishhook</code> 还是项目中最主要的使用方式。</p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</title>
    <link href="/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <url>/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化"><a href="#dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化" class="headerlink" title="dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化"></a>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</h3><p>dyld 是动态加载器，它主要用于动态库的链接和程序启动加载工作，它目前有两个主要版本：dyld 2 和 dyld 3。</p><p><strong>dyld 2</strong></p><p><a href="https://github.com/opensource-apple/dyld/tree/master/src" title="dyld开源地址">dyld2</a> 从 iOS 3.1 开始引入，一直到 iOS 12 被 dyld 3 全面代替。它经过了很多次版本迭代，我们现在常见的特性比如 ASLR，Code Sign，Shared Cache 等技术，都是在 dyld 2 中引入的。dyld 2 的执行流程是这样的：</p><p><img src="http://cdn.zhangferry.com/Images/20220104235847.png"></p><ul><li>解析 <code>mach-o</code> 头文件，找到依赖库，依赖库又可能有别的依赖，这里会进行递归分析，直到获得所有 dylib 的完整图。这里数据庞大，需要进行大量的处理；</li><li>映射所有 <code>mach-o</code> 文件，将它们放入地址空间；</li><li>执行符号查找，若你的程序使用 <code>printf</code> 函数，将会查找 <code>printf</code> 是否在库系统中，然后我们找到它的地址，将它复制到你的程序中的函数指针上；</li><li>进行 bind 和 rebase，修复内部和外部指针；</li><li>运行一些初始化任务，像是加载 category、load 方法等；</li><li>执行 main；</li></ul><p><strong>dyld 3</strong></p><p>dyld 3 在 2017 年就被引入至 iOS 11，当时主要用来优化系统库。现在，在 iOS 13 中它也将用于启动第三方 APP，完全替代 dyld 2。</p><p>dyld 3 最大的特点就是引入了启动闭包，闭包里包含了启动所需要的缓存信息，而且这个闭包在进程外就完成了。在打开 APP 时，实际上已经有不少工作都完成了，这会使 dyld 的执行更快。</p><p>最重要的特性就是启动闭包，闭包里包含了启动所需要的缓存信息，从而提高启动速度。下图是 dyld 2 和 dyld 3 的执行步骤对比：</p><p><img src="http://cdn.zhangferry.com/Images/20220105001119.png"></p><p>dyld 3 的执行步骤分两大步，以图中虚线隔开，虚线以上进程外执行，以下进程创建时执行：</p><ul><li>前 3 步查找依赖和符号相对耗时，且涉及一些安全问题，所以将这些信息做成缓存闭包写入磁盘里，对应地址：<code>tmp/com.apple.dyld</code>。闭包会在重启手机&#x2F;更新&#x2F;下载 App 的首启等时机创建。</li><li>进程启动时，读取闭包并验证闭包有效性。</li><li>后面步骤同 dyld 2</li></ul><h3 id="iOS-15-的LC-DYLD-CHAINED-FIXUPS"><a href="#iOS-15-的LC-DYLD-CHAINED-FIXUPS" class="headerlink" title="iOS 15 的LC_DYLD_CHAINED_FIXUPS"></a>iOS 15 的LC_DYLD_CHAINED_FIXUPS</h3><p>在iOS15 上，APP的<code>rebase</code> &amp; <code>bind</code> 的方式发生了变化。</p><p>如果我们将<code>iOS Deployment Target</code>设置为15的话，通过<code>MachOView</code>查看打包后的Mach-O文件会发现新的二进制上出现了不支持的LC。</p><p><img src="https://upload-images.jianshu.io/upload_images/4642217-76d3f18e9cc92b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/830/format/webp" alt="img"></p><p>这是由于<code>LC_DYLD_INFO_ONLY</code>被替换成了新增的<code>LC_DYLD_EXPORTS_TRIE</code>和<code>LC_DYLD_CHAINED_FIXUPS</code>。</p><p>文件的变化意味着iOS 15的<code>rebase</code>和<code>bind</code>机制发生了变化。回顾iOS 14及以前，<code>dyld</code>是通过解析压缩字节流实现了<code>rebase</code>和<code>bind</code>。解析压缩字节会告诉<code>dyld</code> 整个二进制文件中有哪些地址需要修正，以及在<code>bind</code>时每个地址是为哪个外部符号预留。那iOS 15 <code>dyld</code>是如何进行过修正的呢？接下来我们探索下<code>dyld</code>。</p><p> 前段时间听到有同学讨论iOS 15 <code>dyld3</code> 更新为<code>dyld4</code>了。笔者无法确定苹果是否偷偷地升级了<code>dyld</code>，但是从蛛丝马迹中可以看出来<code>dyld</code> 确实是有变化，例如在<code>instrument</code> 中我们可以看到部分函数的命名空间变成了<code>dyld4</code>。还有就是一些API的调用上发生了一些变化，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">let header:UnsafePointer<span class="hljs-tag">&lt;<span class="hljs-name">mach_header</span>&gt;</span> = _dyld_get_image_header(0)<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在iOS 15系统之前通过索引获取<code>header</code>时，如果<code>index == 0</code>，返回的是可执行程序的<code>header</code>。但是在iOS 15中，<code>index == 0</code>获取到的却是系统库。当然这些变化对我们的业务代码可能还不足以产生影响，但是可以说明<code>dyld</code> 确定是有改动。那<code>LC_DYLD_CHAINED_FIXUPS</code>是<code>dyld</code>的新特性吗？我的答案是否定的。因为从<code>dyld3</code>的<code>dyld-852.2</code>版本中可以看到<code>LC_DYLD_CHAINED_FIXUPS</code>早就预埋在dyld中了，只不过在<code>iOS Deployment Target == 15</code>时引起Mach-O文件变化后，才能进入相应的代码分支。</p><h3 id="iOS15上如何让你的应用启动更快？"><a href="#iOS15上如何让你的应用启动更快？" class="headerlink" title="iOS15上如何让你的应用启动更快？"></a>iOS15上如何让你的应用启动更快？</h3><p>在iOS 15中，原本用于rebase &amp; bind 的压缩字节流被替换，取而代之的是fixup-chains(链表结构)。在iOS 启动时，dyld 先判断是否存在fixup-chains，如果存在fixup-chains 则按照fixup-chains的方式进行解析，否则还是按照压缩字节流的方式解析。解析的目的是为了将应用程序的地址进行修正。fixup-chains 机制是由三层结构进行存储，分别是segment（段）-&gt; pages(页) -&gt; fixup-chains(指针链表) 组成。LC_DYLD_CHAINED_FIXUPS所指向的数据会告诉我们有多少segments，每个segment的信息又会告诉我们这个segment有多少pages，以及每个page 的fixup-chains在哪里。 而 fixup-chains中的指针指向了当前page中每一个需要rebase 或者 bind的地址，这些地址中存储的数据并非像iOS 15之前那样都是0x00，而是有一定格式的具有一定意义的8字节数据。而这短短的8字节数据被按照不同的结构体拆分成多个bit，每个或连续几个bit都具有其特殊的含义用于推断rebase 或 bind 所需要的一切信息。iOS 15废除了lazy_bind(weak_bind仍然保留)，由于rebase和bind 被整合为一个链表，因此遍历一次链表即可完成一个page所需的rebase和bind。</p><p><strong>那fixup-chains为什么能加快启动呢？</strong></p><p>因为在iOS 15以前，rebase和bind的信息在压缩字节流中是分别存储的。这就意味着，在启动时dyld在做rebase时会先遍历一遍rebase压缩字节流所记录的地址进行地址修改，假设为N次page fault，由于经过rebase 的page 是被写入数据的dirty page，因此不会被释放，iOS 会通过压缩的方式优化最近没有使用到的dirty page。然后在进行bind时，又遍历bind压缩字节流所记录的那些地址进行修改，假设需要bind M个page。那么在N和M这两个Pages集合中可能存在很多重叠，这就造成了二次遍历，并且iOS可能对其中某些dirty page做了压缩优化。在这种情况下，bind时就需要对这些重叠的pages做解压操作。而fixup-chains很巧妙地解决了这个问题，因为同一个page的rebase和bind整合成一个链表，同时进行这两种操作，这样就不会存在重复遍历相同的page，也不会存在解压的问题。</p><p><strong>疑问</strong></p><p>fixup-chains 会减少page falut次数吗？：不会，依旧是<code>M</code> ∪<code>N</code></p><p>有人问这个算不算iOS 帮我们做了二进制重排？：完全是两回事。虽然都提到了page fault，但是阶段是不同的。</p><p><a href="https://easeapi.com/blog/blog/83-ios13-dyld3.html" title="iOS 13中dyld 3的改进和优化">iOS 13中dyld 3的改进和优化</a></p><p><a href="https://www.yotrolz.com/posts/c2aae680/" title="iOS dyld 前世今生">iOS dyld 前世今生</a></p><p><a href="https://www.jianshu.com/p/6ff72443377b">从野指针探测到对iOS 15 bind 的探索</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift-weak的实现</title>
    <link href="/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在Swift中, <code>SideTable</code> 是针对有需要的对象而创建，系统会为目标对象分配一块新的内存来保存该对象额外的信息。 因为这不是对象必须的内容，所以这个 <code>SideTable</code> 可有可无。对象会有一个指向 <code>SideTable</code> 的指针，同时 <code>SideTable</code> 也有一个指回原对象的指针。在实现上为了不额外多占用内存，目前只有在创建弱引用时，会先把对象的引用计数放到新创建的 <code>SideTable</code> 去，再把空出来的空间存放 <code>SideTable</code> 的地址，会通过一个标志位来区分对象是否有 <code>SideTable</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JYObject</span>&#123;<br>    <span class="hljs-keyword">var</span> age :<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;JY&quot;</span><br>&#125;<br> <br>  <span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">JYObject</span>()<br>    <br>  <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> t2 <span class="hljs-operator">=</span> t<br>    <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们在<code>print</code>处打上断点，查看t2对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">(lldb) po t2<br>▿ Optional&lt;JYObject&gt;<br>  ▿ some : &lt;JYObject: <span class="hljs-number">0x6000001a9710</span>&gt;<br><br>(lldb) x/<span class="hljs-number">8</span>gx  <span class="hljs-number">0x6000001a9710</span><br><span class="hljs-number">0x6000001a9710</span>: <span class="hljs-number">0x0000000100491e18</span> <span class="hljs-number">0xc0000c00001f03dc</span><br><span class="hljs-number">0x6000001a9720</span>: <span class="hljs-number">0x0000000000000012</span> <span class="hljs-number">0x000000000000594a</span><br><span class="hljs-number">0x6000001a9730</span>: <span class="hljs-number">0xe200000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000001a9740</span>: <span class="hljs-number">0x00007efd22b59740</span> <span class="hljs-number">0x000000000000009c</span><br>(lldb) <br></code></pre></td></tr></table></figure><p>通过查看汇编，定义了一个<code>weak</code>变量，编译器自动调用了<code>swift_weakInit</code>函数，这个函数是由<code>WeakReference</code>调用的。说明<code>weak</code>字段在编译器声明的过程当中自动生成了<code>WeakReference</code>对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">WeakReference *<span class="hljs-title">swift::swift_weakInit</span><span class="hljs-params">(WeakReference *ref, HeapObject *value)</span> </span>&#123;<br>  ref-&gt;<span class="hljs-built_in">nativeInit</span>(value);<br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">(HeapObject *object)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = object ? object-&gt;refCounts.formWeakReference() : <span class="hljs-literal">nullptr</span>;<br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">WeakReferenceBits</span>(side), std::memory_order_relaxed);<br>  &#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::formWeakReference()<br>&#123;<br>    <span class="hljs-comment">// 创建一个 Side Table</span><br>  <span class="hljs-keyword">auto</span> side = <span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (side)<br>      <span class="hljs-comment">// 增加一个弱引用</span><br>    <span class="hljs-keyword">return</span> side-&gt;<span class="hljs-built_in">incrementWeak</span>();<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 我们来看一下<code>allocateSideTable</code>方法，是如何创建一个<code>Side Table</code>的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::<span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-type">bool</span> failIfDeiniting)<br>&#123;<br>  <span class="hljs-comment">//1.拿到原有的引用计数</span><br>  <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>  <br>  <span class="hljs-comment">// 判断是否有SideTable，</span><br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>    <span class="hljs-comment">// Already have a side table. Return it.</span><br>    <span class="hljs-keyword">return</span> oldbits.<span class="hljs-built_in">getSideTable</span>();<br>  &#125; <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>    <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Preflight passed. Allocate a side table.</span><br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> custom side table allocator</span><br> <br>  <span class="hljs-comment">//2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象</span><br>  HeapObjectSideTableEntry *side = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HeapObjectSideTableEntry</span>(<span class="hljs-built_in">getHeapObject</span>());<br> <br>  <span class="hljs-comment">//3.将创建的实例对象地址给了InlineRefCountBits，也就是 RefCountBitsT</span><br>  <span class="hljs-keyword">auto</span> newbits = <span class="hljs-built_in">InlineRefCountBits</span>(side);<br>  <br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>      <span class="hljs-comment">// Already have a side table. Return it and delete ours.</span><br>      <span class="hljs-comment">// Read before delete to streamline barriers.</span><br>      <span class="hljs-keyword">auto</span> result = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>      <span class="hljs-keyword">delete</span> side;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>      <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>     <br>    <span class="hljs-comment">// 将原有的引用计数存储</span><br>    side-&gt;<span class="hljs-built_in">initRefCounts</span>(oldbits);<br>     <br>  &#125; <span class="hljs-keyword">while</span> (! refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                             std::memory_order_release,<br>                                             std::memory_order_relaxed));<br>  <span class="hljs-keyword">return</span> side;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结一下上面所做的事情</p><p>1.拿到原有的引用计数<br>2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象<br>3.将创建的实例对象地址给了<code>InlineRefCountBits</code>，也就是 RefCountBitsT。</p></blockquote><p>构造完 <code>Side Table</code> 以后，对象中的 <code>RefCountBitsT</code> 就不是原来的引用计数了，而是一个指向 <code>Side Table</code> 的指针，然而由于它们实际都是 <code>uint64_t</code>，因此需要一个方法来区分。区分的方法我们可以来看 <code>InlineRefCountBits</code> 的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//弱引用</span><br><span class="hljs-function">LLVM_ATTRIBUTE_ALWAYS_INLINE</span><br><span class="hljs-function">  <span class="hljs-title">RefCountBitsT</span><span class="hljs-params">(HeapObjectSideTableEntry* side)</span></span><br><span class="hljs-function">    : bits((reinterpret_cast&lt;BitsType&gt;(side) &gt;&gt; Offsets::SideTableUnusedLowBits)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::UseSlowRCShift)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::SideTableMarkShift))</span><br><span class="hljs-function">  &#123;</span><br>    <span class="hljs-built_in">assert</span>(refcountIsInline);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在弱引用方法中把创建出来的地址做了偏移操作然后存放到了内存当中。</p><p><code>SideTableUnusedLowBits</code> &#x3D; 3，所以，在这个过程中，传进来的<code>side</code>往右移了 3 位，下面的两个是 62 位和 63 位标记成 1</p></blockquote><p>我们接着来看一下 <code>HeapObjectSideTableEntry</code> 的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapObjectSideTableEntry</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> does object need to be atomic?</span><br>  std::atomic&lt;HeapObject*&gt; object;<br>  SideTableRefCounts refCounts;<br><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HeapObjectSideTableEntry</span>(HeapObject *newObject)<br>    : <span class="hljs-built_in">object</span>(newObject), <span class="hljs-built_in">refCounts</span>()<br>  &#123; &#125;<br></code></pre></td></tr></table></figure><p>我们来尝试还原一下 拿到弱引用计数 </p><p><code>0xc0000c00001f03dc</code>62位和63位清0得到 <code>HeapObjectSideTableEntry</code> 实例对象的地址<code>0xC00001F03DC</code></p><p>它既然是右移 3 位，那么我左移 3 位把它还原，<code>HeapObjectSideTableEntry</code>左移三位 得到<code>0x10062AFE0</code></p><p><img src="https://gitee.com/zhangferry/Images/raw/master/iOSWeeklyLearning/20220302155825.png"></p><ul><li><code>0x6000001a9710</code> 就是实例对象的地址。</li><li><code>0x0000000000000002</code>就是弱引用计数。<br>这里弱引用为<code>2</code>的原因是因为<code>SideTableRefCountBits</code>初始化的时候从<code>1</code>开始.</li></ul><p> <code>Side Table</code>的生命周期与对象是分离的，当强引用计数为 0 时，只有 <code>HeapObject</code> 被释放了，并没有释放<code>Side Table</code>，只有所有的 <code>weak</code> 引用者都被释放了或相关变量被置 <code>nil</code> 后，<code>Side Table</code> 才能得以释放</p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift-对象的内存结构</title>
    <link href="/2021/09/01/Swift%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <url>/2021/09/01/Swift%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h3 id="Swift对象的内存结构"><a href="#Swift对象的内存结构" class="headerlink" title="Swift对象的内存结构"></a>Swift对象的内存结构</h3><p><code>Swift</code>对象的内存结构<code>HeapObject</code>，HeapObject (对应OC中的objc_object) ，有两个属性： 一个是 <code>Metadata</code> ，一个是 <code>RefCount</code> ，默认占用 16 字节大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HeapObject</span> &#123;<br>  HeapMetadata <span class="hljs-type">const</span> * metadata;<br>  InlineRefCounts refCounts;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>HeapMetadata数据结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">swift_class_t</span>: NSObject&#123;<br>   <span class="hljs-type">void</span> *kind; <span class="hljs-comment">//isa, kind(unsigned long)</span><br>   <span class="hljs-type">void</span> *superClass;<br>   <span class="hljs-type">void</span> *cacheData<br>   <span class="hljs-type">void</span> *data<br>   <span class="hljs-type">uint32_t</span> flags; <span class="hljs-comment">//4</span><br>   <span class="hljs-type">uint32_t</span> instanceAddressOffset; <span class="hljs-comment">//4</span><br>   <span class="hljs-type">uint32_t</span> instanceSize;<span class="hljs-comment">//4</span><br>   <span class="hljs-type">uint16_t</span> instanceAlignMask; <span class="hljs-comment">//2</span><br>   <span class="hljs-type">uint16_t</span> reserved; <span class="hljs-comment">//2</span><br><br>   <span class="hljs-type">uint32_t</span> classSize; <span class="hljs-comment">//4</span><br>   <span class="hljs-type">uint32_t</span> classAddressOffset; <span class="hljs-comment">//4</span><br>   <span class="hljs-type">void</span> *description;<br>   <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Macho中的Swift类储存结构"><a href="#Macho中的Swift类储存结构" class="headerlink" title="Macho中的Swift类储存结构"></a>Macho中的Swift类储存结构</h3><p><code>Swift</code> 类的结构描述，结构体 <code>ClassContextDescriptor</code> 是 <code>Swift</code> 类在 <code>macho</code> 里 <code>Section64(__TEXT,__const)</code> 中的存储结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ClassContextDescriptor</span>&#123;</span><br>    <span class="hljs-type">uint32_t</span> Flag;<br>    <span class="hljs-type">uint32_t</span> Parent;<br>    <span class="hljs-type">int32_t</span>  Name;<br>    <span class="hljs-type">int32_t</span>  AccessFunction; <span class="hljs-comment">// 通过此地址可以获取到MetaData地址</span><br>    <span class="hljs-type">int32_t</span>  FieldDescriptor;<br>    <span class="hljs-type">int32_t</span>  SuperclassType;<br>    <span class="hljs-type">uint32_t</span> MetadataNegativeSizeInWords;<br>    <span class="hljs-type">uint32_t</span> MetadataPositiveSizeInWords;<br>    <span class="hljs-type">uint32_t</span> NumImmediateMembers;<br>    <span class="hljs-type">uint32_t</span> NumFields;<br>    <span class="hljs-type">uint32_t</span> FieldOffsetVectorOffset;<br>    <br>    &lt;泛型签名&gt; <span class="hljs-comment">//字节数与泛型的参数和约束数量有关</span><br>    <br>    &lt;MaybeAddResilientSuperclass&gt;<span class="hljs-comment">//有则添加4字节</span><br>    <br>    &lt;MaybeAddMetadataInitialization&gt;<span class="hljs-comment">//有则添加4*3字节</span><br>    <br>    VTableList[]<span class="hljs-comment">//先用4字节存储offset/pointerSize，再用4字节描述数量，随后N个4+4字节描述函数类型及函数地址。</span><br>    <br>    OverrideTableList[]<span class="hljs-comment">//先用4字节描述数量，随后N个4+4+4字节描述当前被重写的类、被重写的函数描述、当前重写函数地址。</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="如何判断是否为泛型？"><a href="#如何判断是否为泛型？" class="headerlink" title="如何判断是否为泛型？"></a>如何判断是否为泛型？</h4><p>通过 <code>Flag</code> 来判断，如果 <code>Flag</code> 的 <code>generic</code> 标记位为1，则说明为泛型</p><hr><h4 id="泛型的长度如何计算？"><a href="#泛型的长度如何计算？" class="headerlink" title="泛型的长度如何计算？"></a>泛型的长度如何计算？</h4><p>假设有泛型有 <code>paramsCount</code> 个参数，有 <code>requeireCount</code> 个约束</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">short</span> pandding = (<span class="hljs-type">unsigned</span>) - paramsCount &amp; <span class="hljs-number">3</span>;<br> 泛型签名字节数 = (<span class="hljs-number">16</span> + paramsCount + pandding + <span class="hljs-number">3</span> * <span class="hljs-number">4</span> * (requeireCount) + <span class="hljs-number">4</span>);<br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     16B  =  4B + 4B + 2B + 2B + 2B + 2B</span><br><span class="hljs-comment">     addMetadataInstantiationCache -&gt; 4B</span><br><span class="hljs-comment">     addMetadataInstantiationPattern -&gt; 4B</span><br><span class="hljs-comment">     GenericParamCount -&gt; 2B</span><br><span class="hljs-comment">     GenericRequirementCount -&gt; 2B</span><br><span class="hljs-comment">     GenericKeyArgumentCount -&gt; 2B</span><br><span class="hljs-comment">     GenericExtraArgumentCount -&gt; 2B</span><br><span class="hljs-comment"> */</span><br> <br></code></pre></td></tr></table></figure><blockquote><p><font color="#54d530">注意：这只是 <code>macho</code> 当中的类的结构形态，但是实际运行的时候，则是会从 <code>metadata + offset(函数偏移位置)</code> 来调用，即将函数地址存储在<code>X8</code> 寄存器中</font></p></blockquote><hr><p><code>Swift</code> 类的 <code>Metadata</code> 位于 <code>__DATA</code> 段，是可读写的，其结构如下：</p><p>上述所提到的 <code>offset(偏移地址)</code>也就是 <code>metaData</code> 距离 <code>func[0]</code> 的距离</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwiftClass</span> &#123;</span><br>    NSInteger kind;<br>    id superclass;<br>    NSInteger reserveword1;<br>    NSInteger reserveword2;<br>    NSUInteger rodataPointer;<br>    UInt32 classFlags;<br>    UInt32 instanceAddressPoint;<br>    UInt32 instanceSize;<br>    UInt16 instanceAlignmentMask;<br>    UInt16 runtimeReservedField;<br>    UInt32 classObjectSize;<br>    UInt32 classObjectAddressPoint;<br>    NSInteger nominalTypeDescriptor; <span class="hljs-comment">// 会指向CalssContextDescriptor</span><br>    NSInteger ivarDestroyer;<br>    <span class="hljs-comment">//func[0]</span><br>    <span class="hljs-comment">//func[1]</span><br>    <span class="hljs-comment">//func[2]</span><br>    <span class="hljs-comment">//func[3]</span><br>    <span class="hljs-comment">//func[4]</span><br>    <span class="hljs-comment">//func[5]</span><br>    <span class="hljs-comment">//func[6]</span><br>    ....<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="ClassContextDescriptor-与-MetaData-之间的关系？"><a href="#ClassContextDescriptor-与-MetaData-之间的关系？" class="headerlink" title="ClassContextDescriptor 与 MetaData 之间的关系？"></a>ClassContextDescriptor 与 MetaData 之间的关系？</h3><p>**<code>MetaData</code> 地址 + <code>0x40</code>  &#x3D;  <code>ClassContextDescriptor</code> 地址 **</p><p><strong><code>ClassContextDescriptor</code> 地址 + <code>AccessFunction（0x12）</code> &#x3D; <code>MetaData</code> 地址</strong></p><blockquote><p><font color="#54d530">注意： 如果编译器进行了缓存，则不会通过 <code>AccessFunction</code> 来获取，直接用缓存中拿到  <code>MetaData</code> 地址</font></p></blockquote><hr><h3 id="Swift方法存储结构"><a href="#Swift方法存储结构" class="headerlink" title="Swift方法存储结构"></a>Swift方法存储结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwiftMethod</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> Flag;<br>    <span class="hljs-type">uint32_t</span> Offset;<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>Flag</code> 的4个字节代表 函数的类型，例如动态，实例，函数类型 <code>Kind</code></p><p><code>Offset</code> 代表存储函数的相对地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// 函数类型 kind 对应的枚举如下所示</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">NS_ENUM</span><span class="hljs-params">(NSInteger, SwiftMethodKind)</span> &#123;<br>    SwiftMethodKindMethod             = <span class="hljs-number">0</span>,     <span class="hljs-comment">// method</span><br>    SwiftMethodKindInit               = <span class="hljs-number">1</span>,     <span class="hljs-comment">//init</span><br>    SwiftMethodKindGetter             = <span class="hljs-number">2</span>,     <span class="hljs-comment">// get</span><br>    SwiftMethodKindSetter             = <span class="hljs-number">3</span>,     <span class="hljs-comment">// set</span><br>    SwiftMethodKindModify             = <span class="hljs-number">4</span>,     <span class="hljs-comment">// modify</span><br>    SwiftMethodKindRead               = <span class="hljs-number">5</span>,     <span class="hljs-comment">// read</span><br>&#125;;<br></code></pre></td></tr></table></figure><hr><h2 id="类重写的函数"><a href="#类重写的函数" class="headerlink" title="类重写的函数"></a>类重写的函数</h2><p><code>Swift</code> 类重写的函数是单独存储的，单独的 <code>OverrideTable </code>，并且 <code>OverrideTable </code> 是存储在 <code>VTable</code> 之后，其结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SwiftOverrideMethod</span> &#123;</span><br>    <span class="hljs-type">uint32_t</span> OverrideClass;<span class="hljs-comment">//记录是重写哪个类的函数，指向TypeContext</span><br>    <span class="hljs-type">uint32_t</span> OverrideMethod;<span class="hljs-comment">//记录重写哪个函数，指向SwiftMethod</span><br>    <span class="hljs-type">uint32_t</span> Method;<span class="hljs-comment">//函数相对地址</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>即修改 <code>Method</code> 为 Hook 的函数地址，那么就可以实现对 重写类的方法的HOOK，与顺序以及数量都无关，</p><hr><h3 id="swift5-types"><a href="#swift5-types" class="headerlink" title="__swift5_types"></a>__swift5_types</h3><p><code> __swift5_types</code> 中存储的是 <code>Class</code> 、<code>Struct</code> 、 <code>Enum</code> 的地址</p><p><code>types</code> 不是 <code>8</code> 字节地址，而是 <code>4</code> 字节，并且所存储的数据明显不是直接地址</p><p>当前文件偏移 + 随后4字节中存储的 <code>value</code>  即可得到 <code>class</code> 地址</p><hr><h4 id="Swift-为什么要采用这种方式来存储数据？"><a href="#Swift-为什么要采用这种方式来存储数据？" class="headerlink" title="Swift 为什么要采用这种方式来存储数据？"></a>Swift 为什么要采用这种方式来存储数据？</h4><p>按照 <code>OC</code> 的习惯需要 <code>8</code> 个字节，现在只需要 <code>4</code> 个字节就能解决，这样的话能够节省包大小</p><p><code>|TypeFlag(16bit)|version(8bit)|generic(1bit)|unique(1bit)|unknown (1bit)| Kind(5bit)|</code></p><p><code>Flag</code> 比较有用的低5位和高16位。低5位可以代表32类型，中间位用来表示<code>version</code> 、是否唯一、泛型等 </p><ul><li>低5位标识当前描述的类型，是 <code>Class</code> | <code>Struct</code> | <code>Enum</code> | <code>Protocol</code> 等等。</li></ul><p>高16位用于标识是否有 <code>Class_HasVTable</code> | <code>Class_HasOverrideTable</code> | <code>Class_HasResilientSuperclass</code> 等等</p><hr><h4 id="如何判断是Class以及拥有V-table"><a href="#如何判断是Class以及拥有V-table" class="headerlink" title="如何判断是Class以及拥有V-table"></a>如何判断是Class以及拥有V-table</h4><p>我们拿到 <code>Class Flag</code> , <code>0x80000050</code>为例 ，其中低5位是 <code>0x50 = 10000 = 16(十进制)</code>, 在 <code>ContextDescriptorKind</code> 当中，16 代表 <code>Class</code></p><p> 高16位为 <code>0x8000 = 10000000000000</code> , 在 <code>TypeContextDescriptorFlags</code> 中，第16位为1 则代表 <code>Class_HasVTable</code>, 所以 <code>swiftType.flag &amp; 0x80000050) == 0x80000050</code> 成立也就是具有 <code>V-Table</code> 的类</p><hr><h3 id="如何知道函数中是否调用了某个Class"><a href="#如何知道函数中是否调用了某个Class" class="headerlink" title="如何知道函数中是否调用了某个Class?"></a><strong>如何知道函数中是否调用了某个Class?</strong></h3><p>在二进制文件中，函数都是4个字节的汇编指令内容，所有的指令都是按地址顺序执行，因此函数都是连续的并且无论有多少 <code>if else</code> 多少 <code>return</code> ，函数只存在一个ret指令位于函数指令结尾</p><p>因此当遇到 <code>ret</code> 的时候就可以认为函数结束 </p><font color="#54d530">引用类会将类的地址放入寄存器中，类的地址是 `classref` 中记录的地址，并且，如果类的地址如果低12位为0，则会将类地址一次性放入寄存器。如果低12位不为0，则会先将高位存入寄存器中，再将低12位存入寄存器中，经过运算加法形成真正的地址</font><p><img src="https://raw.githubusercontent.com/krystal1110/markdownPic/master/tuchuang20220620140706.png"></p><p><strong>在函数范围内，先查看是否直接命中目标函数地址，如果命中则认为类被调用，如果没有直接命中则查看是否先命中高位，再命中低位，如果都命中，则认为类被调用。细心的同学可能会发现，假设存在高位命中了，但是低位被其他地址命中了，则会存在被误报的情况</strong></p><hr>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift关键字</title>
    <link href="/2021/08/16/Swift%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2021/08/16/Swift%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="final关键字有什么作用？"><a href="#final关键字有什么作用？" class="headerlink" title="final关键字有什么作用？"></a>final关键字有什么作用？</h3><p><code>final</code> 定义以后就直接调用，不会继承</p><hr><h3 id="objc关键字有什么作用？"><a href="#objc关键字有什么作用？" class="headerlink" title="@objc关键字有什么作用？"></a>@objc关键字有什么作用？</h3><p>暴露方法给OC调用，并不会改变函数的调用方式</p><p>底层原理：<code>@objc</code> 新生成一个方法,只是暴露了一个方法,但新方法里面还是调用了 <code>swift</code> 原来的方法调用</p><hr><h3 id="dynamic关键字有什么用？"><a href="#dynamic关键字有什么用？" class="headerlink" title="dynamic关键字有什么用？"></a>dynamic关键字有什么用？</h3><p>给函数添加动态的特性，并不会改变函数的调用方式</p><hr><h3 id="dynamicReplacement-有什么作用？"><a href="#dynamicReplacement-有什么作用？" class="headerlink" title="@_dynamicReplacement 有什么作用？"></a>@_dynamicReplacement 有什么作用？</h3><p><code>@_dynamicReplacement</code> 和 <code>dynamic</code> 必须一起使用</p><p><code>@_dynamicReplacement</code> 修饰的方法会替代 <code>dynamic</code> 所修饰的方法</p><p><code>@_dynamicReplacement</code> 需要在 <code>extension</code> 中使用</p><hr><h3 id="objc-dynamic-一起使用会发生什么？"><a href="#objc-dynamic-一起使用会发生什么？" class="headerlink" title="@objc + dynamic 一起使用会发生什么？"></a><code>@objc</code> + <code>dynamic</code> 一起使用会发生什么？</h3><p>函数的调用方式为objc_msgSend</p><hr><h3 id="mutating关键字有什么作用？"><a href="#mutating关键字有什么作用？" class="headerlink" title="mutating关键字有什么作用？"></a>mutating关键字有什么作用？</h3><ul><li>值类型本身创建之后是不允许修改的，如果要修改，需要使⽤ <code>mutating</code> 关键字</li><li><code>mutating</code>的本质是给方法参数 增加了 <code>@inout</code></li></ul><hr><h3 id="nonmutating关键字有什么作用？其结果会有什么不同吗？"><a href="#nonmutating关键字有什么作用？其结果会有什么不同吗？" class="headerlink" title="nonmutating关键字有什么作用？其结果会有什么不同吗？"></a>nonmutating关键字有什么作用？其结果会有什么不同吗？</h3><hr><h3 id="typealias关键字有什么作用？"><a href="#typealias关键字有什么作用？" class="headerlink" title="typealias关键字有什么作用？"></a>typealias关键字有什么作用？</h3><p>对一些数据结构提供别名；<br>可以用于一些框架隔离、结构语义化的场景；</p><hr><h3 id="subscript关键字有什么作用"><a href="#subscript关键字有什么作用" class="headerlink" title="subscript关键字有什么作用?"></a>subscript关键字有什么作用?</h3><p>我们可以对某些结构自定义下标实现方式，方便</p><hr><h3 id="lazy关键字有什么作用-其底层原理如何实现"><a href="#lazy关键字有什么作用-其底层原理如何实现" class="headerlink" title="lazy关键字有什么作用? 其底层原理如何实现?"></a>lazy关键字有什么作用? 其底层原理如何实现?</h3><p>lazy关键字可以对修改的属性懒加载</p><p>底层原理是基于 可选值  进行实现；</p><hr><h3 id="有用过array-lazy-map吗？和array-map有什么区别？"><a href="#有用过array-lazy-map吗？和array-map有什么区别？" class="headerlink" title="有用过array.lazy.map吗？和array.map有什么区别？"></a>有用过array.lazy.map吗？和array.map有什么区别？</h3><hr><h3 id="为什么不能创建-lazy-let-实例属性"><a href="#为什么不能创建-lazy-let-实例属性" class="headerlink" title="为什么不能创建 lazy let 实例属性?"></a>为什么不能创建 lazy let 实例属性?</h3><hr><h3 id="convenience关键字有什么作用"><a href="#convenience关键字有什么作用" class="headerlink" title="convenience关键字有什么作用?"></a>convenience关键字有什么作用?</h3><p>次等的便利构造器，最后会调用指定构造器初始化实例。</p><hr><h3 id="fallthrough关键字有什么作用"><a href="#fallthrough关键字有什么作用" class="headerlink" title="fallthrough关键字有什么作用?"></a>fallthrough关键字有什么作用?</h3><p>让Switch中的case继续往后执行；<br>在代码中可以避免使用这种关键字，因为当调整顺序或者修改逻辑时可能会发生不必要的问题，如果有多个枚举值执行相同逻辑时可以直接使用case .one, ,two:这种形式。</p><hr><h3 id="fileprivate、private、internal、public、open有什么区别？"><a href="#fileprivate、private、internal、public、open有什么区别？" class="headerlink" title="fileprivate、private、internal、public、open有什么区别？"></a>fileprivate、private、internal、public、open有什么区别？</h3><ul><li>open   在public的基础上增加了跨包继承功能；</li><li>public 表示共有访问权限 </li><li>internal 内部的访问权限（默认） </li><li>private   私有访问权限 </li><li>fileprivate  表示在当前的源文件可以访问</li></ul><hr><h3 id="Optional的本质是什么？"><a href="#Optional的本质是什么？" class="headerlink" title="Optional的本质是什么？"></a>Optional的本质是什么？</h3><p>optional本质是一个枚举enum</p><p>枚举接收⼀个泛型参数，有none和some两个case ，⽽当前some的关联值是传入的Wrapped，可以通过模式匹配来匹配对应的值</p><hr><h3 id="unsafelyUnwrapped关键字作用？"><a href="#unsafelyUnwrapped关键字作用？" class="headerlink" title="unsafelyUnwrapped关键字作用？"></a>unsafelyUnwrapped关键字作用？</h3><p>unsafelyUnwrapped和强制解包的作用一致，但是在Release下使用!强制解包，会导致崩溃，而使用unsafelyUnwrapped，则不会崩溃，打印结果为0</p><hr><h3 id="as、as-、as-之间的区别？"><a href="#as、as-、as-之间的区别？" class="headerlink" title="as、as?、as!之间的区别？"></a>as、as?、as!之间的区别？</h3><ul><li>as用于类型转换，可以使用as、as?、as!几种方式 </li><li>as?可以避免编译报错，使用as?返回的是可选项，如果转换失败，直接返回nil </li><li>使用as!强制类型转换，如果转换失败，程序直接崩溃</li></ul><hr><h3 id="defer有哪些用？有什么好处？在什么时候执行？"><a href="#defer有哪些用？有什么好处？在什么时候执行？" class="headerlink" title="defer有哪些用？有什么好处？在什么时候执行？"></a>defer有哪些用？有什么好处？在什么时候执行？</h3><p>defer 先出现的后执行</p><p>常用于资源回收，统一管理，避免逻辑分支过多而忘记操作，例如写文件的时候关闭文件流</p><p>注意事项：需要在return之前才执行</p><p>defer执行时机：当前作用域结束后不久执行</p><hr><h3 id="propertyWrapper是什么？有什么用？"><a href="#propertyWrapper是什么？有什么用？" class="headerlink" title="@propertyWrapper是什么？有什么用？"></a>@propertyWrapper是什么？有什么用？</h3><ul><li><code>@propertyWrapper</code> 的本质就是包装修饰属性的<code>set get</code>方法 </li><li><code>@propertyWrapper</code> 的作用就是降低代码重复率 </li><li><code>@propertyWrapper</code> 的应用中的 <code>projectedValue</code> 在<code>SwiftUI</code> 的 <code>@State</code>中, 作为 <code>@Binding</code> 的修饰对象的引用传递来解决多层嵌套UI的状态同步问题.</li></ul><hr><h3 id="associatedtype关键字有什么用？"><a href="#associatedtype关键字有什么用？" class="headerlink" title="associatedtype关键字有什么用？"></a>associatedtype关键字有什么用？</h3><hr><h3 id="try，try-，-try-三者使用上有什么区别？"><a href="#try，try-，-try-三者使用上有什么区别？" class="headerlink" title="try，try?， try!三者使用上有什么区别？"></a>try，try?， try!三者使用上有什么区别？</h3><hr><h3 id="infix-关键字有什么用？"><a href="#infix-关键字有什么用？" class="headerlink" title="infix 关键字有什么用？"></a>infix 关键字有什么用？</h3><p>指明一个用于两个值之间的运算符。如果一个全新的全局运算符被定义为  <code>infix</code> ，还需要指定优先级</p><hr><h3 id="indirect关键字在枚举中有什么作用？"><a href="#indirect关键字在枚举中有什么作用？" class="headerlink" title="indirect关键字在枚举中有什么作用？"></a>indirect关键字在枚举中有什么作用？</h3><p>指明在枚举类型中，存在成员使用相同枚举类型的实例作为关联值的情况。</p><hr><h3 id="在Swift当中，Int占几个字节"><a href="#在Swift当中，Int占几个字节" class="headerlink" title="**在Swift当中，Int占几个字节 **"></a>**在Swift当中，Int占几个字节 **</h3><ul><li><p>Int占8个字节</p></li><li><p>Int16, 等于short, 占2个字节. -32768 32767</p></li><li><p>Int32, 等于int, 占4个字节. -2147483648 2147483647</p></li><li><p>Int64, 等于long, 占8个字节. -9223372036854775808 9223372036854775807</p></li><li><p>Int8 ，占用1个字节</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-OOM产生的原因</title>
    <link href="/2021/08/08/iOS-OOM%E5%8E%9F%E7%90%86/"/>
    <url>/2021/08/08/iOS-OOM%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM"></a>什么是<code>OOM</code></h4><p><code>out-of-memory</code> 内存超过限制，iOS的<code>Jetsam</code>机制造成的一种<code>Crash</code>，这种另类<code>Crash</code>，通过通过<code>Signal</code>捕获等方法无法捕获</p><h4 id="什么又是FOOM"><a href="#什么又是FOOM" class="headerlink" title="什么又是FOOM"></a>什么又是<code>FOOM</code></h4><p><code>Foreground-out-of-memory</code> App在前台因消耗内存过多而引起的系统强杀</p><h4 id="什么是JetSam机制"><a href="#什么是JetSam机制" class="headerlink" title="什么是JetSam机制"></a>什么是<code>JetSam</code>机制</h4><p><code>JetSam</code>机制是操作系统为了控制内存资源过度所建立的一种管理机制，<code>JetSam</code>是一个独立的进程，每一个进程都会有一个阈值，一旦超过这个值，<code>JetSam</code>就会杀死这个进程，设备的内存是有限制的，并不是无限大的，所以内存资源非常重要。系统进程及用户使用的其他app的进程都会争抢这个资源。由于iOS不支持交换空间，一旦触发低内存事件，<code>Jetsam</code>就会尽可能多的释放应用占用的内存，这样在iOS系统上出现系统内存不足时，应用就会被系统终止。</p><h4 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h4><p>物理内存不够使用该怎么办呢？像一些桌面操作系统，会有内存交换空间，在window上称为虚拟内存。它的机制是，在需要时能将物理内存中的一部分交换到硬盘上去，利用硬盘空间扩展内存空间。</p><h4 id="iOS不支持交换空间"><a href="#iOS不支持交换空间" class="headerlink" title="iOS不支持交换空间"></a>iOS不支持交换空间</h4><p>但iOS并不支持交换空间，大多数移动设备都不支持交换空间。移动设备的大容量存储器通常是闪存，它的读写速度远远小于电脑所使用的硬盘，这就导致在移动设备上就算使用了交换空间，也并不能提升性能。其次，移动设备的容量本身就经常短缺、内存的读写寿命也有限，所以不适合拿闪存来做内存交换</p><h4 id="典型app内存类型"><a href="#典型app内存类型" class="headerlink" title="典型app内存类型"></a>典型app内存类型</h4><p>当内存不足的时候，系统会按照一定策略来腾出更多空间供使用，比较常见的做法是将一部分低优先级的数据挪到磁盘上，这个操作称为Page Out。之后当再次访问到这块数据的时候，系统会负责将它重新搬回内存空间中，这个操作称为Page In。</p><h4 id="Clean-Memory"><a href="#Clean-Memory" class="headerlink" title="Clean Memory"></a>Clean Memory</h4><p>Clean Memory是指那些可以用以Page Out的内存，只读的内存映射文件，或者是App所用到的frameworks。每个frameworks都有_DATA_CONST段，通常他们都是Clean的，但如果用runtime进行swizzling，那么他们就会变Dirty。</p><h4 id="Dirty-Memory"><a href="#Dirty-Memory" class="headerlink" title="Dirty Memory"></a>Dirty Memory</h4><p>Dirty Memory是指那些被App写入过数据的内存，包括所有堆区的对象、图像解码缓冲区，同时，类似Clean memory，也包括App所用到的frameworks。每个framework都会有_DATA段和_DATA_DIRTY段，它们的内存是Dirty的。</p><p>值得注意的是，在使用framework的过程中会产生Dirty Memory，使用单例或者全局初始化方法是减少Dirty Memory不错的方法，因为单例一旦创建就不会销毁，全局初始化方法会在类加载时执行。</p><h4 id="Compressed-Memory"><a href="#Compressed-Memory" class="headerlink" title="Compressed Memory"></a>Compressed Memory</h4><p>由于闪存容量和读写寿命的限制，iOS 上没有交换空间机制，取而代之使用Compressed memory。</p><p>Compressed memory是在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用。它在节省内存的同时提高了系统的响应速度，特点总结起来如下：</p><p>Shrinks memory usage 减少了不活跃内存占用 Improves power efficiency 改善电源效率，通过压缩减少磁盘IO带来的损耗 Minimizes CPU usage 压缩&#x2F;解压十分迅速，能够尽可能减少 CPU 的时间开销 Is multicore aware 支持多核操作 例如，当我们使用Dictionary去缓存数据的时候，假设现在已经使用了3页内存，当不访问的时候可能会被压缩为1页，再次使用到时候又会解压成3页。</p><p>本质上，<code>Compressed memory</code>也是<code>Dirty memory</code>。<br>因此， <code>memory footprint = dirty size + compressed size</code> ，这也就是我们需要并且能够尝试去减少的内存占用。</p><h4 id="出现OOM前一定会出现Memory-Warning么？"><a href="#出现OOM前一定会出现Memory-Warning么？" class="headerlink" title="出现OOM前一定会出现Memory Warning么？"></a>出现OOM前一定会出现<code>Memory Warning</code>么？</h4><p>答案是不一定，有可能瞬间申请了大量内存，而恰好此时主线程在忙于其他事情，导致可能没有经历过Memory Warning就发生了OOM。当然即便出现了多次Memory Warning后，也不见得会在最后一次Memory Warning的几秒钟后出现OOM。之前做extension开发的时候，就经常会出现Memory Warnning，但是不会出现OOM，再操作一两分钟后，才出现OOM，而在这一两分钟内，没有再出现过Memory Warning。</p><p>当然在内存警告时，处理内存，可以在一定程度上避免出现OOM。</p><h4 id="开始分析系统的JetSam"><a href="#开始分析系统的JetSam" class="headerlink" title="开始分析系统的JetSam"></a>开始分析系统的<code>JetSam</code></h4><p><code>bsd_init</code>当中找到初始化<code>JetSam</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// iOS上独有的特性，内存和进程的休眠的常驻监控线程</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_FREEZE   <span class="hljs-comment">// 这个宏是内核会对进程进行冷冻而不是kill掉</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMORYSTATUS</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* Initialise background freezing */</span><br>    <span class="hljs-built_in">bsd_init_kprintf</span>(<span class="hljs-string">&quot;calling memorystatus_freeze_init\n&quot;</span>);<br>    <span class="hljs-built_in">memorystatus_freeze_init</span>(); <span class="hljs-comment">//从内核中开启优先级最高的线程来监控整个系统的内存情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//iOS独有，JetSAM（即低内存事件的常驻监控线程）</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_MEMORYSTATUS</span><br>    <span class="hljs-comment">/* Initialize kernel memory status notifications */</span><br>    <span class="hljs-built_in">bsd_init_kprintf</span>(<span class="hljs-string">&quot;calling memorystatus_init\n&quot;</span>);<br>    <span class="hljs-built_in">memorystatus_init</span>(); <span class="hljs-comment">//从内核中开启优先级最高的线程来监控整个系统的内存情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_MEMORYSTATUS */</span></span><br></code></pre></td></tr></table></figure><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>在内核里面所有的进程都有一个优先级，通过一个数组维护，数组的每一项是一个进程的列表也就是<code>memstat_bucket</code>。这个数组的大小则是<code>JETSAM_PRIORITY_MAX + 1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMSTAT_BUCKET_COUNT (JETSAM_PRIORITY_MAX + 1)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">memstat_bucket</span> &#123;<br>    <span class="hljs-built_in">TAILQ_HEAD</span>(, proc) list; <span class="hljs-comment">//一个TAILQ_HEAD的双向链表用来存放优先级</span><br>    <span class="hljs-type">int</span> count; <span class="hljs-comment">//进程个数</span><br>    <span class="hljs-type">int</span> relaunch_high_count;<br>&#125; <span class="hljs-type">memstat_bucket_t</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">memstat_bucket_t</span> memstat_bucket[MEMSTAT_BUCKET_COUNT]; <span class="hljs-comment">//优先级队列(里面包含不同优先级的结构)    </span><br></code></pre></td></tr></table></figure><p>在这里可以看到优先级数字，其中<code>SpringBoard</code>就<code>JETSAM_PRIORITY_HOME</code>,后台应用程序为<code>JETSAM_PRIORITY_BACKGROUND</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb50ee7d685846d1ad3b6ac2c1496a4e~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="回到-memorystatus-init"><a href="#回到-memorystatus-init" class="headerlink" title="回到 memorystatus_init"></a>回到 <code>memorystatus_init</code></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jetsam_threads = zalloc<span class="hljs-constructor">_permanent(<span class="hljs-params">sizeof</span>(<span class="hljs-params">struct</span> <span class="hljs-params">jetsam_thread_state</span>)</span><span class="hljs-operator"> *</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>max_jetsam_threads, <span class="hljs-constructor">ZALIGN(<span class="hljs-params">struct</span> <span class="hljs-params">jetsam_thread_state</span>)</span>);<br><br><br><span class="hljs-comment">/* Initialize all the jetsam threads */</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; max_jetsam_threads; i++) &#123;<br><br><span class="hljs-comment">// max_jetsam_threads 性能差为1个 ，普通为3个</span><br>jetsam_threads<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.inited = FALSE;<br>jetsam_threads<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.index = i;<br><br><br><span class="hljs-comment">//这些线程的优先级是内核所能分配的最高级95 MAXPRI_KERNEL  (XNU的线程优先级为0-127)</span><br>result = kernel<span class="hljs-constructor">_thread_start_priority(<span class="hljs-params">memorystatus_thread</span>, NULL, 95 <span class="hljs-operator">/</span><span class="hljs-operator">*</span> MAXPRI_KERNEL <span class="hljs-operator">*</span><span class="hljs-operator">/</span>, &amp;<span class="hljs-params">jetsam_threads</span>[<span class="hljs-params">i</span>].<span class="hljs-params">thread</span>)</span>;<br><span class="hljs-keyword">if</span> (result != KERN_SUCCESS) &#123;<br>     panic(<span class="hljs-string">&quot;Could not create memorystatus_thread %d&quot;</span>, i);<br>&#125;<br>     thread<span class="hljs-constructor">_deallocate(<span class="hljs-params">jetsam_threads</span>[<span class="hljs-params">i</span>].<span class="hljs-params">thread</span>)</span>;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="来到-memorystatus-thread"><a href="#来到-memorystatus-thread" class="headerlink" title="来到 memorystatus_thread"></a>来到 <code>memorystatus_thread</code></h4><p>系统中会有一个线程专门来管理内存状态，当内存出现问题或者压力过大时，将会通过一些方法来干掉APP回收内存</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbac5549ff7249d4a21f8c009ef12be8~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><p><code>memorystatus_action_needed()</code>是触发OOM的核心判断条件。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f9f965fa5194490b1a56a272bd7f2d2~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="我们来到-is-reason-thrashing"><a href="#我们来到-is-reason-thrashing" class="headerlink" title="我们来到 is_reason_thrashing"></a>我们来到 <code>is_reason_thrashing</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a731f7cd91614b75b3c0cf852819ccea~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="memorystatus-action-needed为true来到了Highwater"><a href="#memorystatus-action-needed为true来到了Highwater" class="headerlink" title="memorystatus_action_needed为true来到了Highwater"></a><code>memorystatus_action_needed</code>为true来到了<code>Highwater</code></h4><p>来到这里证明当前内存紧张，来到<code>memorystatus_act_on_hiwat_processes</code></p><h4 id="memorystatus-act-on-hiwat-processes"><a href="#memorystatus-act-on-hiwat-processes" class="headerlink" title="memorystatus_act_on_hiwat_processes"></a><code>memorystatus_act_on_hiwat_processes</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539a3a8aed30452e9f5d3e8610538d97~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><p>则会调用<code>memorystatus_kill_hiwat_proc</code></p><ol><li>优先级队列里面取出优先级最低的进程</li><li>while循环查找进程的内存是否高于阈值</li><li>如果高于则通过<code>memorystatus_do_kill</code>杀掉这个进程，并结束循环</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37ebcdf7faa64f049020f209fd3fc070~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><p>如果经过了<code>Highwater</code>还是没有办法结束进程，将来到<code>memorystatus_act_aggressive</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d74e199fadb4df0ad63134f4c79ec4e~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="memorystatus-act-aggressive-也就是我们所经常遇到的OOM"><a href="#memorystatus-act-aggressive-也就是我们所经常遇到的OOM" class="headerlink" title="memorystatus_act_aggressive 也就是我们所经常遇到的OOM"></a><code>memorystatus_act_aggressive</code> 也就是我们所经常遇到的OOM</h4><p>这部分代码太多 我就贴关键的代码了</p><h4 id="如果上面memorystatus-act-aggressive函数没有杀死任何进程，那么就需要通过LRU来杀死Jetsam队列中的第一个进程"><a href="#如果上面memorystatus-act-aggressive函数没有杀死任何进程，那么就需要通过LRU来杀死Jetsam队列中的第一个进程" class="headerlink" title="如果上面memorystatus_act_aggressive函数没有杀死任何进程，那么就需要通过LRU来杀死Jetsam队列中的第一个进程"></a>如果上面<code>memorystatus_act_aggressive</code>函数没有杀死任何进程，那么就需要通过<code>LRU</code>来杀死<code>Jetsam</code>队列中的第一个进程</h4><h3 id="总结-系统触发OOM的过程"><a href="#总结-系统触发OOM的过程" class="headerlink" title="总结 - 系统触发OOM的过程"></a>总结 - 系统触发OOM的过程</h3><ol><li><code>JetSam</code>线程初始化完毕，从外部接受到有内存压力</li><li>如果接收到的内存压力是当前物理内存达到限制时，则触发<code>per-process-limit</code>类型的<code>OOM</code>，然后退出流程</li><li>如果接收到内存压力是其他类型时，唤醒<code>JetSam</code>线程，判断当前可用内存紧张则进入<code>OOM</code>逻辑</li><li>首先遍历优先级最低的进程，判断进程是否高于阈值，如果没有高于阈值，则查找比当前优先级高一级的进程，直到找到后，触发<code>high-water</code>类型<code>OOM</code></li><li>如果没有触发<code>high-water</code> ，那就先回收一个优先级较低的进程或者标记为随时可回收的进程</li><li>当所有低优先级进程和随时可回收的进程都被杀掉后，如果<code>memorystatus_available_pages</code>可用内存依然低于正常水平，那就开始杀掉后台进程，每杀掉一个后台进程，则判断一下<code>memorystatus_available_pages</code>可用内存是否还是低于正常水平，如果已经恢复到正常，则挂起线程，等待唤醒</li><li>当所有后台进程都被杀死后，可用内存还是低于正常，那就开始杀掉前台的进程，挂起线程，等待唤醒</li><li>如果上面没有杀掉任何进程，就通过<code>LRU</code>杀死<code>JetSam</code>队列中的第一个进程，挂起线程，等待唤醒</li></ol><h4 id="Matrix如何检测OOM？"><a href="#Matrix如何检测OOM？" class="headerlink" title="Matrix如何检测OOM？"></a><code>Matrix</code>如何检测<code>OOM</code>？</h4><p><code>Matrix</code>采用的是排除法，在每次启动<code>Matrix</code>的时候都会调用<code>[MatrixAppRebootAnalyzer checkRebootType];</code></p><p>来看一下<code>checkRebootType</code>方法中有什么</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs awk">+ (void)checkRebootType &#123;<br>    <span class="hljs-keyword">if</span> ([MatrixDeviceInfo isBeingDebugged]) &#123; <span class="hljs-regexp">//</span> 是否在DEBUG<br>        MatrixInfo(@<span class="hljs-string">&quot;app is being debugged&quot;</span>);<br>        MatrixAppRebootInfo *info = [MatrixAppRebootInfo sharedInstance];<br>        info.isAppCrashed = NO;<br>        info.isAppQuitByExit = NO;<br>        info.isAppQuitByUser = NO;<br>        info.isAppWillSuspend = NO;<br>        info.isAppEnterBackground = NO;<br>        info.isAppEnterForeground = NO;<br>        info.isAppBackgroundFetch = NO;<br>        info.isAppSuspendKilled = NO;<br>        info.isAppMainThreadBlocked = NO;<br>        info.dumpFileName = @<span class="hljs-string">&quot;&quot;</span>;<br>        info.userScene = @<span class="hljs-string">&quot;&quot;</span>;<br>        [info saveInfo];<br>        return;<br>    &#125;<br><br>    MatrixAppRebootInfo *info = [MatrixAppRebootInfo sharedInstance];<br><br>    <span class="hljs-keyword">if</span> (info.isAppCrashed) &#123;<br>        <span class="hljs-regexp">//</span> App是否发生了普通的Crash<br>        s_rebootType = MatrixAppRebootTypeNormalCrash;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppQuitByUser) &#123;<br>        <span class="hljs-regexp">//</span> 是否用户主动退出应用<br>        s_rebootType = MatrixAppRebootTypeQuitByUser;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppQuitByExit) &#123;<br>        <span class="hljs-regexp">//</span> 是否调用了<span class="hljs-keyword">exit</span>相关的函数<br>        s_rebootType = MatrixAppRebootTypeQuitByExit;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppWillSuspend || info.isAppBackgroundFetch) &#123;<br>        <span class="hljs-regexp">//</span> App是否挂起Suspend或者执行了BackgroundFetch<br>        <span class="hljs-keyword">if</span> (info.isAppSuspendKilled) &#123;<br>            s_rebootType = MatrixAppRebootTypeAppSuspendCrash;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s_rebootType = MatrixAppRebootTypeAppSuspendOOM;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([MatrixAppRebootAnalyzer isAppChange]) &#123;<br>        <span class="hljs-regexp">//</span> App的版本是否发生了改变<br>        s_rebootType = MatrixAppRebootTypeAPPVersionChange;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([MatrixAppRebootAnalyzer isOSChange]) &#123;<br>        <span class="hljs-regexp">//</span> 手机系统是否升级了<br>        s_rebootType = MatrixAppRebootTypeOSVersionChange;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([MatrixAppRebootAnalyzer isOSReboot]) &#123;<br>        <span class="hljs-regexp">//</span> 手机是否重启了<br>        s_rebootType = MatrixAppRebootTypeOSReboot;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppEnterBackground) &#123;<br>        <span class="hljs-regexp">//</span> App是否处于后台<br>        s_rebootType = MatrixAppRebootTypeAppBackgroundOOM;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppEnterForeground) &#123;<br>        <span class="hljs-regexp">//</span> App是否处于前台<br>        <span class="hljs-keyword">if</span> (info.isAppMainThreadBlocked) &#123;<br>            <span class="hljs-regexp">//</span> 主线程是否卡死了 <br>            s_rebootType = MatrixAppRebootTypeAppForegroundDeadLoop;<br>            s_lastDumpFileName = info.dumpFileName;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-regexp">//</span> 触发Foreground OOM<br>            s_rebootType = MatrixAppRebootTypeAppForegroundOOM;<br>            s_lastDumpFileName = @<span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s_rebootType = MatrixAppRebootTypeOtherReason;<br>    &#125;<br></code></pre></td></tr></table></figure><p>现在所遇到的<code>OOM</code>主要都是<code>FOOM</code>，因为优先级的缘故，App在后台的时候，即使占用内存很少，也有可能被前台应用过多占用内存而被杀死，所以关注的点上还是要在<code>FOOM</code></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/TuGeLe/article/details/104004692">深入了解iOS中的OOM(低内存崩溃)</a></p><p>(<a href="http://www.cocoachina.com/index.php/articles/485753">你真的了解OOM吗？——京东iOS APP内存优化实录</a>)</p><p><a href="https://juejin.cn/post/6844903749836603400">iOS Out-Of-Memory 原理阐述及方案调研</a></p><p><a href="https://wetest.qq.com/lab/view/367.html">iOS微信内存监控</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-编译过程梳理</title>
    <link href="/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-编译过程梳理"><a href="#iOS-编译过程梳理" class="headerlink" title="iOS 编译过程梳理"></a>iOS 编译过程梳理</h1><p>编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率很高。</p><h2 id="编译器的概述"><a href="#编译器的概述" class="headerlink" title="编译器的概述"></a>编译器的概述</h2><p>编译器的作用是把我们的高级语言转换成机器可以识别的机器码，经典的设计结构如下：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dwrp77ruj20ki03z0sn.jpg"></p><ul><li>前端（Frontend）：语法分析，语义分析和生成中间代码。在这个过程中，也会对代码进行检查，如果发现出错的或需要警告的会标注出来。</li><li>优化器（Optimizer）：会进行 BitCode 的生成，链接期优化等工作。</li><li>后端（Backend）：针对不同的架构，生成对应的机器码。</li></ul><h2 id="Clang-LLVM-的编译过程"><a href="#Clang-LLVM-的编译过程" class="headerlink" title="Clang + LLVM 的编译过程"></a>Clang + LLVM 的编译过程</h2><ol><li><strong>预处理阶段</strong>：import 头文件替换；macro 宏展开；处理预编译指令</li><li><strong>词法分析</strong>：预处理完成后进入词法分析，将输入的代码转化为一系列符合特定语言的词法单元（token 流）。</li><li><strong>语法分析</strong>：将词法分析得到的 token 流进行语法静态分析（Static Analysis），输出<strong>抽象语法树（AST）</strong>，过程中会校验语法是否错误。</li><li><strong>CodeGen 生成 IR 中间代码</strong>：CodeGen 负责将语法树自顶向下遍历翻译成 <code>LLVM IR</code>，<code>IR</code> 是编译过程中前端的输出后端的输入。</li><li><strong>Optimize 优化 IR</strong>：到这里 LLVM 会做一些优化工作，在 Xcode 的编译设置里可以设置优化级别 -01, -03, -0s，也可以写自己的 Pass，Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。附件：<a href="http://llvm.org/docs/WritingAnLLVMPass.html">官方 Pass 教程</a>。</li><li><strong>LLVM Bitcode 生成字节码</strong>：如果开启了 bitcode，苹果会做进一步优化。若有新的后端架构，依旧可以用这份优化过的 bitcode 去生成。</li><li><strong>生成汇编</strong></li><li><strong>生成目标文件</strong></li><li><strong>生成可执行文件</strong></li></ol><h2 id="Xcode-Build-的流程"><a href="#Xcode-Build-的流程" class="headerlink" title="Xcode Build 的流程"></a>Xcode Build 的流程</h2><p>我们在 Xcode 中使用 <strong>Command + B</strong> 或 <strong>Command + R</strong> 时，即完成了一次编译，来看下这个过程做了哪些事情。</p><p>编译过程分为四个步骤：</p><ul><li>预编译（Pre-process）：宏替换、删除注释、展开头文件，产生 .i 文件。</li><li>编译（Compliling）：把前面生成的 .i 文件转化为汇编语言，产生 .s 文件。</li><li>汇编（Asembly）：把汇编语言 .s 文件转化为机器码文件，产生 .0 文件。</li><li>链接（Link）：对 .o 文件中的对于其他库的引用的地方进行引用，生成最后的可执行文件。也包括多个 .o 文件进行 link。</li></ul><p>通过解析 Xcode 编译 log，可以发现 Xcode 是根据 Target 进行编译的。我们可以通过 Xcode 中的 Build Phases、Build Settings 及 Build Rules 来控制编译过程。</p><ul><li>Build Settings：这一栏下是对编译的细节进行设定，包含 build 过程的每个阶段的设置选项（包含编译、链接、代码签名、打包）。</li><li>Build Phases：用于控制从源文件到可执行文件的整个过程，如编译哪些文件，编译过程中执行哪些自定义脚本。例如 CocoaPods 在这里会进行相关配置。</li><li>Build Rules：指定了不同的文件类型该如何编译。一般我们不需要修改这里的内容。如果需要对特定类型的文件添加处理方法，可以在这里添加规则。</li></ul><p>每个 Target 的具体编译过程也可以通过 log 日志获得。大致过程为：</p><ul><li>编译信息写入辅助文件（如Entitlements.plist），创建编译后的文件架构</li><li>写入辅助信息（.hmap 文件）。将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件。</li><li>运行预设的脚本。如 Cocoapods 会在 Build Phases 中预设一些脚本（CheckPods Manifest.lock）。</li><li>编译 .m 文件，生成可执行文件 Mach-O。每次进行了 LLVM 的完整流程：前端（词法分析 - 语法分析 - 生成 IR）、优化器（优化 IR）、后端（生成汇编 - 生成目标文件 - 生成可执行文件）。使用 <code>CompileC</code> 和 <code>clang</code> 命令。 CompileC 是 xcodebuild 内部函数的日志记录表示形式，它是 build.log 文件中有关编译的基本信息来源。</li><li>链接需要的库。如 Foundation.framework，AFNetworking.framework…</li><li>拷贝资源文件到目标包</li><li>编译 storyboard 文件</li><li>链接 storyboard 文件</li><li>编译 Asset 文件。如果使用 Asset.xcassets 来管理图片，这些图片会被编译为机器码，除了 icon 和 launchIamge。</li><li>处理 infoplist</li><li>执行 CocoaPods 脚本，将在编译项目前已编译好的依赖库和相关资源拷贝到包中。</li><li>拷贝 Swift 标准库</li><li>创建 .app 文件并对其签名</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-系统内存泄露</title>
    <link href="/2021/07/01/iOS-%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <url>/2021/07/01/iOS-%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
    
    <content type="html"><![CDATA[<p>下面是复现泄漏的测试代码，<code>JYObject</code>是一个没有任何多余代码的类，继承自<code>NSObject</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">JYObject * jyobject = [JYObject <span class="hljs-keyword">new</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span> * <span class="hljs-number">1000</span>; ++i) &#123;<br>    id value = @<span class="hljs-string">&quot;JY&quot;</span>;<br>    [jyobject validateValue:&amp;value forKey:@<span class="hljs-string">&quot;notexistkey&quot;</span> error:nil];<br>&#125;<br></code></pre></td></tr></table></figure><p>当对一个没有实现校验方法的key进行<code>validateValue</code>时，就会有少量内存泄漏。如果执行很多次，结果还是很可观的。上面的代码会让内存飙到160M。</p><h4 id="定位泄漏源"><a href="#定位泄漏源" class="headerlink" title="定位泄漏源"></a>定位泄漏源</h4><p>这个泄漏使用Instruments的Leaks模版可以很快的发现，但是代码却不好定位。下面是Leaks报告的泄漏截图。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1nksnswpjj20yg06hwf7.jpg"></p><p>可以看出，泄漏发生在<code>validateValue:forKey:error:</code>，再细看右边的调用栈，可以看到这块内存是由<code>malloc</code>分配的。所以很有可能是这个系统方法内部发生了泄漏。</p><p>可以看出，泄漏发生在<code>validateValue:forKey:error:</code>，再细看右边的调用栈，可以看到这块内存是由<code>malloc</code>分配的。所以很有可能是这个系统方法内部发生了泄漏。</p><h4 id="使用符号断点深入观察系统方法"><a href="#使用符号断点深入观察系统方法" class="headerlink" title="使用符号断点深入观察系统方法"></a>使用符号断点深入观察系统方法</h4><p>首先使用符号断点，让程序在<code>validateValue:forKey:error:</code>处停下。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/17/162d197750bcc39e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>运行程序，命中断点后，我们就可以观察<code>validateValue:forKey:error:</code>的汇编代码了。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/17/162d197750e0badd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h4 id="寻找Leak的内存来源"><a href="#寻找Leak的内存来源" class="headerlink" title="寻找Leak的内存来源"></a>寻找Leak的内存来源</h4><p>在汇编代码中，我发现了一个malloc调用和一个free调用。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x1048272ef</span> &lt;+<span class="hljs-number">63</span>&gt;:  callq  <span class="hljs-number">0x10498b1da</span>               <span class="hljs-comment">; symbol stub for: malloc</span><br>...<br><span class="hljs-number">0x104827389</span> &lt;+<span class="hljs-number">217</span>&gt;: callq  <span class="hljs-number">0x10498b066</span>               <span class="hljs-comment">; symbol stub for: free</span><br>复制代码<br></code></pre></td></tr></table></figure><p>通过单步调试发现，malloc出来的内存主要用来存储key，并且把首字母变成大写，应该是为了方便构成<code>validate&lt;Key&gt;:error:</code>的selector name。不过如果对象上没有校验这个key的方法，那么代码会直接jump到free调用的下二行。这样这个内存块就永远不会被释放了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x104827390</span> &lt;+<span class="hljs-number">224</span>&gt;: movb   $<span class="hljs-number">0</span>x1, %r14b<br></code></pre></td></tr></table></figure><p>当我们给LeakObject加上notexistkey的校验方法后，单步可以发现free被调用。下面是增加的校验方法。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">- (BOOL)validateNotexistkey:(<span class="hljs-built_in">id</span> *)value <span class="hljs-keyword">error</span>:(NSError **)<span class="hljs-keyword">error</span> &#123;<br><span class="hljs-built_in">    return</span> YES;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这次泄漏的寻找过程，大致可以分为</p><ol><li>使用Instruments Leak模版初步定位</li><li>使用符号断点深入泄漏方法，如果泄漏的方法不是系统或者第三方静态（动态）库的方法，就不用这么麻烦了。</li><li>关注泄漏内存块的分配释放方式，在源码或者汇编代码中寻找匹配的内存块。 由于这次泄漏的仅仅是malloc内存块，所以OC的引用计数记录并不能起什么作用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS日常问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-线程数量监控</title>
    <link href="/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/"/>
    <url>/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<p>在iOS开发中，我们会经常开辟新的线程去做一些事，如何合理的开辟线程，在App开发阶段，监控线程的开辟数量，避免线上发生意外情况。 </p><p>当线程过多或瞬间创建大量子线程(线程爆炸)，就在控制台打印信息，并记录信息。</p><ol><li><p>创建子线程过多，是会造成性能问题的，因为创建线程需要占用内存空间（默认的情况下，主线程占1M,子线程占用512KB）。</p></li><li><p>不合理创建和使用线程，容易引发数据一致性（线程安全）和死锁问题。</p></li></ol><p>因为在iOS中基本上都是使用的<code>p_thread</code>，在<code>Mach</code>层中<code>thread_basic_info</code> 结构体封装了单个线程的基本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">struct thread_basic_info &#123;<br>    time_value_t  user_time;      /* user run time */<br>    time_value_t  system_time;    /* system run time */<br>    integer_t    cpu_usage;       /* scaled cpu usage percentage */<br>    policy_t     policy;          /* scheduling policy in effect */<br>    integer_t    run_state;       /* run state (see below) */<br>    integer_t    flags;           /* various flags (see below) */<br>    integer_t    suspend_count;   /* suspend count for thread */<br>    integer_t    sleep_time;      /* number of seconds that thread  has been sleeping */<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<code>Mach Task</code>包含它的线程列表。内核提供了<code>task_threads</code> API 调用获取指定 task 的线程列表，然后可以通过<code>thread_info</code> API调用来查询指定线程的信息，在 thread_act.h 中有相关定义。</p><p><code>task_threads</code> 将<code>target_task</code> 任务中的所有线程保存在<code>act_list</code>数组中，act_listCnt表示线程个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">kern_return_t task_threads<br>(<br>    task_t target_task,<br>    thread_act_array_t *act_list,<br>    mach_msg_type_number_t *act_listCnt<br>);<br></code></pre></td></tr></table></figure><p> <code>thread_info</code>结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">kern_return_t</span> <span class="hljs-title">thread_info</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_act_t</span> target_act,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_flavor_t</span> flavor,  <span class="hljs-comment">// 传入不同的宏定义获取不同的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_info_t</span> thread_info_out,  <span class="hljs-comment">// 查询到的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">mach_msg_type_number_t</span> *thread_info_outCnt  <span class="hljs-comment">// 信息的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p> 如果频繁调用<code>task_threads</code>函数，来获取线程数量和增长速度，大量调用这个函数会造成一定的性能问题</p><p>通过<code>hook</code>线程的创建和销毁，来监听线程的数量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//在#include &lt;pthread/introspection.h&gt;文件里</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">定义函数指针：pthread_introspection_hook_t</span><br><span class="hljs-comment">event  : 线程处于的生命周期（下面枚举了线程的4个生命周期）</span><br><span class="hljs-comment">thread ：线程</span><br><span class="hljs-comment">addr   ：线程栈内存基址</span><br><span class="hljs-comment">size   ：线程栈内存可用大小</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">pthread_introspection_hook_t</span>)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> event,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-keyword">enum</span> &#123;<br>PTHREAD_INTROSPECTION_THREAD_CREATE = <span class="hljs-number">1</span>, <span class="hljs-comment">//创建线程</span><br>PTHREAD_INTROSPECTION_THREAD_START, <span class="hljs-comment">// 线程开始运行</span><br>PTHREAD_INTROSPECTION_THREAD_TERMINATE,  <span class="hljs-comment">//线程运行终止</span><br>PTHREAD_INTROSPECTION_THREAD_DESTROY, <span class="hljs-comment">//销毁线程</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">看这个函数名，很像我们平时hook函数一样的。</span><br><span class="hljs-comment">返回值是上面声明的pthread_introspection_hook_t函数指针：返回原线程生命周期函数。</span><br><span class="hljs-comment">参数也是函数指针：传入的是我们自定义的线程生命周期函数</span><br><span class="hljs-comment">*/</span><br>__attribute__((__nonnull__, __warn_unused_result__))<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">pthread_introspection_hook_t</span></span><br><span class="hljs-function"><span class="hljs-title">pthread_introspection_hook_install</span><span class="hljs-params">(<span class="hljs-type">pthread_introspection_hook_t</span> hook)</span></span>;<br><br></code></pre></td></tr></table></figure><h4 id="下面开始写一个Monitor"><a href="#下面开始写一个Monitor" class="headerlink" title="下面开始写一个Monitor"></a>下面开始写一个<code>Monitor</code></h4><p>先来定义一些参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static pthread_introspection_hook_t original_pthread_introspection_hook_t = NULL;<br><br>/// 创建信号量<br>static dispatch_semaphore_t semaphore;<br><br>/// 线程总数<br>static int threadCount = 0;<br><br>/// 是否开启监控<br>static bool isMonitor = false;<br><br>/// 线程总数阈值<br>static int averageThreadCount = 40;<br><br>/// 线程在一定时间内新增数<br>static int newThreadCount = 0;<br><br>/// 线程在一定时间内新增阈值<br>static int newAverageThreadCount = 10;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 开启监控<br>+ (void)startMonitor&#123;<br>    // 创建信号量 最大并发数为1<br>    semaphore = dispatch_semaphore_create(1);<br>    // 等待<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <br>    mach_msg_type_number_t count;<br>    thread_act_array_t threads;<br>    // 获取到count<br>    task_threads(mach_task_self(), &amp;threads, &amp;count);<br>   <br>    // 保证加锁的时候，线程数量不变<br>    threadCount = count;<br>    <br>    // 添加🪝钩子函数<br>    original_pthread_introspection_hook_t = pthread_introspection_hook_install(kry_pthread_introspection_hook_t);<br>    <br>    // 解锁 信号量+1<br>    dispatch_semaphore_signal(semaphore);<br>    <br>    // 开始监控<br>    isMonitor = true;<br>    <br>    <br>    // 开启一个定时器 检测每秒线程创建 然后通过clearNewThreadCount置位0<br>    const char *queenIdentifier = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);<br>    if (queenIdentifier == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>    &#125;else&#123;<br>        dispatch_async(dispatch_get_main_queue(), ^&#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>        &#125;);<br>    &#125;<br>&#125;<br><br>// 当前线程总数<br>+ (int)currentThreadCount&#123;<br>    return threadCount;<br>&#125;<br><br>void kry_pthread_introspection_hook_t(unsigned int event,<br>                                      pthread_t thread, void *addr, size_t size)&#123;<br>    <br>    // 正常调用原有逻辑<br>    if (original_pthread_introspection_hook_t) &#123;<br>        original_pthread_introspection_hook_t(event,thread,addr,size);<br>    &#125;<br>    <br>    // 开始记录<br>    <br>    // 如果是创建线程,则线程的数量+1，新增数+1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) &#123;<br>        threadCount +=1;<br>        if (isMonitor &amp;&amp; threadCount &gt; averageThreadCount) &#123;<br>            // 总数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(false, 0);<br>        &#125;<br>        <br>        newThreadCount +=1;<br>        if (isMonitor &amp;&amp; newThreadCount &gt; newAverageThreadCount) &#123;<br>            // 新增数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(true, newThreadCount);<br>        &#125;<br>    &#125;<br>    <br>    <br>    // 销毁线程，则线程数量-1，新增数-1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_DESTROY) &#123;<br>        threadCount -=1;<br>       <br>        if (newThreadCount &gt; 0 ) &#123;<br>            newThreadCount -=1;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><br>void kry_Log_CallStack(bool isIncreaseLog, int num)<br>&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    if (isIncreaseLog) &#123;<br>        printf(&quot;\n🔥一秒钟开启 %d 条线程！！！！\n&quot;, num);<br>    &#125;<br>    // 可以记录堆栈信息<br>    dispatch_semaphore_signal(semaphore);<br>&#125;<br><br>+ (void)clearNewThreadCount&#123;<br>    newThreadCount = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，都有注释，近期在看PCL的堆栈记录，后期会把堆栈记录完善上去</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.jianshu.com/p/95df83780c8f">APP性能检测方案汇总</a></p><p><a href="https://juejin.cn/post/6844904122248855560">iOS线程数量监控工具</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-自定义Section延迟load加载</title>
    <link href="/2021/07/01/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89Section%E5%BB%B6%E8%BF%9Fload%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/07/01/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89Section%E5%BB%B6%E8%BF%9Fload%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="在指定的segment和section中存入数据"><a href="#在指定的segment和section中存入数据" class="headerlink" title="在指定的segment和section中存入数据"></a>在指定的segment和section中存入数据</h4><p>之前我们已经了解过<code>machO</code>的结构了，那么我们有没有办法去修改或者新增<code>segment</code>和<code>section</code>当中的数据呢，答案是可以的，使用<code>__attribute__ section</code>将指定的数据存储到指定的<code>segmemt</code>和<code>section</code>中，也可以在通过在<code>Build Settings</code>中的<code>Other Linker Flags</code>设置链接参数，从而达到移动段，新增段，赋予权限等操作</p><h4 id="attribute-的用法"><a href="#attribute-的用法" class="headerlink" title=" __attribute__的用法"></a><code> __attribute__</code>的用法</h4><p><code>__attribute__</code> 可以用来设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）</p><ul><li><code>__attribute__((format()))</code> 按照指定格式进行参数检查。</li></ul><hr><ul><li><code>__attribute__((__always_inline__))</code> 强制内联。</li></ul><hr><ul><li><code>__attribute__((deprecated(&quot;Use xxx: instead&quot;)</code> 这个可能是我们见的比较多的，用来标记某个方法已经被废弃了，需要用其它的方法代替。</li></ul><hr><ul><li><code>__attribute__((__unused__))</code> 标记函数或变量可能不会用到。</li></ul><hr><ul><li><p><code>__attribute__((visibility(&quot;visibility_type&quot;)))</code> 标记动态库符号是否可见，有以下取值：</p><pre><code class="hljs">   1.  `default` 符号可见，可导出。          2.  `hidden` 符号隐藏，不可导出，只能在本动态库内调用。</code></pre></li></ul><hr><ul><li><code>__attribute__((objc_designated_initializer))</code> 明确指定用于初始化的方法。一个优秀的设计，初始化接口可以有多个，但最终多个初始化初始化接口都会调用 <code>designed initializer</code> 方法。</li></ul><hr><ul><li><code>__attribute__((unavailable))</code>、<code>__attribute__((unavailable(&quot;Must use xxx: instead.&quot;)));</code> 标记方法被禁用，不能直接调用，但这并不意味着该方法不能被调用，在 Objective-C 中使用 runtime 依然可以调用。</li></ul><hr><ul><li><code>__attribute__((section(&quot;segment,section&quot;)))</code> 将一个指定的数据储存到我们需要的 segment 和 section 中。</li></ul><hr><ul><li><code>__attribute__((constructor))</code> 被 <code>attribute((constructor))</code> 标记的函数，会在 <code>main</code> 函数之前或动态库加载时执行。在 mach-o 中，被 <code>attribute((constructor))</code> 标记的函数会在 <code>_DATA</code> 段的 <code>__mod_init_func</code> 区中。当多个被标记 <code>attribute((constructor))</code> 的方法想要有顺序的执行，怎么办？<code>attribute((constructor))</code> 是支持优先级的：<code>_attribute((constructor(1)))</code></li></ul><hr><ul><li><code>__attribute__((destructor))</code> 和 <code>attribute((constructor))</code> 相反：被 <code>attribute((destructor))</code> 标记的函数，会在 <code>main</code> 函数退出或动态库卸载时执行。在 mach-o 中此类函数会放在 <code>_DATA</code> 段的 <code>__mod_term_func</code> 区中</li></ul><p>… 还有很多 这里就不一一列举了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span>&#123;<br>    <span class="hljs-type">char</span> *className;<br>    <span class="hljs-type">char</span> *method;<br>&#125;;<br><br> <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JYProtocolRegister(_className_,_method_)\</span><br><span class="hljs-meta">__attribute__((used)) static struct JYProtocolInfo JYProtocolInfo##_className_ \</span><br><span class="hljs-meta">__attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,JYLoadDelayData&quot;</span>))) =\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">    .className = #_className_,\</span><br><span class="hljs-meta">    .method = #_method_,\</span><br><span class="hljs-meta">&#125;;</span><br><br><br>@interface JYLoadDelayTool : NSObject<br><br>+ (<span class="hljs-type">void</span>)readDataFromMachO;<br><br>+ (<span class="hljs-type">void</span>)xxx;<br><br>@end<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">JYProtocolRegister</span>(JYLoadDelayTool,xxx)<br><br>+ (<span class="hljs-type">void</span>)xxx&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;123&quot;</span>);<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)readDataFromMachO &#123;<br>   <br>     Dl_info info;<br>     <span class="hljs-built_in">dladdr</span>((__bridge <span class="hljs-type">void</span> *)[self <span class="hljs-keyword">class</span>], &amp;info);<br><br>    <span class="hljs-comment">// 读取__DATA中自定义的ProtocolInfoDataz数据</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LP64__</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header</span> *mhp = (<span class="hljs-keyword">struct</span> mach_header*)info.dli_fbase;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint32_t</span> *schemeMemory = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-built_in">getsectiondata</span>(mhp, <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;JYLoadDelayData&quot;</span>, &amp;schemeSize);<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* defined(__LP64__) */</span></span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header_64</span> *mhp = (<span class="hljs-keyword">struct</span> mach_header_64*)info.dli_fbase;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint64_t</span> *schemeMemory = (<span class="hljs-type">uint64_t</span>*)<span class="hljs-built_in">getsectiondata</span>(mhp, <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;JYLoadDelayData&quot;</span>, &amp;schemeSize);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* defined(__LP64__) */</span></span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeCounter = schemeSize/<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> JYProtocolInfo);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span> *items = (<span class="hljs-keyword">struct</span> JYProtocolInfo*)schemeMemory;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; idx &lt; schemeCounter; ++idx)&#123;<br>        <br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span> * info = (<span class="hljs-keyword">struct</span> JYProtocolInfo*)&amp;items[idx];<br>        <br>        Class JYClass = <span class="hljs-built_in">NSClassFromString</span>([NSString stringWithUTF8String:info-&gt;className]);<br><br>        SEL sel = <span class="hljs-built_in">NSSelectorFromString</span>([NSString stringWithUTF8String:info-&gt;method]);<br>        <br>        <span class="hljs-built_in">id</span> (*func)(Class, SEL) = (<span class="hljs-built_in">id</span> (*)(Class, SEL))objc_msgSend;<br>       <br>        <span class="hljs-built_in">func</span>(JYClass, sel);<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>这样，可以把一些<code>+load</code>的方法都通过指定<code>JYProtocolRegister</code>来加载，这样可以优化启动时间，另外我们APM的监控，应该是最早的，这样在APP启动后的问题都能够检测到，如果<code>load</code>里面的方法有性能问题，而APM监控却是在<code>load</code>之后，那么就会检查不到，所以一些非必要性的<code>load</code>方法可以放在APM之后加载，通过上述方式</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://juejin.cn/post/6980545001126101005">iOS APP 启动优化(六)：在指定的 segment 和 section 中存入数据</a></p><p><a href="https://xiaozhuanlan.com/topic/9204153876">iOS开发之runtime（12）：深入 Mach-O</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-逆向防护</title>
    <link href="/2021/06/01/iOS-%E9%80%86%E5%90%91%E9%98%B2%E6%8A%A4/"/>
    <url>/2021/06/01/iOS-%E9%80%86%E5%90%91%E9%98%B2%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="MethodSwizzle"><a href="#MethodSwizzle" class="headerlink" title="**MethodSwizzle **"></a>**MethodSwizzle **</h3><ul><li>利用OC的运行时（Runtime）特性修改 <code>SEL</code> 和 <code>IMP(函数指针)</code> 的关系，打到Hook OC方法的目的</li><li><code>method_exchangeIMP</code>交换两个 <code>IMP</code></li><li><code>class_replaceMethod</code>替换某个 <code>SEL</code>的 <code>IMP</code> （如果没有该方法就添加，相当于换掉这个方法）</li><li><code>method_getImplementation</code> 、<code>method_setImplementation</code> 获取和设置某个方法的IMP （很多第三方框架都使用）</li></ul><hr><h3 id="MonKey-Hook"><a href="#MonKey-Hook" class="headerlink" title="MonKey Hook"></a>MonKey Hook</h3><p>Monkey中使用了  <code>libsubstrate.dylib</code></p><ul><li><code>method_setImplementation</code></li><li><code>method_getImplementation</code></li></ul><h4 id="MonKey已经替换的系统函数"><a href="#MonKey已经替换的系统函数" class="headerlink" title="MonKey已经替换的系统函数"></a><strong>MonKey已经替换的系统函数</strong></h4><ul><li>dlsym </li><li>sysctl</li><li>ptrace</li></ul><hr><h3 id="Dobby-（修改静态函数-C-和-swift）"><a href="#Dobby-（修改静态函数-C-和-swift）" class="headerlink" title="Dobby （修改静态函数 C 和 swift）"></a>Dobby （修改静态函数 C 和 swift）</h3><ul><li>实际上是替换 <code>Text段</code>   </li><li>动态修改 （加载到内存的时候修改）</li></ul><hr><h3 id="防护-：lldb-ptrace"><a href="#防护-：lldb-ptrace" class="headerlink" title="防护 ：lldb - ptrace"></a>防护 ：<code>lldb - ptrace</code></h3><ul><li><code>ptrace</code> 是 命令行工程以及 Mac OS 工程里的 <code>&lt;sys/ptrace.h&gt;</code>提供的一个函数 , 可以用来来控制进程附加管理 , 它可以实现禁止应用程序进程被附加的效果 . 在 iOS 中并没有暴露出来 , 但是 iOS 是可以使用的 .</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> arg1: ptrace要做的事情: PT_DENY_ATTACH 表示要控制的是当前进程不允许被附加</span><br><span class="hljs-comment"> arg2: 要操作进程的PID , 0就代表自己</span><br><span class="hljs-comment"> arg3: 地址 取决于第一个参数要做的处理不同传递不同</span><br><span class="hljs-comment"> arg4: 数据 取决于第一个参数要做的处理不同传递不同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ptrace</span>(PT_DENY_ATTACH, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li><p>效果：</p><ul><li>运行工程 , 程序闪退 .</li><li>从手机点开应用 , 应用正常 .</li><li>使用Xcode 自带的 Debug - Attach to process 发现附加失败</li></ul></li><li><p>破解：</p><ul><li>通过符号断点检测</li><li>使用 <code>fishhook</code>  HOOK掉ptrace这个函数</li></ul></li></ul><hr><h3 id="防护：-sysctl"><a href="#防护：-sysctl" class="headerlink" title="防护： sysctl"></a>防护： sysctl</h3><ul><li><code>sysctl ( system control )</code> 是由 <code>&lt;sys/sysctl.h&gt;</code> 提供的一个函数 , 它有很多作用 , 其中一个是可以监测当前进程有没有被附加 . 但是因为其特性 , 只是监测当前时刻应用有没有被附加 .</li><li>因此正向开发中我们往往结合定时器一起使用 , 或者 定时 &#x2F; 定期 &#x2F; 在特定时期 去使用 .</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#import <span class="hljs-string">&quot;ViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;sys/sysctl.h&gt;</span></span><br>@<span class="hljs-function">interface <span class="hljs-title">ViewController</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">@end</span><br><span class="hljs-function"></span><br><span class="hljs-function">@implementation ViewController</span><br><span class="hljs-function">BOOL <span class="hljs-title">isDebug</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> name[<span class="hljs-number">4</span>];             <span class="hljs-comment">//里面放字节码。查询的信息</span><br>    name[<span class="hljs-number">0</span>] = CTL_KERN;      <span class="hljs-comment">//内核查询</span><br>    name[<span class="hljs-number">1</span>] = KERN_PROC;     <span class="hljs-comment">//查询进程</span><br>    name[<span class="hljs-number">2</span>] = KERN_PROC_PID; <span class="hljs-comment">//传递的参数是进程的ID</span><br>    name[<span class="hljs-number">3</span>] = <span class="hljs-built_in">getpid</span>();      <span class="hljs-comment">//获取当前进程ID</span><br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> info;  <span class="hljs-comment">//接受查询结果的结构体</span><br>    <span class="hljs-type">size_t</span> info_size = <span class="hljs-built_in">sizeof</span>(info);  <span class="hljs-comment">//结构体大小</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sysctl</span>(name, <span class="hljs-number">4</span>, &amp;info, &amp;info_size, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))&#123;<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;查询失败&quot;</span>);<br>        <span class="hljs-keyword">return</span> NO;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    查询结果看info.kp_proc.p_flag 的第12位。如果为1，表示调试状态。</span><br><span class="hljs-comment">    (info.kp_proc.p_flag &amp; P_TRACED) 就是0x800, 即可获取第12位</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> ((info.kp_proc.p_flag &amp; P_TRACED) != <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">dispatch_source_t</span> timer;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debugCheck</span><span class="hljs-params">()</span></span>&#123;<br>    timer = <span class="hljs-built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">dispatch_get_global_queue</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">dispatch_source_set_timer</span>(timer, DISPATCH_TIME_NOW, <span class="hljs-number">1.0</span> * NSEC_PER_SEC, <span class="hljs-number">0.0</span> * NSEC_PER_SEC);<br>    <span class="hljs-built_in">dispatch_source_set_event_handler</span>(timer, ^&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDebug</span>()) &#123;<span class="hljs-comment">//在这里写你检测到调试要做的操作</span><br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;调试状态!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;正常！&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_resume</span>(timer);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    <span class="hljs-built_in">debugCheck</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>效果：</p><ul><li>可以上报或者 <code>exit</code></li></ul></li><li><p>破解：</p><ul><li>因为 <code>sysctl</code>函数也是系统函数，从而可以使用fishHook来交换</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">int</span>  (*sysctl_ptr)(<span class="hljs-type">int</span> *, u_int, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">my_sysctl</span><span class="hljs-params">(<span class="hljs-type">int</span> * name, u_int namelen, <span class="hljs-type">void</span> * info, <span class="hljs-type">size_t</span> * infoSize, <span class="hljs-type">void</span> * newInfo, <span class="hljs-type">size_t</span> newInfoSize)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>] == CTL_KERN &amp;&amp; name[<span class="hljs-number">1</span>] == KERN_PROC &amp;&amp; name[<span class="hljs-number">2</span>] == KERN_PROC_PID &amp;&amp; *infoSize == <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> kinfo_proc)) &#123;<br>        <br>        <span class="hljs-type">int</span> old = <span class="hljs-built_in">sysctl_ptr</span>(name,namelen,info,infoSize,newInfo,newInfoSize);<br>        <span class="hljs-comment">//拿出info</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> * myinfo = (<span class="hljs-keyword">struct</span> kinfo_proc *)info;<br>        <br>        <span class="hljs-keyword">if</span> ((myinfo-&gt;kp_proc.p_flag &amp; P_TRACED ) != <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">//使用异或取反</span><br>            myinfo-&gt;kp_proc.p_flag ^= P_TRACED;<br>        &#125;<br>        <span class="hljs-keyword">return</span> old;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sysctl_ptr</span>(name,namelen,info,infoSize,newInfo,newInfoSize);<br>&#125;<br><br>+(<span class="hljs-type">void</span>)load&#123;<br>  <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> rebingSysctl;<br>    rebingSysctl.name = <span class="hljs-string">&quot;sysctl&quot;</span>;<br>    rebingSysctl.replacement = my_sysctl;<br>    rebingSysctl.replaced = (<span class="hljs-type">void</span> *)&amp;sysctl_ptr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> rebs[<span class="hljs-number">1</span>] = &#123;rebingSysctl&#125;;<br>    <span class="hljs-built_in">rebind_symbols</span>(rebs, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：<ul><li>需要慎用 <code>exit</code> 函数</li><li>逆向中通过 <code>exit</code>  添加符号断点，就可以查看函数调用栈，从而可以看到调用 <code>exit</code>的函数地址，在减去首地址就可以拿到函数的偏移量，接着在 <code>Hopper</code> 当中就可以知道调用 <code>exit</code> 的地址了</li><li>我们自己开发所使用的 <code> framework</code> 会比注入的动态库更早的执行，虽然还是会被 <code>fishhook</code> 替换掉，但是可以在此之前，禁用掉 <code>fishhook</code> 或者完成检测</li><li>只不过如果破解人员找到这个 <code>framework</code> ，然后在 <code>load</code> 方法中直接 <code>Return</code></li></ul></li></ul><hr><hr><h3 id="防护：-通过函数地址直接调用-ptrace-和-sysctl"><a href="#防护：-通过函数地址直接调用-ptrace-和-sysctl" class="headerlink" title="防护： 通过函数地址直接调用 ptrace 和 sysctl"></a>防护： 通过函数地址直接调用 <code>ptrace</code> 和 <code>sysctl</code></h3><ul><li><p>在我工程开始我就获取 <code>ptrace / sysctl</code> 的地址 , 后面直接使用地址调用这个函数 . 实际上是可行的 , 利用 <code>dlsym</code>这个函数 .</p><ul><li>通过符号获取函数地址 ( dladdr 函数 ) </li><li>通过函数内部地址找到函数符号 ( dlsym 函数 )</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#import <span class="hljs-string">&quot;MyPtraceHeader.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callFunAddres</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> name[<span class="hljs-number">4</span>];             <span class="hljs-comment">//里面放字节码。查询的信息</span><br>    name[<span class="hljs-number">0</span>] = CTL_KERN;      <span class="hljs-comment">//内核查询</span><br>    name[<span class="hljs-number">1</span>] = KERN_PROC;     <span class="hljs-comment">//查询进程</span><br>    name[<span class="hljs-number">2</span>] = KERN_PROC_PID; <span class="hljs-comment">//传递的参数是进程的ID</span><br>    name[<span class="hljs-number">3</span>] = <span class="hljs-built_in">getpid</span>();      <span class="hljs-comment">//获取当前进程ID</span><br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> info;  <span class="hljs-comment">//接受查询结果的结构体</span><br>    <span class="hljs-type">size_t</span> info_size = <span class="hljs-built_in">sizeof</span>(info);  <span class="hljs-comment">//结构体大小</span><br>    <br>    <span class="hljs-comment">//这里做法是隐藏常量字符串</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[] = &#123;<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;s&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;y&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;s&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;c&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;t&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;l&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = str;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-keyword">while</span> (((*p) ^= <span class="hljs-string">&#x27;a&#x27;</span>) != <span class="hljs-string">&#x27;\0&#x27;</span>) p++;<br>    <br>    <span class="hljs-type">void</span> * handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;/usr/lib/system/libsystem_c.dylib&quot;</span>, RTLD_LAZY);<br><br>    <span class="hljs-built_in">int</span>  (*sysctl_ptr)(<span class="hljs-type">int</span> *, u_int, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>);<br>    <span class="hljs-comment">//获取sysctl函数指针</span><br>    sysctl_ptr = <span class="hljs-built_in">dlsym</span>(handle,(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)str);<br>    <span class="hljs-keyword">if</span> (sysctl_ptr) &#123;<br>        <br>        <span class="hljs-built_in">sysctl_ptr</span>(name, <span class="hljs-number">4</span>, &amp;info, &amp;info_size, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      <br>        <span class="hljs-keyword">if</span> ((info.kp_proc.p_flag &amp; P_TRACED ) != <span class="hljs-number">0</span> )&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;调试状态&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;正常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>破解 <ul><li>使用 <code>fishhook </code> 将  <code>dlopen</code> 与 <code>dlsym</code> 这两个系统函数干掉</li></ul></li></ul><hr><hr><h3 id="防护-汇编"><a href="#防护-汇编" class="headerlink" title="防护 汇编"></a>防护 汇编</h3><ul><li>使用汇编直接调用</li></ul><hr><hr><h3 id="字符串常量隐藏"><a href="#字符串常量隐藏" class="headerlink" title="字符串常量隐藏"></a>字符串常量隐藏</h3><ul><li>例如在App内注册第三方APP的Key,SecretKey等，字符串常量隐藏</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kWxAppID @<span class="hljs-string">&quot;krystal69d7xxxxxx&quot;</span>  </span><br> - (<span class="hljs-type">void</span>)configureForWXSDK&#123;<br>    [WXApi registerApp:kWxAppID<br>         universalLink:@<span class="hljs-string">&quot;123123&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>利用Hopper打开MachO就可以看到<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gslif4da10j31lw0egmze.jpg">  </p><ul><li>解决办法<ul><li>在方法中返回这个字符串</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KRYSTAL_ENCRYPT_KEY @<span class="hljs-string">&quot;krystal_key&quot;</span></span><br>@implementation ViewController<br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    <span class="hljs-comment">//使用函数代替字符串</span><br>    [self uploadDataWithKey:<span class="hljs-built_in">AES_KEY</span>()];  <br>&#125;<br><br>- (<span class="hljs-type">void</span>)uploadDataWithKey:(NSString *)key&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> NSString * <span class="hljs-title">AES_KEY</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[] = &#123;<br>        <span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> [NSString stringWithUTF8String:(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)key];<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><ul><li><p><strong>破解：</strong></p><ul><li>静态分析需要找到这个返回 <code> Key</code> 函数</li></ul></li><li><p><strong>升级防护</strong></p><ul><li>通过异或方式</li><li>这些字符不会进入字符常量区 . 编译器直接换算成异或结果 .<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING_ENCRYPT_KEY @<span class="hljs-string">&quot;demo_AES_key&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENCRYPT_KEY 0xAC</span><br>@<span class="hljs-function">interface <span class="hljs-title">ViewController</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">@end</span><br><span class="hljs-function"></span><br><span class="hljs-function">@implementation ViewController</span><br><span class="hljs-function">- <span class="hljs-params">(<span class="hljs-type">void</span>)</span>viewDidLoad </span>&#123;<br>    [super viewDidLoad];<br><span class="hljs-comment">//    [self uploadDataWithKey:STRING_ENCRYPT_KEY]; //使用宏/常量字符串</span><br>    [self uploadDataWithKey:<span class="hljs-built_in">AES_KEY</span>()]; <span class="hljs-comment">//使用函数代替字符串</span><br>&#125;<br><br>- (<span class="hljs-type">void</span>)uploadDataWithKey:(NSString *)key&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> NSString * <span class="hljs-title">AES_KEY</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[] = &#123;<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;d&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;e&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;m&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;o&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;_&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;A&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;E&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;S&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;_&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;\0&#x27;</span>),<br>    &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = key;<br>    <span class="hljs-keyword">while</span> (((*p) ^= ENCRYPT_KEY) != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [NSString stringWithUTF8String:(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)key];<br>&#125;<br>@end<br></code></pre></td></tr></table></figure></li></ul><ul><li><strong>效果：</strong><br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsm44y5b44j30o80ka76l.jpg"></li></ul></li></ul><hr><hr><hr><h3 id="动态库检测"><a href="#动态库检测" class="headerlink" title="动态库检测"></a>动态库检测</h3><ul><li><p>可以在服务器上存储一份 <code> _dyld_image_name</code></p></li><li><p>然后本地运行后获取到的上传服务器做比对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isExternalLibs&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-type">int</span> dyld_count = _dyld_image_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dyld_count; i++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * imageName = _dyld_get_image_name(i);<br>        NSString *res = [NSString stringWithUTF8String:imageName];<br>        <span class="hljs-keyword">if</span>([res hasPrefix:@<span class="hljs-string">&quot;/var/containers/Bundle/Application&quot;</span>])&#123;<br>            <span class="hljs-keyword">if</span>([res hasSuffix:@<span class="hljs-string">&quot;.dylib&quot;</span>])&#123;<br>                <span class="hljs-comment">//这边还需要过滤掉自己项目中本身有的动态库</span><br>                <span class="hljs-keyword">return</span> YES;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>破解：</strong> </p><ul><li>可以hook NSString的hasPrefix方法绕过检测</li></ul></li></ul><hr><hr><h3 id="防护-NSFileManager"><a href="#防护-NSFileManager" class="headerlink" title="防护  NSFileManager"></a>防护  NSFileManager</h3><ul><li>使用NSFileManager通过检测一些越狱后的关键文件&#x2F;路径是否可以访问来判断是否越狱 常见的文件&#x2F;路径有<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-type">static</span> <span class="hljs-type">char</span> *JailbrokenPathArr[] = &#123;<span class="hljs-string">&quot;/Applications/Cydia.app&quot;</span>,<br>                                     <span class="hljs-string">&quot;/usr/sbin/sshd&quot;</span>,<br>                                     <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>                                     <span class="hljs-string">&quot;/etc/apt&quot;</span>,<br>                                     <span class="hljs-string">&quot;/Library/MobileSubstrate&quot;</span>,<br>                                     <span class="hljs-string">&quot;/User/Applications/&quot;</span>&#125;; <br>      <br>      <br>+ (BOOL)isJailbroken1&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">if</span>([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:JailbrokenPathArr[i]]])&#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>破解<ul><li>攻击者可以通过hook NSFileManager的fileExistsAtPath方法来绕过检测<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//绕过使用NSFileManager判断特定文件是否存在的越狱检测，此时直接返回NO势必会影响程序中对这个方法的正常使用，因此可以先打印一下path，然后判断如果path是用来判断是否越狱则返回NO，否则按照正常逻辑返回</span><br>%hook NSFileManager<br>- (BOOL)fileExistsAtPath:(NSString *)path&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        NSString *jPath = [NSString stringWithUTF8String:JailbrokenPathArr[i]];<br>        <span class="hljs-keyword">if</span>([path isEqualToString:jPath])&#123;<br>            <span class="hljs-keyword">return</span> NO;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> %orig;<br>&#125;<br>%end<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><hr><h3 id="防护-stat-函数"><a href="#防护-stat-函数" class="headerlink" title="防护 stat 函数"></a>防护 <code>stat</code> 函数</h3><ul><li><p>使用C语言函数stat判断文件是否存在(注:stat函数用于获取对应文件信息，返回0则为获取成功，-1为获取失败)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isJailbroken2&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_info;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">stat</span>(JailbrokenPathArr[i], &amp;stat_info)) &#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;      <br></code></pre></td></tr></table></figure></li><li><p>破解：</p><ul><li>使用fishhook可hook C函数，fishhook通过在mac-o文件中查找并替换函数地址达到hook的目的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*orig_stat)</span><span class="hljs-params">(<span class="hljs-type">char</span> *c, <span class="hljs-keyword">struct</span> stat *s)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hook_stat</span><span class="hljs-params">(<span class="hljs-type">char</span> *c, <span class="hljs-keyword">struct</span> stat *s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-built_in">strcmp</span>(c, JailbrokenPathArr[i]))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">orig_stat</span>(c,s);<br>&#125;<br>+(<span class="hljs-type">void</span>)statHook&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> stat_rebinding = &#123;<span class="hljs-string">&quot;stat&quot;</span>, hook_stat, (<span class="hljs-type">void</span> *)&amp;orig_stat&#125;;<br>    <span class="hljs-built_in">rebind_symbols</span>((<span class="hljs-keyword">struct</span> rebinding[<span class="hljs-number">1</span>])&#123;stat_rebinding&#125;, <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure> 在动态库加载的时候，调用statHook    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"> %ctor&#123;<br>    [StatHook statHook];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>判断stat的来源是否来自于系统库，因为fishhook通过交换函数地址来实现hook，若hook了stat，则stat来源将指向攻击者注入的动态库中 因此我们可以完善上方的isJailbroken2判断规则，若stat来源非系统库，则直接返回已越狱      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isJailbroken2&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-type">int</span> ret ;<br>    Dl_info dylib_info;<br>    <span class="hljs-built_in">int</span> (*func_stat)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-keyword">struct</span> stat *) = stat;<br>    <span class="hljs-keyword">if</span> ((ret = <span class="hljs-built_in">dladdr</span>(func_stat, &amp;dylib_info))) &#123;<br>        NSString *fName = [NSString stringWithUTF8String:dylib_info.dli_fname];<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;fname--%@&quot;</span>,fName);<br>        <span class="hljs-keyword">if</span>(![fName isEqualToString:@<span class="hljs-string">&quot;/usr/lib/system/libsystem_kernel.dylib&quot;</span>])&#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_info;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">stat</span>(JailbrokenPathArr[i], &amp;stat_info)) &#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><hr><hr><hr><h3 id="BundleID检测"><a href="#BundleID检测" class="headerlink" title="BundleID检测"></a>BundleID检测</h3><ul><li>进行BundleID检测可以有效防止多开</li><li>获取当前项目的BundleID有多种方法，此处不再赘述，绕过检测则是hook对应的方法，返回原有的BundleID</li><li>防止攻击者绕过检测，可以在自行link的framework中获取BundleID并进行检测，以在被hook前进行校验<br> BundleID并进行校验以避免常见的BundleID获取方法被hook<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取Boundle ID</span><br><span class="hljs-type">char</span>  * bundleName =  getenv(<span class="hljs-string">&quot;XPC_SERVICE_NAME&quot;</span>);<br>    NSLog(@<span class="hljs-string">&quot;%s&quot;</span>,bundleName);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-夜间模式框架</title>
    <link href="/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>iOS夜间模式的适配，主要用到了<code>NSProxy</code>转发原理 ，其中JYDynamicColor继承于UIColor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColor : UIColor<br><br>@property (nonatomic, readonly) UIColor * lightColor;<br><br>@property (nonatomic, readonly) UIColor * darkColor;<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider;<br><br>@end<br></code></pre></td></tr></table></figure><p>  但是在.m文件中,我们实际将消息给了JYDynamicColorProxy处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYDynamicColor<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor &#123;<br>  return [self colorWithDynamicProvider:^(JYTraitCollection *traitCollection)&#123;<br>    return traitCollection.userInterfaceStyle == JYInterfaceStyleDark ? darkColor : lightColor;<br>  &#125;];<br>&#125;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * _Nonnull (^)(JYTraitCollection * _Nonnull))dynamicProvider &#123;<br>    <br>    return (JYDynamicColor *)[[JYDynamicColorProxy alloc] initWithDynamicProvider:dynamicProvider];<br>&#125;<br><br>- (UIColor *)lightColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>  return nil;<br>&#125;<br><br>- (UIColor *)darkColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>   return nil;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>接着看到<code>JYDynamicColorProxy</code>是继承于<code>NSProxy</code>，将所有的事件都转发到了<code>resolvedColor</code>，而<code>resolvedColor</code>是根据当前模式返回 <code>lightColor</code> 或者 <code>darkColor</code>,这样就实现了，对外其实是一个<code>UIColor</code>，但是实际上是一个<code>JYDynamicColorProxy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColorProxy : NSProxy &lt;NSCopying&gt;<br><br>@property (nonatomic, readonly) UIColor * resolvedColor;<br><br>@property (nonatomic, strong) UIColor *(^dynamicProvider)(JYTraitCollection *);<br><br>@end<br><br><br>@implementation JYDynamicColorProxy<br><br>- (instancetype)initWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider &#123;<br>  self.dynamicProvider = dynamicProvider;<br>  return self;<br>&#125;<br><br>// MARK: NSProxy - 转发消息 将消息全部转发到 resolvedColor<br>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;<br>  return [self.resolvedColor methodSignatureForSelector:sel];<br>&#125;<br><br>- (void)forwardInvocation:(NSInvocation *)invocation &#123;<br>  [invocation invokeWithTarget:self.resolvedColor];<br>&#125;<br><br>- (UIColor *)resolvedColor &#123;<br>  return [self resolvedColorWithTraitCollection:JYTraitCollection.overrideTraitCollection];<br>&#125;<br><br>- (UIColor *)resolvedColorWithTraitCollection:(JYTraitCollection *)traitCollection &#123;<br>    return self.dynamicProvider(traitCollection);<br>&#125;<br><br>// MARK: UIColor<br>- (UIColor *)colorWithAlphaComponent:(CGFloat)alpha &#123;<br>  return [JYDynamicColor colorWithDynamicProvider:^UIColor *(JYTraitCollection *traitCollection) &#123;<br>    return [self.dynamicProvider(traitCollection) colorWithAlphaComponent:alpha];<br>  &#125;];<br>&#125;<br><br>- (CGColorRef)CGColor &#123;<br>  return [[self resolvedColor] CGColor];<br>&#125;<br><br><br>// MARK: NSObject<br>- (BOOL)isKindOfClass:(Class)aClass &#123;<br>  static JYDynamicColor *dynamicColor = nil;<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^&#123;<br>    dynamicColor = [[JYDynamicColor alloc] init];<br>  &#125;);<br>  return [dynamicColor isKindOfClass:aClass];<br>&#125;<br><br>// MARK: NSCopying<br>- (id)copy &#123;<br>  return [self copyWithZone:nil];<br>&#125;<br><br>- (id)copyWithZone:(NSZone *)zone &#123;<br>  return [[JYDynamicColorProxy alloc] initWithDynamicProvider:[self.dynamicProvider copy]];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> iOS13以下，如果需要切换颜色，该如何刷新？<code>JYDynamicColorProxy</code>是如何存储颜色的呢？</p></blockquote><p>我们<code>swizzle</code>将设置颜色方法进行了hook，例如<code>@selector(setBackgroundColor:);</code>方法，将<code>backgroundColor</code>为<code>JYDynamicColor</code>的都进行处理</p><p>这里采用了关联对象的思想，写了一个<code>UIView</code>的分类,将<code>JYDynamicColorProxy</code>进行存储，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">...<br>@property (nullable, readonly) JYDynamicColor *jy_dynamicBackgroundColor;<br>...<br><br>- (JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>    return objc_getAssociatedObject(self, @selector(jy_dynamicBackgroundColor));<br>&#125;<br><br>- (void)setJy_dynamicBackgroundColor:(JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>  objc_setAssociatedObject(self,<br>                           @selector(jy_dynamicBackgroundColor),<br>                           jy_dynamicBackgroundColor,<br>                           OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br></code></pre></td></tr></table></figure><p>当修改当前模式的时候，我们将初始化拿到的<code>UIApplication</code>进行遍历，拿到<code>UIView</code>,然后调用分类当中的修改颜色方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jyTraitCollectionDidChange:(JYTraitCollection *)previousTraitCollection &#123;<br>  if (@available(iOS 13.0, *)) &#123;<br>    return;<br>  &#125;<br>    [self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull view, NSUInteger idx, BOOL * _Nonnull stop) &#123;<br>        [view jyTraitCollectionDidChange:previousTraitCollection];<br>     &#125;];<br>     <br>    [self setNeedsLayout];<br>    [self setNeedsDisplay];<br>#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_13_0<br>    [self jy_updateDynamicColors];<br>#endif<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jy_updateDynamicColors&#123;<br>    JYDynamicColor * backgroundColor = [self jy_dynamicBackgroundColor];<br>    if (backgroundColor) &#123;<br>        [self setBackgroundColor:backgroundColor];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过关联对象取到对应模式的Color,然后赋值即可，图片也是一样的原理</p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-渲染机制</title>
    <link href="/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="CALayer-与-UIView"><a href="#CALayer-与-UIView" class="headerlink" title="CALayer 与 UIView"></a>CALayer 与 UIView</h3><p>UIView拥有一个属性为<code>layer</code>和<code>layerClass</code>属性</p><ul><li><code>layer</code> 属性返回的是 <code>UIView</code> 所持有的主 <code>Layer(RootLayer)</code> 实例，我们可以通过其来设置 <code>UIView</code> 没有封装的一些 <code>layer</code> 属性；</li><li><code>layerClass</code> 则返回 <code>RootLayer</code> 所使用的类，我们可以通过重写该属性，来让 <code>UIView</code> 使用不同的 <code>CALayer</code> 来显示</li></ul><p><code>CALayer</code>继承自<code>NSObject</code>，负责图像渲染</p><p><code>UIView</code>继承自<code>UIResponder</code>，负责事件的响应</p><h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024844.png" alt="image-20190312112603570"></p><p>CPU和GPU通过总线连接，CPU中计算出的往往是<code>bitmap</code>位图，通过总线由合适的时机传递给GPU，GPU拿到位图后，渲染到帧缓存区<code>FrameBuffer</code>,然后由视频控制器根据<code>Vsync</code>信号在指定时间之前去帧缓冲区提取内容，显示到屏幕上。</p><p>CPU工作内容: </p><ol><li>layout（UI布局，文本计算）</li><li>display（绘制 drawRect）</li><li>prepare(图片解码)</li><li>commit（提交位图）</li></ol><p><code>GPU工作内容:</code> 顶点着色，图元装配，光栅化，片段着色，片段处理，最后提交帧缓冲区</p><h3 id="View绘制渲染机制和Runloop什么关系"><a href="#View绘制渲染机制和Runloop什么关系" class="headerlink" title="View绘制渲染机制和Runloop什么关系"></a>View绘制渲染机制和Runloop什么关系</h3><p>例如有以下 <code>UIView</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYView<br>- (void)drawRect:(CGRect)rect &#123;<br>    CGContextRef con = UIGraphicsGetCurrentContext();<br>    CGContextAddEllipseInRect(con, CGRectMake(0,0,100,200));<br>    CGContextSetRGBFillColor(con, 0, 0, 1, 1);<br>    CGContextFillPath(con);<br>&#125;<br>@end<br><br><br>@implementation ViewController<br><br>- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    JYView *view = [[JYView alloc] init];<br>    view.backgroundColor = [UIColor whiteColor];<br>    view.bounds = CGRectMake(0, 0, 100, 100);<br>    view.center = CGPointMake(100, 100);<br>    [self.view addSubview:view];<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>重写了 <code>UIView</code> 的 <code>DrawRect</code>方法.展现在屏幕前经历以下堆栈</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-03-093059.jpg" alt="img"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>当在操作 UI 时，比如改变了<code>Frame</code> 、更新了 <code>UIView/CALayer</code> 的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()<br>QuartzCore:CA::Transaction::observer_callback:<br>CA::Transaction::commit();<br>CA::Context::commit_transaction();<br>CA::Layer::layout_and_display_if_needed();<br>CA::Layer::layout_if_needed();<br>[CALayer layoutSublayers];<br>[UIView layoutSubviews];<br>CA::Layer::display_if_needed();<br>[CALayer display];<br>[UIView drawRect];<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-A4.png" alt="img"></p><h3 id="View布局与约束时机"><a href="#View布局与约束时机" class="headerlink" title="View布局与约束时机"></a>View布局与约束时机</h3><p>一个视图的布局指的是它在屏幕上的的大小和位置。每个 view 都有一个 frame 属性，用来表示在父 view 坐标系中的位置和具体的大小。<code>UIView</code> 给你提供了用来通知系统某个 view 布局发生变化的方法，也提供了在 view 布局重新计算后调用的可重写的方法。</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局:"></a>布局:</h4><p><strong>layoutSubviews()</strong></p><p>它负责给出当前 view 和每个子 view 的位置和大小。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。系统会在任何它需要重新计算视图的 frame 的时候调用这个方法，所以你应该在需要更新 frame 来重新定位或更改大小时重载它。然而你不应该在代码中显式调用这个方法。相反，有许多可以在 run loop 的不同时间点触发 <code>layoutSubviews</code> 调用的机制，这些触发机制比直接调用 <code>layoutSubviews</code> 的资源消耗要小得多。</p><p><strong>自动刷新触发器</strong></p><p>有许多事件会自动给视图打上 “update layout” 标记，因此 <code>layoutSubviews</code> 会在<strong>下一个周期中（重点！！！）</strong>被调用，而不需要开发者手动操作。这些自动通知系统 view 的布局发生变化的方式有：</p><ul><li>修改 view 的大小</li><li>新增 subview</li><li>用户在 <code>UIScrollView</code> 上滚动（<code>layoutSubviews</code> 会在 <code>UIScrollView</code> 和它的父 view 上被调用）</li><li>用户旋转设备</li><li>更新视图的 constraints</li></ul><p>这些方式都会告知系统 view 的位置需要被重新计算，继而会自动转化为一个最终的 <code>layoutSubviews</code> 调用。当然，也有直接触发 <code>layoutSubviews</code> 的方法。</p><p><strong>setNeedsLayout()</strong></p><p>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法。调用这个方法代表向系统表示视图的布局需要重新计算。<code>setNeedsLayout</code> 方法会立刻执行并返回，但在返回前不会真正更新视图。视图会在下一个 update cycle 中更新，就在系统调用视图们的 <code>layoutSubviews</code> 以及他们的所有子视图的 <code>layoutSubviews</code> 方法的时候。</p><p><strong>layoutIfNeeded()</strong></p><p><code>layoutIfNeeded</code> 是另一个会让 <code>UIView</code> 触发 <code>layoutSubviews</code> 的方法。 当视图需要更新的时候，与 <code>setNeedsLayout()</code> 会让视图在下一周期调用 <code>layoutSubviews</code> 更新视图不同，<code>layoutIfNeeded</code> 会立即调用 <code>layoutSubviews</code> 方法。但是如果你调用了 <code>layoutIfNeeded</code> 之后，并且没有任何操作向系统表明需要刷新视图，那么就不会调用 <code>layoutsubview</code>。如果你在同一个 run loop 内调用两次 <code>layoutIfNeeded</code>，并且两次之间没有更新视图，第二个调用同样不会触发 <code>layoutSubviews</code> 方法。</p><p>使用 <code>layoutIfNeeded</code>，则布局和重绘会立即发生并在函数返回之前完成（除非有正在运行中的动画）。这个方法在你需要依赖新布局，无法等到下一次 update cycle 的时候会比 <code>setNeedsLayout</code> 有用</p><p>当对希望通过修改 constraint 进行动画时，这个方法特别有用。你需要在 animation block 之前对 self.view 调用 <code>layoutIfNeeded</code>，以确保在动画开始之前传播所有的布局更新。在 animation block 中设置新 constrait 后，需要再次调用 <code>layoutIfNeeded</code> 来动画到新的状态。</p><p>(<strong>注:</strong> Masonry 动画需要这个)</p><h4 id="显示："><a href="#显示：" class="headerlink" title="显示："></a>显示：</h4><p>一个视图的显示包含了颜色、文本、图片和 Core Graphics 绘制等视图属性，不包括其本身和子视图的大小和位置。和布局的方法类似，显示也有触发更新的方法，它们由系统在检测到更新时被自动调用，或者我们可以手动调用直接刷新。</p><p><strong>setNeedsDisplay()</strong></p><p>这个方法类似于布局中的 <code>setNeedsLayout</code> 。它会给有内容更新的视图设置一个内部的标记，但在视图重绘之前就会返回。然后在下一个 update cycle 中，系统会遍历所有已标标记的视图，并调用它们的 <code>draw</code> 方法。</p><p>大部分时候，在视图中更新任何 UI 组件都会把相应的视图标记为“dirty”，通过设置视图“内部更新标记”，在下一次 update cycle 中就会重绘，而不需要显式的 <code>setNeedsDisplay</code> 调用</p><h4 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h4><p><strong>updateConstraints()</strong></p><p>这个方法用来在自动布局中动态改变视图约束。和布局中的 <code>layoutSubviews()</code> 方法或者显示中的 <code>draw</code> 方法类似，<code>updateConstraints()</code> 只应该被重载，<strong>绝不要在代码中显式地调用</strong>。通常你只应该在 <code>updateConstraints</code> 方法中实现必须要更新的约束。</p><p><strong>setNeedsUpdateConstraints()</strong></p><p>调用 <code>setNeedsUpdateConstraints()</code> 会保证在下一次更新周期中更新约束。它通过标记“update constraints”来触发 <code>updateConstraints()</code>。这个方法和 <code>setNeedsDisplay()</code> 以及 <code>setNeedsLayout()</code> 方法的工作机制类似。</p><p><strong>updateConstraintsIfNeeded()</strong></p><p>对于使用自动布局的视图来说，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 “update constraints”标记（可以被 <code>setNeedsUpdateConstraints</code> 或者 <code>invalidateInstrinsicContentSize</code>方法自动设置）。如果它认为这些约束需要被更新，它会立即触发 <code>updateConstraints()</code> ，<strong>而不会等到 RunLoop 的末尾。</strong></p><h3 id="UI-卡顿-列表卡顿、掉帧原理"><a href="#UI-卡顿-列表卡顿、掉帧原理" class="headerlink" title="UI 卡顿,列表卡顿、掉帧原理"></a>UI 卡顿,列表卡顿、掉帧原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024849.png" alt="image-20190312140156990"></p><p>iOS的 <code>mainRunloop</code>是一个60fps的回调，也就是说每16.7ms(VSync信号时间)会绘制一次屏幕，这个时间段内要完成view的缓冲区创建，view内容的绘制（如果重写了drawRect），这些CPU的工作。然后将这个缓冲区交给GPU渲染，这个过程又包括多个view的拼接(compositing)，纹理的渲染（Texture）等，最终显示在屏幕上。整个过程就是我们上面画的流程图。 因此，如果在16.7ms内完不成这些操作，比如，CPU做了太多的工作，或者view层次过于多，图片过于大，导致GPU压力太大，就会导致“卡”的现象，也就是丢帧.</p><blockquote><p>在规定的16.7ms内，在下一个VSync信号到来之前，CPU和GPU并没有共同完成下一帧视频的合成，就会出现掉帧、卡顿。</p></blockquote><h5 id="滑动优化方案思路："><a href="#滑动优化方案思路：" class="headerlink" title="滑动优化方案思路："></a>滑动优化方案思路：</h5><ul><li>CPU：<ul><li>对象的创建、调整、销毁可以放在子线程中去做ASDK；</li><li>预排班。布局计算、文本计算等事先放到子线程中去做；</li><li>使用轻量级对象，比如CALayer代替UIView</li><li>预渲染。文本等异步绘制，图片编解码等。</li><li>控制并发线程数量</li><li>减少重复计算布局，减少修改frame等</li><li>autolayout比frame更消耗资源</li><li>可以让图片的size跟frame一致</li></ul></li><li>GPU：<ul><li>纹理渲染。避免离屏渲染</li><li>视图混合。减少视图层级的复杂性，减少透明视图；不透明的opaque设置为YES</li><li>GPU能处理的最大纹理是4096 * 4096，一旦超过这个尺寸就会调用CPU进行资源处理，所以纹理尽量不要超过这个尺寸</li></ul></li></ul><h3 id="UIView的绘制原理"><a href="#UIView的绘制原理" class="headerlink" title="UIView的绘制原理"></a>UIView的绘制原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024854.png" alt="image-20190312141642996"></p><p><code>[UIView setNeedsDisplay]</code> 并没有发生当前视图立即绘制工作,打上需要重绘的脏标记，最后是在某个时机完成</p><p><code>[UIView setLayoutIfNeed]</code> 立即重新布局视图(下一个Runloop)</p><p><code>[view layouIfNeeded]</code> 当前RunLoop休眠前更新</p><p>当我们调用UIView的<code>setNeedsDisplay</code>的方法时候，会调用<code>layer</code>的同名方法，相当于在当前<code>layer</code>打上绘制标记，在当前<code>runloop</code>将要结束的时候，才会调用CALayer的<code>display</code>方法进入到真正的绘制当中。</p><p>CALayer的<code>display</code>方法中，首先会判断layer的delegate方法<code>displayLayer：</code>是否实现，如果代理没有响应这个方法，则进入到系统绘制流程；如果代理响应了这个方法，则进入到异步绘制流程</p><h3 id="系统绘制流程"><a href="#系统绘制流程" class="headerlink" title="系统绘制流程"></a>系统绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024857.png" alt="image-20190312142115333"></p><p>在CALayer内部，系统会创建一个backingStore（可以理解为CGContextRef，drawRect中取到的currentRef就是这个东西），然后layer回判断是否有delegate，如果没有代理，就调用CALayer的<code>drawInContext：</code>方法；如果有代理，则调用layer代理的<code>drawLayer:inContext:</code>方法，这一步发生在系统内部，然后在合适的时间给与我们回调一个熟悉的UIView的<code>drawRect：</code>方法。也就是在系统内部的绘制之上，允许我们再做一些额外的绘制。最后CALayer把backting store（位图）传给GPU。</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-07-23-134925.jpg" alt="15420320733034"></p><ol><li>首先一个视图由 CPU 进行 Frame 布局，准备视图和图层的层级关系，查询是否有重写 <code>drawRect:</code> 或 <code>drawLayer:inContext:</code>方法，<strong>注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</strong></li><li>CPU 会将处理视图和图层的层级关系打包，通过 IPC（内部处理通信）通道提交给渲染服务，渲染服务由 OpenGL ES 和 GPU 组成。</li><li>渲染服务首先将图层数据交给 OpenGL ES 进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧缓存的切换。</li><li>最后，将最终要显示在画面上的后帧缓存交给 GPU，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</li></ol><blockquote><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存，即GPU会预先渲染好一帧放入一个缓冲区内（前帧缓存），让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器（后帧缓存）。当你视频控制器已经读完一帧，准备读下一帧的时候，GPU会等待显示器的VSync信号发出后，前帧缓存和后帧缓存会瞬间切换，后帧缓存会变成新的前帧缓存，同时旧的前帧缓存会变成新的后帧缓存。</p></blockquote><h3 id="异步绘制流程"><a href="#异步绘制流程" class="headerlink" title="异步绘制流程"></a>异步绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024902.png" alt="image-20190312142425272"></p><p>layer的delegate如果实现了<code>displayLayer:</code>方法，就会进入到异步绘制的流程。在异步绘制的过程中，需要代理来生成对应的bitmap位图文件，并把此bitmap作为layer的contents属性</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024910.png" alt="image-20190312142514299"></p><h3 id="drawRect方法内为何第一行代码总要获取图形的上下文"><a href="#drawRect方法内为何第一行代码总要获取图形的上下文" class="headerlink" title="drawRect方法内为何第一行代码总要获取图形的上下文"></a>drawRect方法内为何第一行代码总要获取图形的上下文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">CGContextRef con = UIGraphicsGetCurrentContext();<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-082448.jpg" alt="img"></p><p>每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store 当UIView被绘制时（从 CA::Transaction::commit:以后），CPU执行drawRect，通过context将数据写入backing store 当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上 所以在 drawRect 方法中 要首先获取 context</p><h3 id="为什么要将图像渲染和事件响应这两个功能分开？"><a href="#为什么要将图像渲染和事件响应这两个功能分开？" class="headerlink" title="为什么要将图像渲染和事件响应这两个功能分开？"></a>为什么要将图像渲染和事件响应这两个功能分开？</h3><p>因为<code>CALayer</code>属于<code>QuartzCore</code>框架，<code>UIView</code>属于<code>UIKit</code>框架，</p><p><code>QuartzCore</code> 框架是可以跨平台使用的，但是<code>UIKit</code>框架只能在iOS中，在MacOs当中触摸是鼠标键盘，而iOS是触摸事件，遵循设计原则中的单一职责。</p><h3 id="CALayer为什么可以呈现可视化内容呢？"><a href="#CALayer为什么可以呈现可视化内容呢？" class="headerlink" title="CALayer为什么可以呈现可视化内容呢？"></a>CALayer为什么可以呈现可视化内容呢？</h3><p>CALayer包含一个<code>contents</code>属性,<code>CALayer</code> 中的 <code>contents</code> 属性保存了由设备渲染流水线渲染好的位图 <code>bitmap</code>（通常也被称为 <code>backing store</code>），而当设备屏幕进行刷新时，会从 <code>CALayer</code> 中读取生成好的 <code>bitmap</code>，进而呈现到屏幕上。CALayer的<code>contents</code>的值必须是<code>CGImage</code>。</p><h3 id="例如添加一个View-其底层做了什么操作？"><a href="#例如添加一个View-其底层做了什么操作？" class="headerlink" title="例如添加一个View,其底层做了什么操作？"></a>例如添加一个View,其底层做了什么操作？</h3><p><code>Core Animation</code> 会在APP启动时像 <code>Runloop</code> 注册一个 <code>Observer</code>，当事件到来的时候，<code>Runloop</code> 会被唤醒处理相关的业务逻辑（UIView 的创建，修改），将UI信息提交给<code>Render Server</code>,然后会等待<code>VSync</code>信号的到来，然后会通过<code>Metal</code>或者<code>OpenGLES</code>做一些绘制操作，然后把处理完的数据，纹理，顶点，着色器等提交给<code>GPU</code>，在下一个<code>VSync</code>信号到来的时候，视频控制器等读取帧缓冲区的数据显示到屏幕上。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><h3 id="界面掉帧是因为什么引起的？"><a href="#界面掉帧是因为什么引起的？" class="headerlink" title="界面掉帧是因为什么引起的？"></a>界面掉帧是因为什么引起的？</h3><p>掉帧是因为当在一个<code>Vsync</code>周期中，<code>CPU</code>或者<code>GPU</code>没有完成内容提交，那么这一帧就会被废弃掉，等待下一个<code>Vsync</code>的到来，而显示屏还会保持之前的内容不变，这也是界面卡顿的原因。</p><h3 id="CoreAnimation渲染流程？"><a href="#CoreAnimation渲染流程？" class="headerlink" title="CoreAnimation渲染流程？"></a>CoreAnimation渲染流程？</h3><p>首先收到事件的处理，例如布局改变</p><p>通过CPU完成显示内容计算，对APP图层进行打包，在下一次runloop时将描述好的 UI 信息以 <code>IPC</code> 的形式提供给<strong>系统常驻的 UI 绘制进程</strong>渲染服务RenderServer, </p><p>将收到的打包进行解码，执行metal相关程序，调用GPU</p><p>GPU完成对图像的渲染，最后显示到屏幕上</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzj6f3n9o3j20xc0hq406.jpg"></p><p><strong>但是如果重写了 <code>drawRect:</code> 方法，这个方法会直接调用 <code>Core Graphics</code> 绘制方法得到 <code>bitmap</code> 数据，同时系统会额外申请一块内存，用于暂存绘制好的 <code>bitmap</code>。</strong></p><p>由于重写了 <code>drawRect:</code> 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。</p><h3 id="离屏渲染指的是什么？"><a href="#离屏渲染指的是什么？" class="headerlink" title="离屏渲染指的是什么？"></a>离屏渲染指的是什么？</h3><p>我们知道<code>GPU</code>会将渲染完成后的结果放入<code>Frame Buffer</code>当中，但是如果<code>GPU</code>无法一次完成渲染工作，需要两，这时就需要一个额外的载体来保存第一次的结果，而这个载体也就是离屏渲染缓冲区。</p><p>离屏渲染会创建新的缓冲区，增加额外的空间，大量的离屏渲染可能造成内存的过大压力。</p><p>离屏渲染的过程中，会进行两次上下文的切换，先切换到屏幕外，离屏渲染完成后再切回当前屏幕。</p><h3 id="所有的离屏渲染都是坏的吗？"><a href="#所有的离屏渲染都是坏的吗？" class="headerlink" title="所有的离屏渲染都是坏的吗？"></a>所有的离屏渲染都是坏的吗？</h3><p>我们可以利用开启<code>CALayer</code>的<code>shouldRasterize</code>属性去触发离屏渲染。开启之后，<code>Render Server</code> 会强制将 <code>CALayer 的渲染位图结果</code>bitmap&#96; 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。</p><p>保存的 <code>bitmap</code> 包含 <code>layer</code> 的 <code>subLayer</code>、圆角、阴影、组透明度 <code>group opacity</code> 等，所以如果 <code>layer</code> 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。<strong>其主旨在于降低性能损失，但总是至少会触发一次离屏渲染。</strong></p><blockquote><p>圆角、阴影、组透明度等会由系统自动触发离屏渲染，那么打开光栅化就可以节约第二次及以后的渲染时间。而多层 subLayer 的情况由于不会自动触发离屏渲染，所以相比之下会多花费第一次离屏渲染的时间，但是可以节约后续的重复渲染的开销。</p></blockquote><h3 id="哪些情况会触发离屏渲染？"><a href="#哪些情况会触发离屏渲染？" class="headerlink" title="哪些情况会触发离屏渲染？"></a>哪些情况会触发离屏渲染？</h3><ul><li>使用了 <code>mask</code> 的 <code>layer (layer.mask)</code>；</li><li>添加了投影的<code> layer (layer.shadow*，表示相关的 shadow 开头的属性)</code></li><li>设置了组透明度为 YES，并且透明度不为 1 的<code>layer (layer.allowsGroupOpacity/layer.opacity)</code></li><li>采用了光栅化的 <code>layer (layer.shouldRasterize)</code></li><li>绘制了文字的 <code>layer (UILabel, CATextLayer, Core Text 等)</code></li><li>需要进行裁剪的<code> layer (layer.masksToBounds / view.clipsToBounds)</code></li></ul><p>总结一下，iOS 9 之后圆角造成离屏渲染的条件包括：</p><ul><li>圆角</li><li>裁剪</li><li><code>layer</code> 的<code>contents</code>不为 <code>nil</code></li><li>设置了背景色 &#x2F; 边框 &#x2F; 其他有图像内容的图层</li></ul><h3 id="知识点问题梳理"><a href="#知识点问题梳理" class="headerlink" title="知识点问题梳理"></a>知识点问题梳理</h3><ul><li><p>图像显示的原理</p></li><li><p>layoutSubviews()&#x2F;setNeedsLayout()&#x2F;layoutIfNeeded()三者之间的区别？</p></li><li><p>setNeedsDisplay()有什么作用？</p></li><li><p>界面掉帧是因为什么引起的？</p></li><li><p>离屏渲染是什么?所有的离屏渲染都是坏的吗？哪些情况会触发离屏渲染？</p></li><li><p>异步绘制的流程</p></li><li><p>drawRect方法在什么时候调用？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-Runloop</title>
    <link href="/2021/03/01/iOS-Runloop/"/>
    <url>/2021/03/01/iOS-Runloop/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><ul><li>Run loops是线程相关的的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比 如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</li></ul><h3 id="runloop和线程的关系"><a href="#runloop和线程的关系" class="headerlink" title="runloop和线程的关系"></a>runloop和线程的关系</h3><ul><li>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。</li><li>子线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。</li><li>子线程中，RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。</li><li>你只能在一个线程的内部获取其 RunLoop（主线程除外）。</li></ul><h3 id="runloop的接口"><a href="#runloop的接口" class="headerlink" title="runloop的接口"></a>runloop的接口</h3><ul><li>CFRunLoopRef<ul><li>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source&#x2F;Timer&#x2F;Observer，让其互不影响</li></ul></li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef<ul><li>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。<ul><li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li><li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li></ul></li></ul></li><li>CFRunLoopTimerRef<ul><li>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</li></ul></li><li>CFRunLoopObserverRef<ul><li>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</li></ul></li></ul><h3 id="runloop的mode"><a href="#runloop的mode" class="headerlink" title="runloop的mode"></a>runloop的mode</h3><ul><li>kCFRunLoopDefaultMode&#x2F;NSDefaultRunLoopMode<ul><li>App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li></ul></li><li>UITrackingRunLoopMode<ul><li>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li></ul></li><li>UIInitializationRunLoopMode<ul><li>在刚启动App时第进入的第一个Mode，启动完成后就不再使用</li></ul></li><li>GSEventReceiveRunLoopMode<ul><li>接受系统事件的内部Mode，通常用不到</li></ul></li><li>kCFRunLoopCommonModes&#x2F;NSRunLoopCommonModes<ul><li>组合状态，这是一个占位的 Mode，没有实际作用。</li></ul></li></ul><h3 id="runloop内部逻辑"><a href="#runloop内部逻辑" class="headerlink" title="runloop内部逻辑"></a>runloop内部逻辑</h3><p><img src="http://blog.qiji.tech/wp-content/uploads/2016/04/RunLoop_1.png" alt="image"></p><ul><li>1、通知Observer：即将进入Loop</li><li>2、通知Observer：将要处理Timer</li><li>3、通知Observer：将要处理Source0</li><li>4、处理Source0</li><li>5、如果有Source1，跳到第9步</li><li>6、通知Observer：线程即将休眠</li><li>7、休眠，等待唤醒</li><li>8、通知Observer：线程刚被唤醒</li><li>9、处理唤醒时收到的消息，之后跳回2</li><li>10、通知Observer：即将退出Loop</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs scss">&#123;<br>    <span class="hljs-comment">/// 1. 通知Observers，即将进入RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopEntry);<br>    do &#123;<br> <br>        <span class="hljs-comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeTimers);<br>        <span class="hljs-comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeSources);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 4. 触发 Source0 (非基于port的) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>(source0);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 6. 通知Observers，即将进入休眠</span><br>        <span class="hljs-comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeWaiting);<br> <br>        <span class="hljs-comment">/// 7. sleep to wait msg.</span><br>        <span class="hljs-built_in">mach_msg</span>() -&gt; <span class="hljs-built_in">mach_msg_trap</span>();<br>        <br> <br>        <span class="hljs-comment">/// 8. 通知Observers，线程被唤醒</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopAfterWaiting);<br> <br>        <span class="hljs-comment">/// 9. 如果是被Timer唤醒的，回调Timer</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>(timer);<br> <br>        <span class="hljs-comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(dispatched_block);<br> <br>        <span class="hljs-comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>(source1);<br> <br> <br>    &#125; while (...);<br> <br>    <span class="hljs-comment">/// 10. 通知Observers，即将退出RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopExit);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><h3 id="runloop什么时候退出"><a href="#runloop什么时候退出" class="headerlink" title="runloop什么时候退出"></a>runloop什么时候退出</h3><ul><li>1、超过设定的超时</li><li>2、当前runloop中没有需要处理的timer、source</li><li>3、接收到exit信号</li></ul><h2 id="runloop在系统中的应用"><a href="#runloop在系统中的应用" class="headerlink" title="runloop在系统中的应用"></a>runloop在系统中的应用</h2><h3 id="1、AutoreleasePool"><a href="#1、AutoreleasePool" class="headerlink" title="1、AutoreleasePool"></a>1、AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="2、事件响应"><a href="#2、事件响应" class="headerlink" title="2、事件响应"></a>2、事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code></p><p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 <code>mach port</code> 转发给需要的App进程。随后苹果在APP内注册的 Source1 就会触发回调，并调用<code>_UIApplicationHandleEventQueue() </code>进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent </code>处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 <code>UIButton 点击、touchesBegin/Move/End/Cancel </code>事件都是在这个回调中完成的。</p><h3 id="3、手势识别"><a href="#3、手势识别" class="headerlink" title="3、手势识别"></a>3、手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue() </code>识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。</p><p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p><h3 id="4、界面更新"><a href="#4、界面更新" class="headerlink" title="4、界面更新"></a>4、界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h3 id="5、定时器"><a href="#5、定时器" class="headerlink" title="5、定时器"></a>5、定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="6、PerformSelecter"><a href="#6、PerformSelecter" class="headerlink" title="6、PerformSelecter"></a>6、PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="7、网络请求（现在的NSURLSession是否借助了runloop？）"><a href="#7、网络请求（现在的NSURLSession是否借助了runloop？）" class="headerlink" title="7、网络请求（现在的NSURLSession是否借助了runloop？）"></a>7、网络请求（现在的NSURLSession是否借助了runloop？）</h3><p>NSURLConnection 的工作过程也借助了runloop。使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="image"></p><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="你用runloop实现了什么"><a href="#你用runloop实现了什么" class="headerlink" title="你用runloop实现了什么"></a>你用runloop实现了什么</h2><h3 id="使用runloop开启一个常驻子线程"><a href="#使用runloop开启一个常驻子线程" class="headerlink" title="使用runloop开启一个常驻子线程"></a>使用runloop开启一个常驻子线程</h3><ul><li>AFNetworking2开启子线程，在后台线程接收 Delegate 回调  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">+ (<span class="hljs-type">void</span>)networkRequestThreadEntryPoint:(id)__unused object &#123;<br> <br>     @autoreleasepool &#123;<br>       [[NSThread currentThread] setName:@<span class="hljs-string">&quot;AFNetworking&quot;</span>];<br>       NSRunLoop *runLoop = [NSRunLoop currentRunLoop];<br>       [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>       [runLoop run];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>线上实时卡顿监控<ul><li>NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources（3. 通知 Observers: 即将触发 Source0回调）和kCFRunLoopBeforeWaiting（6. 通知Observers，即将进入休眠）之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿</li><li><a href="https://www.jianshu.com/p/890d1ba05f4c">iOS线上实时卡顿监控</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-动态库与静态库的区别</title>
    <link href="/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="静态库-Static-Library"><a href="#静态库-Static-Library" class="headerlink" title="静态库 (Static Library)"></a>静态库 (Static Library)</h3><ul><li><p>分发文件大</p></li><li><p>静态库默认仅将有用到的类文件<code>link</code>到<code>Mach-O</code>中(已类文件为最小链接单位)</p></li><li><p>ipa包小(为了APP瘦身，尽量将代码放静态库中) </p><ul><li>静态库中某个目标文件的代码没有被任何地方引用，则这个目标文件不会被链接到可执行文件中去(前提是不要使用<code>-Objc</code>和<code>-all_load</code>选项，分类代码经常被优化掉，一般都使用<code>-force_load</code>来处理静态库分类加载问题)</li></ul></li><li><p>APP冷启动速度快</p><ul><li>前提是不使用<code>动态库拆分</code>搭配<code>动态库懒加载方案</code></li><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个静态库只需要<code>rebase</code>和<code>bind</code>一次</li></ul></li><li><p>存在符号冲突可能</p></li><li><p>共享<code>TEXT段</code></p><ul><li>iOS9以前单个Mach-O的TEXT限制60M</li><li>iOS9以后单个Mach-O的TEXT限制500M</li></ul></li><li><p>不需要额外签名验证  </p></li><li><p>静态库符号的可见性可以在链接期间被修改 </p></li><li><p>文件格式多为<code>fat</code>格式的静态库文件</p></li><li><p>形式多为<code>.a</code>与<code>.framework</code></p></li><li><p>静态库不含<code>bitcode</code>时，引用静态库的目标部署时就不能包含<code>bitcode</code></p></li></ul><h3 id="动态库-Dynamic-Library"><a href="#动态库-Dynamic-Library" class="headerlink" title="动态库 (Dynamic Library)"></a>动态库 (Dynamic Library)</h3><ul><li><p>分发文件小</p></li><li><p>ipa包大  （前提是不考虑懒加载的情况）</p><ul><li>动态库会把整个<code>lib</code>复制进<code>ipa</code>中</li></ul></li><li><p>APP冷启动速度慢</p><ul><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个动态库只需要多次<code>rebase</code>和<code>bind</code></li></ul></li><li><p>需要设置合适的<code>runpath</code> </p></li><li><p>需要动态加载</p></li><li><p>需要签名且需要验证签名</p><ul><li>会检查<code>framework</code>的签名，签名中必须包含<code>TeamIdentifier</code>,并且<code>framework</code>和host APP的<code>TeamIdentifier</code>必须一致</li><li>Xcode重签命，保证动态库签名一致性</li></ul></li><li><p>需要导出符号</p></li><li><p>重复的<code>arch</code>结构</p></li><li><p>APP与动态库中重复代码可以共存，不会发生符号冲突</p><ul><li>因为可执行文件在构建链接阶段，遇到静态库则吸附进来，遇到动态库则打个标记，彼此保持独立性</li><li>对于来自动态库的符号，编译器会打个标记，交给<code>dyld</code>去加载和链接符号，也就是把链接的过程推迟到了运行时执行。（比如APP使用的是3.0版本SDK，动态库使用的是1.0版本SDK，能正常运行，但是会有风险）</li></ul></li><li><p>链接后需要包含分发大小</p></li><li><p>冷启动过程中，默认会在<code>main</code>函数之前加载</p><ul><li>默认情况下，过多的动态库会拖慢冷启动速度</li><li>如果采用懒加载动态库的形式，能够加快APP的启动速度,可以使用<code>dlopen</code>和<code>bundle</code>懒加载优化</li></ul></li><li><p>文件格式<code>Mach-O</code>（一个没有<code>main</code>函数的可执行文件）</p></li><li><p>动态库不包含<code>bitcode</code>时，引用动态库的目标部署时可以包含<code>bitcode</code></p></li><li><p><code>CocoaPods</code>从<code>v0.36.0</code>开始，可添加关键字<code>use_frameworks!</code>编译成类似<code>Embedded Framework</code>的结构（可以称之为<code>umbrella framework</code>）</p><ul><li>缺点：默认把项目的依赖全部改为动态库（可是使用<code>use_modular_headers!</code>,也可以在<code>podsepc</code>添加<code>s.static_framework = true</code>规避）</li><li><code>CocoaPods</code>执行脚本把动态库嵌入到<code>.app</code>的<code>Framework</code>目录下（相当于在<code>Embedded Binaries</code>加入动态库）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="简述OSI七层协议"><a href="#简述OSI七层协议" class="headerlink" title="简述OSI七层协议"></a>简述OSI七层协议</h3><ul><li>OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层</li></ul><hr><hr><h3 id="简述TCP-x2F-IP五层协议"><a href="#简述TCP-x2F-IP五层协议" class="headerlink" title="简述TCP&#x2F;IP五层协议"></a>简述TCP&#x2F;IP五层协议</h3><ul><li>TCP&#x2F;IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层</li></ul><hr><hr><h3 id="物理层有什么作用"><a href="#物理层有什么作用" class="headerlink" title="物理层有什么作用"></a>物理层有什么作用</h3><ul><li>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</li></ul><hr><hr><h3 id="数据链路层有什么作用"><a href="#数据链路层有什么作用" class="headerlink" title="数据链路层有什么作用"></a>数据链路层有什么作用</h3><ul><li>在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</li></ul><hr><hr><h3 id="网络层有什么作用"><a href="#网络层有什么作用" class="headerlink" title="网络层有什么作用"></a>网络层有什么作用</h3><ul><li>将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。</li></ul><hr><hr><h3 id="传输层有什么作用"><a href="#传输层有什么作用" class="headerlink" title="传输层有什么作用"></a>传输层有什么作用</h3><ul><li>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</li></ul><hr><hr><h3 id="会话层有什么作用"><a href="#会话层有什么作用" class="headerlink" title="会话层有什么作用"></a>会话层有什么作用</h3><ul><li>建立会话：身份验证，权限鉴定等；保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局；断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。</li></ul><hr><hr><h3 id="表示层有什么作用"><a href="#表示层有什么作用" class="headerlink" title="表示层有什么作用"></a>表示层有什么作用</h3><ul><li>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</li></ul><hr><hr><h3 id="应用层有什么作用"><a href="#应用层有什么作用" class="headerlink" title="应用层有什么作用"></a>应用层有什么作用</h3><ul><li>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。</li></ul><hr><hr><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><ul><li>TCP作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信 </li><li></li><li>UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播</li></ul><hr><hr><h3 id="为何TCP可靠"><a href="#为何TCP可靠" class="headerlink" title="为何TCP可靠"></a>为何TCP可靠</h3><ul><li>TCP有三次握手建立连接，四次挥手关闭连接的机制。除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。对于每份报文也存在校验，保证每份报文可靠性。</li></ul><hr><hr><h3 id="为何UDP不可靠"><a href="#为何UDP不可靠" class="headerlink" title="为何UDP不可靠"></a>为何UDP不可靠</h3><ul><li>UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。仅仅在IP数据报头部加入校验和复用。UDP没有服务器和客户端的概念。UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。</li></ul><hr><hr><h3 id="简述TCP粘包现象"><a href="#简述TCP粘包现象" class="headerlink" title="简述TCP粘包现象"></a>简述TCP粘包现象</h3><ul><li>TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。</li></ul><h3 id="TCP粘包现象处理方法"><a href="#TCP粘包现象处理方法" class="headerlink" title="TCP粘包现象处理方法"></a>TCP粘包现象处理方法</h3><ul><li>固定发送信息长度，或在两个信息之间加入分隔符。</li></ul><hr><hr><h3 id="简述TCP协议的滑动窗口"><a href="#简述TCP协议的滑动窗口" class="headerlink" title="简述TCP协议的滑动窗口"></a>简述TCP协议的滑动窗口</h3><ul><li>滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。</li></ul><h3 id="简述TCP协议的拥塞控制"><a href="#简述TCP协议的拥塞控制" class="headerlink" title="简述TCP协议的拥塞控制"></a>简述TCP协议的拥塞控制</h3><ul><li><p>拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.</p></li><li><p>当cwnd &lt; ssthresh 时，使用慢开始算法。当cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当cwnd &#x3D; ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。</p></li><li><p>慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。</p></li><li><p>拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。</p></li><li><p>快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。</p></li><li><p>快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。</p></li></ul><hr><hr><h3 id="简述快重传"><a href="#简述快重传" class="headerlink" title="简述快重传"></a>简述快重传</h3><ul><li>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。</li></ul><hr><hr><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><ul><li>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq&#x3D;x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。</li><li>第二次握手:服务端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack&#x3D;x+1,随机产生一个值seq&#x3D;y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</li><li>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack&#x3D;y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了</li></ul><hr><hr><h3 id="简述半连接队列"><a href="#简述半连接队列" class="headerlink" title="简述半连接队列"></a>简述半连接队列</h3><ul><li>TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</li></ul><hr><hr><h3 id="简述SYN攻击"><a href="#简述SYN攻击" class="headerlink" title="简述SYN攻击"></a>简述SYN攻击</h3><ul><li>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</li></ul><h4 id="优化方式："><a href="#优化方式：" class="headerlink" title="优化方式："></a>优化方式：</h4><ul><li>缩短SYN Timeout时间<br>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li></ul><hr><hr><h3 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h3><ul><li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。</li><li>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li><li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</li><li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</li></ul><hr><hr><h3 id="为什么TCP挥手需要4次"><a href="#为什么TCP挥手需要4次" class="headerlink" title="为什么TCP挥手需要4次"></a>为什么TCP挥手需要4次</h3><ul><li><p>主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。</p></li><li><p>所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。</p></li></ul><h3 id="为什么四次挥手释放连接时需要等待2MSL"><a href="#为什么四次挥手释放连接时需要等待2MSL" class="headerlink" title="为什么四次挥手释放连接时需要等待2MSL"></a>为什么四次挥手释放连接时需要等待2MSL</h3><ul><li>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</li></ul><hr><hr><h3 id="简述DNS协议"><a href="#简述DNS协议" class="headerlink" title="简述DNS协议"></a>简述DNS协议</h3><ul><li>DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</li></ul><h3 id="简述DNS解析过程"><a href="#简述DNS解析过程" class="headerlink" title="简述DNS解析过程"></a>简述DNS解析过程</h3><ol><li><p>客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器</p></li><li><p>本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找</p></li><li><p>本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器</p></li><li><p>根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址</p></li><li><p>客户机的dns服务器根据返回的信息接着访问下一级的dns服务器</p></li><li><p>这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息</p></li><li><p>客户机的本地的dns服务器会将查询结果返回给我们的客户机</p></li><li><p>客户机根据得到的ip信息访问目标主机，完成解析过程</p></li></ol><hr><hr><h3 id="简述HTTP协议"><a href="#简述HTTP协议" class="headerlink" title="简述HTTP协议"></a>简述HTTP协议</h3><ul><li>http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。</li></ul><hr><hr><h3 id="简述cookie"><a href="#简述cookie" class="headerlink" title="简述cookie"></a>简述cookie</h3><ul><li><p>HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p></li><li><p>Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。</p></li></ul><hr><hr><h3 id="简述session"><a href="#简述session" class="headerlink" title="简述session"></a>简述session</h3><ul><li>session用于标记特定客户端信息，存在在服务器的一个文件里。一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。</li></ul><h3 id="简述http状态码和对应的信息"><a href="#简述http状态码和对应的信息" class="headerlink" title="简述http状态码和对应的信息"></a>简述http状态码和对应的信息</h3><ul><li><p>1XX：接收的信息正在处理</p></li><li><p>2XX：请求正常处理完毕</p></li><li><p>3XX：重定向</p></li><li><p>4XX：客户端错误</p></li><li><p>5XX：服务端错误</p></li><li><p>常见错误码：301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到</p></li><li><p>转发和重定向的区别<br>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p></li><li><p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p></li></ul><hr><hr><ul><li><p>简述http1.0<br>规定了请求头和请求尾，响应头和响应尾（get post）</p></li><li><p>每一个请求都是一个单独的连接，做不到连接的复用</p></li></ul><hr><hr><h3 id="简述http1-1的改进"><a href="#简述http1-1的改进" class="headerlink" title="简述http1.1的改进"></a>简述http1.1的改进</h3><ul><li><p>HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</p></li><li><p>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p></li><li><p>服务端无法主动push</p></li></ul><hr><hr><h3 id="简述HTTP短连接与长连接区别"><a href="#简述HTTP短连接与长连接区别" class="headerlink" title="简述HTTP短连接与长连接区别"></a>简述HTTP短连接与长连接区别</h3><p>HTTP中的长连接短连接指HTTP底层TCP的连接。</p><ul><li><p>短连接：客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。</p></li><li><p>长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。</p></li></ul><hr><hr><h3 id="简述http2-0的改进"><a href="#简述http2-0的改进" class="headerlink" title="简述http2.0的改进"></a>简述http2.0的改进</h3><ul><li><p>提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。</p></li><li><p>引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。</p></li></ul><h3 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h3><ul><li>http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。</li></ul><hr><hr><h3 id="简述TLS-x2F-SSL-HTTP-HTTPS的关系"><a href="#简述TLS-x2F-SSL-HTTP-HTTPS的关系" class="headerlink" title="简述TLS&#x2F;SSL, HTTP, HTTPS的关系"></a>简述TLS&#x2F;SSL, HTTP, HTTPS的关系</h3><ul><li><p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。</p></li><li><p>可以将HTTPS协议简单理解为HTTP协议＋TLS&#x2F;SSL</p></li></ul><hr><hr><h3 id="https的连接过程"><a href="#https的连接过程" class="headerlink" title="https的连接过程"></a>https的连接过程</h3><ul><li><p>浏览器将支持的加密算法信息发给服务器<br>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器<br>客户端(SSL&#x2F;TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。<br>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器<br>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。<br>服务器将加密后的密文发送给客户端<br>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成<br>Get与Post区别<br>Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。</p></li><li><p>Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。</p></li><li><p>Get方法参数有大小限制吗<br>一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。</p></li></ul><h3 id="了解REST-API吗"><a href="#了解REST-API吗" class="headerlink" title="了解REST API吗"></a>了解REST API吗</h3><ul><li><p>REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：</p></li><li><p>Create ：POST<br>Read ：GET<br>Update ：PUT&#x2F;PATCH<br>Delete：DELETE<br>浏览器中输入一个网址后，具体发生了什么<br>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址<br>通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接<br>浏览器生成HTTP报文，发送HTTP请求，等待服务器响应<br>服务器处理请求，并返回给浏览器<br>根据HTTP是否开启长连接，进行TCP的挥手过程<br>浏览器根据收到的静态资源进行页面渲染</p></li></ul><hr><hr><h3 id="HTTPS相关"><a href="#HTTPS相关" class="headerlink" title="HTTPS相关"></a>HTTPS相关</h3><p>1）HTTPS 结合使用了 非对称加密算法，对称加密算法，hash算法，分别利用他们的优势，避免他们的缺点。利用非对称加密算法获得对称加密算法的秘钥，保证他的安全性；然后实际的网页内容的加密使用的是对称加密算法，利用了对称加密算法速度快的优势，hash算法主要是防止篡改的发生，是一种校验机制，最后数字证书，保证了服务器在将非对称加密算法的公钥传给浏览器时的安全性(不会被中间人篡改)，同时也标志了服务器的身份。</p><p>2）HTTPS的四大金刚：</p><p>非对称加密算法(对称加密算法的秘钥) + 对称加密算法(加密内容) + 数字证书(防止篡改非对称加密算法的公钥) + HASH算法(防止篡改消息)&#x3D;&#x3D; HTTPS</p><p>3）HTTPS的本质是什么？</p><p>HTTPS的本质就是在HTTP连接发起之前，先使用SSL&#x2F;TLS协议，协调客户端和服务端，在两端各自生产一个对称加密算法的秘钥，</p><p>然后使用普通的HTTP协议传输 经过对称加密算法加密的网页内容。因为对称加密算法的秘钥是安全的，所以对称加密算法加密的网页内容也是安全的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-同步方案（锁）</title>
    <link href="/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/"/>
    <url>/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>近期要写一个多线程工具，把之前学习的多线程，以及线程同步复习一下 </p><p>多线程的本质：有多条线程，但是只能执行一条，如果间隔时间设置的足够小，就给人的感觉是多条线程是同时进行的，时间片轮转调度算法</p><p>iOS中线程同步方案</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>Dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h4 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock - 自旋锁"></a>OSSpinLock - 自旋锁</h4><p> 等待锁🔐的线程会处于忙等状态，一直占用CPU资源</p><p>会出现优先级翻转的问题，如果线程之间的优先级不同，如果低优先级的锁先进来，把锁锁住，那么高优先级的线程进来就会一直忙等，但是系统又会分配时间资源给线程高的，从而导致低优先级的线程无法执行完自己的代码，从而导致优先级低的锁无法释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_SPINLOCK_INIT;<br>   <br>- (void)saleTicket&#123;<br>    /// 加锁<br>  OSSpinLockLock(&amp;_lock);<br>  //BOOL isLock =  OSSpinLockTry(&amp;_lock); <br>  int oldTicketsCount = self.ticketsCount;<br>  sleep(.2);<br>  oldTicketsCount--;<br>  self.ticketsCount = oldTicketsCount;<br>  NSLog(@&quot;还剩下%d张票 = %@&quot;,self.ticketsCount,[NSThread currentThread]);<br>  /// 解锁<br>  OSSpinLockUnlock(&amp;_lock);<br>&#125;<br>   <br></code></pre></td></tr></table></figure><hr><h4 id="os-unfair-lock-iOS10后支持-（本质是互斥锁）"><a href="#os-unfair-lock-iOS10后支持-（本质是互斥锁）" class="headerlink" title="os_unfair_lock - iOS10后支持 （本质是互斥锁）"></a>os_unfair_lock - iOS10后支持 （本质是互斥锁）</h4><p>用于替代<code>OSSpinLock</code> 的锁，使用的技术不再是忙等，而是休眠等待唤醒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_UNFAIR_LOCK_INIT;<br>- (void)saleTicket&#123;   <br>    /// 加锁<br>    os_unfair_lock_lock(&amp;_lock);<br>//  BOOL isLock = os_unfair_lock_trylock(&amp;lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    os_unfair_lock_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><p><code>mutex</code> 叫做”互斥锁”，等待锁的线程会处于休眠状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化属性    <br>pthread_mutexattr_t attr;<br>pthread_mutexattr_init(&amp;attr);<br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);<br>/// 初始化锁<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>//销毁属性 pthread_mutexattr_destroy(&amp;attr);<br>//销毁锁   pthread_mutex_destroy(&amp;_lock);<br><br>- (void)saleTicket&#123; <br>    /// 加锁<br>    pthread_mutex_lock(&amp;_lock);<br>    ///尝试 加锁<br>    //BOOL islock = pthread_mutex_trylock(&amp;_lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/*<br> * Mutex type attributes<br> */<br>#define PTHREAD_MUTEX_NORMAL0  //普通状态锁<br>#define PTHREAD_MUTEX_ERRORCHECK1<br>#define PTHREAD_MUTEX_RECURSIVE2  //用于处理递归锁<br>#define PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL<br><br></code></pre></td></tr></table></figure><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>递归锁：允许同一个线程对一把锁重复加锁</p><p>线程一 : 调用<code>saleTicket</code> (+🔐)</p><ul><li>调用<code>saleTicket</code> (+🔐)</li><li>调用<code>saleTicket</code> (+🔐)</li></ul><p> 线程二：调用<code>saleTicket</code> (发现已经被加锁了，等待) </p><p>当锁中间的代码遇到递归调用，打印的结果永远只有一条<code>saleTicket</code>，因为没有人能够走到解锁的那一步。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">- (void)saleTicket&#123;<br>    <span class="hljs-comment">/// 加锁</span><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;_lock);<br>    <span class="hljs-comment">///尝试 加锁</span><br>    <span class="hljs-comment">//BOOL islock = pthread_mutex_trylock(&amp;_lock);</span><br>    <span class="hljs-built_in">NSLog</span>(@&quot;%s&quot;,__func__);<br>    <span class="hljs-comment">// 卖票 递归调用</span><br>    <span class="hljs-selector-attr">[self saleTicket]</span>;<br>    <span class="hljs-comment">/// 解锁</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;_lock);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p> <code>pthread</code>是支持递归锁的，只需要把初始化属性改为递归锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxupqijd8nj30c205igme.jpg"></p><h5 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, assign) pthread_cond_t cond;<br><br>/// 初始化条件<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>// 销毁条件<br>pthread_cond_destroy(&amp;_cond);<br><br>[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil]start];<br>[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil]start];<br><br>- (void)__remove&#123;<br>   <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    if (self.dataArray.count == 0) &#123;<br>        //一旦进入等待状态，就会放开这把锁，直到别人发送信号唤醒<br>        pthread_cond_wait(&amp;_cond, &amp;_lock);<br>    &#125;<br>    [self.dataArray removeLastObject];<br>    NSLog(@&quot;删除了元素&quot;);<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br><br>- (void)__add&#123;<br>    <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    [self.dataArray addObject:@&quot;123&quot;];<br>    NSLog(@&quot;添加了元素&quot;);<br>     <br>    pthread_cond_signal(&amp;_cond);<br>    pthread_mutex_unlock(&amp;_lock);<br>    // 这里需要保证pthread_cond_signal在pthread_mutex_unlock之前<br>    // 如果在之后的话，锁解开了，发送信号的这个过程中有可能被别的锁抢先进来了<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h4 id="NSLock-x2F-NSRecursiveLock-x2F-NSCondition"><a href="#NSLock-x2F-NSRecursiveLock-x2F-NSCondition" class="headerlink" title="NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition"></a>NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition</h4><ul><li><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p></li><li><p><code>NSRecursiveLock</code> 是对<code>mutex</code>递归锁的封装</p></li><li><p><code>NSCondition</code> 是对<code>mutex</code>和<code>cont</code>的封装</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@protocol NSLocking<br><br>- (void)lock;<br>- (void)unlock;<br><br>@end<br><br>@interface NSLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (BOOL)tryLock; // 尝试加锁<br>- (BOOL)lockBeforeDate:(NSDate *)limit; //在这个时间之前等不到这个锁，都会睡眠<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br>@end<br></code></pre></td></tr></table></figure><p>可以查看GNUStep看到<code>NSLock</code>的实现</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxusubtzxlj30js0b8400.jpg"></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;<br><br>@property (readonly) NSInteger condition;<br>- (void)lockWhenCondition:(NSInteger)condition;<br>- (BOOL)tryLock;<br>- (BOOL)tryLockWhenCondition:(NSInteger)condition;<br>- (void)unlockWithCondition:(NSInteger)condition;<br>- (BOOL)lockBeforeDate:(NSDate *)limit;<br>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br><br>@end<br></code></pre></td></tr></table></figure><hr><h4 id="Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列"><a href="#Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列" class="headerlink" title="Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列"></a>Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列</h4><ul><li>串行队列，也可以实现线程同步，保证了每一条线程的操作都是按顺序的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">  @property (nonatomic, strong) dispatch_queue_t  queen;<br>  <br>  self.queen =  dispatch_queue_create(&quot;123&quot;, DISPATCH_QUEUE_SERIAL);<br>  <br>  - (void)test&#123;<br>    self.ticketsCount = 20;<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore - 信号量"></a>dispatch_semaphore - 信号量</h4><ul><li>信号量的初始值，可以用来控制线程的并发访问的最大数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, strong) dispatch_semaphore_t semaphore;<br>  // 设置最大并发数     <br> self.semaphore = dispatch_semaphore_create(1);<br>      <br>  for (int i = 0; i&lt;20; i++) &#123;<br>     [[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];<br>  &#125;<br>  <br>- (void)test&#123;    <br>    // 如果信号量的值&gt;0,就让信号量减1，然后继续执行下面的代码<br>    // 直到信号量的值&lt;=0的时候，就会休眠等待<br>    // DISPATCH_TIME_FOREVER永远 或者 设置成 DISPATCH_TIME_NOW现在立即<br>    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);<br>    self.ticketsCount--;<br>    sleep(2);<br>    NSLog(@&quot;剩下的票为 %d&quot;,self.ticketsCount);<br>    //让信号量的值+1<br>    dispatch_semaphore_signal(self.semaphore);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><ul><li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@synchronized (self) &#123; //objc_sync_enter<br>&#125; // objc_sync_exit<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">int objc_sync_enter(id obj)<br>&#123;<br>    int result = OBJC_SYNC_SUCCESS;<br><br>    if (obj) &#123;<br>        SyncData* data = id2data(obj, ACQUIRE);<br>        ASSERT(data);<br>        data-&gt;mutex.lock();<br>    &#125; else &#123;<br>        // @synchronized(nil) does nothing<br>        if (DebugNilSync) &#123;<br>            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);<br>        &#125;<br>        objc_sync_nil();<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>id2data</code> 方法内部</p><p>![image-20211229175537934](&#x2F;Users&#x2F;karthrine&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211229175537934.png)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxuusl6m2wj30cm01z74g.jpg"></p><p>内部是一个哈希表，把<code>obj</code>当做<code>key</code> ，<code>data-&gt;mutex.lock();</code> 拿到唯一的mutex锁，来加锁</p><hr><h4 id="自旋锁和互斥锁对比"><a href="#自旋锁和互斥锁对比" class="headerlink" title="自旋锁和互斥锁对比"></a>自旋锁和互斥锁对比</h4><p>什么情况下使用自旋锁比较划算？</p><ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发送</li><li>CPU资源不紧张</li><li>多核处理器</li></ul><p>什么情况下使用互斥锁比较划算？</p><ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
