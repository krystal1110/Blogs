<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS-系统C函数的hook</title>
    <link href="/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/"/>
    <url>/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/</url>
    
    <content type="html"><![CDATA[<h3 id="fishhook方案"><a href="#fishhook方案" class="headerlink" title="fishhook方案"></a>fishhook方案</h3><p>通过解析<code>bind</code>、<code>lazy_bind</code>、<code>weak_bind</code>可以获取到元组列表，每个元组会告诉我们符号和指针信息，指针信息包括指针位于哪个段以及在段的偏移</p><p>在iOS中，我们使用用变量或类似<code>NSLog()</code>等外部函数并不是直接调用地址，而是在经过bind 或 lazy_bind后才能得到真正的地址。bind或lazy_bind后真正的函数地址记录在 <code>nl_symbol_ptr</code> 或 <code>la_symbol_ptr</code>中，通过符号表可以找到每个函数对应在<code>nl_symbol_ptr</code>或<code>la_symbol_ptr</code>中的地址。fishhook 就是通过查找符号表，找到记录函数指针的地址修改函数指针从而实现C函数的hook。</p><p>bind是在加载镜像的时候就就已经绑定，而lazy_bind是在首次使用时才触发绑定。</p><blockquote><p> lazy_bind是如何实现在首次调用函数时进行bind的呢？</p></blockquote><p>假设张三和李四是同学，老师手里有个名单，这个名单上记录着要参加值日的同学。本来今天应该是李四值日，但是由于打印名单时教务处老师不知道李四的名字，因此打印了班长张三的名字。老师只认名单，因此老师找来张三打扫卫生。但是张三只做了一件事情，就是把名单上的名字改成了李四，并且叫李四来打扫卫生。这样老师以后如果再吩咐打扫卫生的事情时就直接找到了李四。这就是lazy_bind。故事中老师就是我们写的代码，代码只认地址。名单就是<code>la_symbol_ptr</code>，上面记录了值日同学名。张三就是stub机制，它只是起到了辅助作用。而李四则是真正的外部函数，需要真正执行的函数。</p><h3 id="动态库C函数hook"><a href="#动态库C函数hook" class="headerlink" title="动态库C函数hook"></a>动态库C函数hook</h3><p>除了<code>fishhook</code>外，笔者也有一种C函数的静态hook方式，相比于<code>fishhook</code>，此方案不存在耗时的查找比对操作。下面我将介绍这种比较特殊的方案：基于动态库的C函数hook </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dv8sqwtvj20xc0fjmyr.jpg"></p><p><strong>Step1</strong>: 首先在主工程中定义一个同名同参同返回的函数，这样在<code>ld64</code>链接时会认为<code>func1</code>和<code>func2</code> 中用到的<code>NSLog</code>是我们自定义的函数，这样就不会跟系统库的函数进行匹配，<code>NSLog</code>也就不会被标记为需要<code>bind</code>的函数。</p><p><strong>Step2</strong>: 在我们自定义的<code>NSLog</code>内部，我们调用自定义动态库的中间函数<code>MyNSLog</code>，这一步是为了能够调用到真正的<code>NSLog</code></p><p><strong>Step3</strong>: 由于动态库中我们没有自定义<code>NSLog</code>去“欺骗”ld64，因此动态中的<code>NSLog</code>会去调用真正的系统函数。</p><p>到这里可能有同学会问，“难道动态库的<code>NSLog</code>不存在重新调用到主程序的<code>NSLog</code>函数的风险吗？那样岂不是会死循环？”</p><p>不会的。因为动态库是具备编译和链接过程的产物。经过链接时，在二进制文件中就已经写定了<code>NSLog</code>  <code>bind</code>到系统库中的<code>NSLog</code>了，因此在启动阶段<code>dyld</code>不会“违抗”二进制的命令执行到主程序的<code>NSLog</code>。</p><p>但是由于侵入性较强，仅对部分需要<strong>同步启动</strong>用到的函数使用。<code>fishhook</code> 还是项目中最主要的使用方式。</p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</title>
    <link href="/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <url>/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化"><a href="#dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化" class="headerlink" title="dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化"></a>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</h3><p>dyld 是动态加载器，它主要用于动态库的链接和程序启动加载工作，它目前有两个主要版本：dyld 2 和 dyld 3。</p><p><strong>dyld 2</strong></p><p><a href="https://github.com/opensource-apple/dyld/tree/master/src" title="dyld开源地址">dyld2</a> 从 iOS 3.1 开始引入，一直到 iOS 12 被 dyld 3 全面代替。它经过了很多次版本迭代，我们现在常见的特性比如 ASLR，Code Sign，Shared Cache 等技术，都是在 dyld 2 中引入的。dyld 2 的执行流程是这样的：</p><p><img src="http://cdn.zhangferry.com/Images/20220104235847.png"></p><ul><li>解析 <code>mach-o</code> 头文件，找到依赖库，依赖库又可能有别的依赖，这里会进行递归分析，直到获得所有 dylib 的完整图。这里数据庞大，需要进行大量的处理；</li><li>映射所有 <code>mach-o</code> 文件，将它们放入地址空间；</li><li>执行符号查找，若你的程序使用 <code>printf</code> 函数，将会查找 <code>printf</code> 是否在库系统中，然后我们找到它的地址，将它复制到你的程序中的函数指针上；</li><li>进行 bind 和 rebase，修复内部和外部指针；</li><li>运行一些初始化任务，像是加载 category、load 方法等；</li><li>执行 main；</li></ul><p><strong>dyld 3</strong></p><p>dyld 3 在 2017 年就被引入至 iOS 11，当时主要用来优化系统库。现在，在 iOS 13 中它也将用于启动第三方 APP，完全替代 dyld 2。</p><p>dyld 3 最大的特点就是引入了启动闭包，闭包里包含了启动所需要的缓存信息，而且这个闭包在进程外就完成了。在打开 APP 时，实际上已经有不少工作都完成了，这会使 dyld 的执行更快。</p><p>最重要的特性就是启动闭包，闭包里包含了启动所需要的缓存信息，从而提高启动速度。下图是 dyld 2 和 dyld 3 的执行步骤对比：</p><p><img src="http://cdn.zhangferry.com/Images/20220105001119.png"></p><p>dyld 3 的执行步骤分两大步，以图中虚线隔开，虚线以上进程外执行，以下进程创建时执行：</p><ul><li>前 3 步查找依赖和符号相对耗时，且涉及一些安全问题，所以将这些信息做成缓存闭包写入磁盘里，对应地址：<code>tmp/com.apple.dyld</code>。闭包会在重启手机&#x2F;更新&#x2F;下载 App 的首启等时机创建。</li><li>进程启动时，读取闭包并验证闭包有效性。</li><li>后面步骤同 dyld 2</li></ul><h3 id="iOS-15-的LC-DYLD-CHAINED-FIXUPS"><a href="#iOS-15-的LC-DYLD-CHAINED-FIXUPS" class="headerlink" title="iOS 15 的LC_DYLD_CHAINED_FIXUPS"></a>iOS 15 的LC_DYLD_CHAINED_FIXUPS</h3><p>在iOS15 上，APP的<code>rebase</code> &amp; <code>bind</code> 的方式发生了变化。</p><p>如果我们将<code>iOS Deployment Target</code>设置为15的话，通过<code>MachOView</code>查看打包后的Mach-O文件会发现新的二进制上出现了不支持的LC。</p><p><img src="https://upload-images.jianshu.io/upload_images/4642217-76d3f18e9cc92b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/830/format/webp" alt="img"></p><p>这是由于<code>LC_DYLD_INFO_ONLY</code>被替换成了新增的<code>LC_DYLD_EXPORTS_TRIE</code>和<code>LC_DYLD_CHAINED_FIXUPS</code>。</p><p>文件的变化意味着iOS 15的<code>rebase</code>和<code>bind</code>机制发生了变化。回顾iOS 14及以前，<code>dyld</code>是通过解析压缩字节流实现了<code>rebase</code>和<code>bind</code>。解析压缩字节会告诉<code>dyld</code> 整个二进制文件中有哪些地址需要修正，以及在<code>bind</code>时每个地址是为哪个外部符号预留。那iOS 15 <code>dyld</code>是如何进行过修正的呢？接下来我们探索下<code>dyld</code>。</p><p> 前段时间听到有同学讨论iOS 15 <code>dyld3</code> 更新为<code>dyld4</code>了。笔者无法确定苹果是否偷偷地升级了<code>dyld</code>，但是从蛛丝马迹中可以看出来<code>dyld</code> 确实是有变化，例如在<code>instrument</code> 中我们可以看到部分函数的命名空间变成了<code>dyld4</code>。还有就是一些API的调用上发生了一些变化，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">let header:UnsafePointer<span class="hljs-tag">&lt;<span class="hljs-name">mach_header</span>&gt;</span> = _dyld_get_image_header(0)<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在iOS 15系统之前通过索引获取<code>header</code>时，如果<code>index == 0</code>，返回的是可执行程序的<code>header</code>。但是在iOS 15中，<code>index == 0</code>获取到的却是系统库。当然这些变化对我们的业务代码可能还不足以产生影响，但是可以说明<code>dyld</code> 确定是有改动。那<code>LC_DYLD_CHAINED_FIXUPS</code>是<code>dyld</code>的新特性吗？我的答案是否定的。因为从<code>dyld3</code>的<code>dyld-852.2</code>版本中可以看到<code>LC_DYLD_CHAINED_FIXUPS</code>早就预埋在dyld中了，只不过在<code>iOS Deployment Target == 15</code>时引起Mach-O文件变化后，才能进入相应的代码分支。</p><h3 id="iOS15上如何让你的应用启动更快？"><a href="#iOS15上如何让你的应用启动更快？" class="headerlink" title="iOS15上如何让你的应用启动更快？"></a>iOS15上如何让你的应用启动更快？</h3><p>在iOS 15中，原本用于rebase &amp; bind 的压缩字节流被替换，取而代之的是fixup-chains(链表结构)。在iOS 启动时，dyld 先判断是否存在fixup-chains，如果存在fixup-chains 则按照fixup-chains的方式进行解析，否则还是按照压缩字节流的方式解析。解析的目的是为了将应用程序的地址进行修正。fixup-chains 机制是由三层结构进行存储，分别是segment（段）-&gt; pages(页) -&gt; fixup-chains(指针链表) 组成。LC_DYLD_CHAINED_FIXUPS所指向的数据会告诉我们有多少segments，每个segment的信息又会告诉我们这个segment有多少pages，以及每个page 的fixup-chains在哪里。 而 fixup-chains中的指针指向了当前page中每一个需要rebase 或者 bind的地址，这些地址中存储的数据并非像iOS 15之前那样都是0x00，而是有一定格式的具有一定意义的8字节数据。而这短短的8字节数据被按照不同的结构体拆分成多个bit，每个或连续几个bit都具有其特殊的含义用于推断rebase 或 bind 所需要的一切信息。iOS 15废除了lazy_bind(weak_bind仍然保留)，由于rebase和bind 被整合为一个链表，因此遍历一次链表即可完成一个page所需的rebase和bind。</p><p><strong>那fixup-chains为什么能加快启动呢？</strong></p><p>因为在iOS 15以前，rebase和bind的信息在压缩字节流中是分别存储的。这就意味着，在启动时dyld在做rebase时会先遍历一遍rebase压缩字节流所记录的地址进行地址修改，假设为N次page fault，由于经过rebase 的page 是被写入数据的dirty page，因此不会被释放，iOS 会通过压缩的方式优化最近没有使用到的dirty page。然后在进行bind时，又遍历bind压缩字节流所记录的那些地址进行修改，假设需要bind M个page。那么在N和M这两个Pages集合中可能存在很多重叠，这就造成了二次遍历，并且iOS可能对其中某些dirty page做了压缩优化。在这种情况下，bind时就需要对这些重叠的pages做解压操作。而fixup-chains很巧妙地解决了这个问题，因为同一个page的rebase和bind整合成一个链表，同时进行这两种操作，这样就不会存在重复遍历相同的page，也不会存在解压的问题。</p><p><strong>疑问</strong></p><p>fixup-chains 会减少page falut次数吗？：不会，依旧是<code>M</code> ∪<code>N</code></p><p>有人问这个算不算iOS 帮我们做了二进制重排？：完全是两回事。虽然都提到了page fault，但是阶段是不同的。</p><p><a href="https://easeapi.com/blog/blog/83-ios13-dyld3.html" title="iOS 13中dyld 3的改进和优化">iOS 13中dyld 3的改进和优化</a></p><p><a href="https://www.yotrolz.com/posts/c2aae680/" title="iOS dyld 前世今生">iOS dyld 前世今生</a></p><p><a href="https://www.jianshu.com/p/6ff72443377b">从野指针探测到对iOS 15 bind 的探索</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift-weak的实现</title>
    <link href="/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在Swift中, <code>SideTable</code> 是针对有需要的对象而创建，系统会为目标对象分配一块新的内存来保存该对象额外的信息。 因为这不是对象必须的内容，所以这个 <code>SideTable</code> 可有可无。对象会有一个指向 <code>SideTable</code> 的指针，同时 <code>SideTable</code> 也有一个指回原对象的指针。在实现上为了不额外多占用内存，目前只有在创建弱引用时，会先把对象的引用计数放到新创建的 <code>SideTable</code> 去，再把空出来的空间存放 <code>SideTable</code> 的地址，会通过一个标志位来区分对象是否有 <code>SideTable</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JYObject</span>&#123;<br>    <span class="hljs-keyword">var</span> age :<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;JY&quot;</span><br>&#125;<br> <br>  <span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">JYObject</span>()<br>    <br>  <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> t2 <span class="hljs-operator">=</span> t<br>    <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们在<code>print</code>处打上断点，查看t2对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">(lldb) po t2<br>▿ Optional&lt;JYObject&gt;<br>  ▿ some : &lt;JYObject: <span class="hljs-number">0x6000001a9710</span>&gt;<br><br>(lldb) x/<span class="hljs-number">8</span>gx  <span class="hljs-number">0x6000001a9710</span><br><span class="hljs-number">0x6000001a9710</span>: <span class="hljs-number">0x0000000100491e18</span> <span class="hljs-number">0xc0000c00001f03dc</span><br><span class="hljs-number">0x6000001a9720</span>: <span class="hljs-number">0x0000000000000012</span> <span class="hljs-number">0x000000000000594a</span><br><span class="hljs-number">0x6000001a9730</span>: <span class="hljs-number">0xe200000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000001a9740</span>: <span class="hljs-number">0x00007efd22b59740</span> <span class="hljs-number">0x000000000000009c</span><br>(lldb) <br></code></pre></td></tr></table></figure><p>通过查看汇编，定义了一个<code>weak</code>变量，编译器自动调用了<code>swift_weakInit</code>函数，这个函数是由<code>WeakReference</code>调用的。说明<code>weak</code>字段在编译器声明的过程当中自动生成了<code>WeakReference</code>对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">WeakReference *<span class="hljs-title">swift::swift_weakInit</span><span class="hljs-params">(WeakReference *ref, HeapObject *value)</span> </span>&#123;<br>  ref-&gt;<span class="hljs-built_in">nativeInit</span>(value);<br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">(HeapObject *object)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = object ? object-&gt;refCounts.formWeakReference() : <span class="hljs-literal">nullptr</span>;<br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">WeakReferenceBits</span>(side), std::memory_order_relaxed);<br>  &#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::formWeakReference()<br>&#123;<br>    <span class="hljs-comment">// 创建一个 Side Table</span><br>  <span class="hljs-keyword">auto</span> side = <span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (side)<br>      <span class="hljs-comment">// 增加一个弱引用</span><br>    <span class="hljs-keyword">return</span> side-&gt;<span class="hljs-built_in">incrementWeak</span>();<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 我们来看一下<code>allocateSideTable</code>方法，是如何创建一个<code>Side Table</code>的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::<span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-type">bool</span> failIfDeiniting)<br>&#123;<br>  <span class="hljs-comment">//1.拿到原有的引用计数</span><br>  <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>  <br>  <span class="hljs-comment">// 判断是否有SideTable，</span><br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>    <span class="hljs-comment">// Already have a side table. Return it.</span><br>    <span class="hljs-keyword">return</span> oldbits.<span class="hljs-built_in">getSideTable</span>();<br>  &#125; <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>    <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Preflight passed. Allocate a side table.</span><br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> custom side table allocator</span><br> <br>  <span class="hljs-comment">//2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象</span><br>  HeapObjectSideTableEntry *side = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HeapObjectSideTableEntry</span>(<span class="hljs-built_in">getHeapObject</span>());<br> <br>  <span class="hljs-comment">//3.将创建的实例对象地址给了InlineRefCountBits，也就是 RefCountBitsT</span><br>  <span class="hljs-keyword">auto</span> newbits = <span class="hljs-built_in">InlineRefCountBits</span>(side);<br>  <br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>      <span class="hljs-comment">// Already have a side table. Return it and delete ours.</span><br>      <span class="hljs-comment">// Read before delete to streamline barriers.</span><br>      <span class="hljs-keyword">auto</span> result = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>      <span class="hljs-keyword">delete</span> side;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>      <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>     <br>    <span class="hljs-comment">// 将原有的引用计数存储</span><br>    side-&gt;<span class="hljs-built_in">initRefCounts</span>(oldbits);<br>     <br>  &#125; <span class="hljs-keyword">while</span> (! refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                             std::memory_order_release,<br>                                             std::memory_order_relaxed));<br>  <span class="hljs-keyword">return</span> side;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结一下上面所做的事情</p><p>1.拿到原有的引用计数<br>2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象<br>3.将创建的实例对象地址给了<code>InlineRefCountBits</code>，也就是 RefCountBitsT。</p></blockquote><p>构造完 <code>Side Table</code> 以后，对象中的 <code>RefCountBitsT</code> 就不是原来的引用计数了，而是一个指向 <code>Side Table</code> 的指针，然而由于它们实际都是 <code>uint64_t</code>，因此需要一个方法来区分。区分的方法我们可以来看 <code>InlineRefCountBits</code> 的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//弱引用</span><br><span class="hljs-function">LLVM_ATTRIBUTE_ALWAYS_INLINE</span><br><span class="hljs-function">  <span class="hljs-title">RefCountBitsT</span><span class="hljs-params">(HeapObjectSideTableEntry* side)</span></span><br><span class="hljs-function">    : bits((reinterpret_cast&lt;BitsType&gt;(side) &gt;&gt; Offsets::SideTableUnusedLowBits)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::UseSlowRCShift)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::SideTableMarkShift))</span><br><span class="hljs-function">  &#123;</span><br>    <span class="hljs-built_in">assert</span>(refcountIsInline);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在弱引用方法中把创建出来的地址做了偏移操作然后存放到了内存当中。</p><p><code>SideTableUnusedLowBits</code> &#x3D; 3，所以，在这个过程中，传进来的<code>side</code>往右移了 3 位，下面的两个是 62 位和 63 位标记成 1</p></blockquote><p>我们接着来看一下 <code>HeapObjectSideTableEntry</code> 的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapObjectSideTableEntry</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> does object need to be atomic?</span><br>  std::atomic&lt;HeapObject*&gt; object;<br>  SideTableRefCounts refCounts;<br><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HeapObjectSideTableEntry</span>(HeapObject *newObject)<br>    : <span class="hljs-built_in">object</span>(newObject), <span class="hljs-built_in">refCounts</span>()<br>  &#123; &#125;<br></code></pre></td></tr></table></figure><p>我们来尝试还原一下 拿到弱引用计数 </p><p><code>0xc0000c00001f03dc</code>62位和63位清0得到 <code>HeapObjectSideTableEntry</code> 实例对象的地址<code>0xC00001F03DC</code></p><p>它既然是右移 3 位，那么我左移 3 位把它还原，<code>HeapObjectSideTableEntry</code>左移三位 得到<code>0x10062AFE0</code></p><p><img src="https://gitee.com/zhangferry/Images/raw/master/iOSWeeklyLearning/20220302155825.png"></p><ul><li><code>0x6000001a9710</code> 就是实例对象的地址。</li><li><code>0x0000000000000002</code>就是弱引用计数。<br>这里弱引用为<code>2</code>的原因是因为<code>SideTableRefCountBits</code>初始化的时候从<code>1</code>开始.</li></ul><p> <code>Side Table</code>的生命周期与对象是分离的，当强引用计数为 0 时，只有 <code>HeapObject</code> 被释放了，并没有释放<code>Side Table</code>，只有所有的 <code>weak</code> 引用者都被释放了或相关变量被置 <code>nil</code> 后，<code>Side Table</code> 才能得以释放</p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-编译过程梳理</title>
    <link href="/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-编译过程梳理"><a href="#iOS-编译过程梳理" class="headerlink" title="iOS 编译过程梳理"></a>iOS 编译过程梳理</h1><p>编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率很高。</p><h2 id="编译器的概述"><a href="#编译器的概述" class="headerlink" title="编译器的概述"></a>编译器的概述</h2><p>编译器的作用是把我们的高级语言转换成机器可以识别的机器码，经典的设计结构如下：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dwrp77ruj20ki03z0sn.jpg"></p><ul><li>前端（Frontend）：语法分析，语义分析和生成中间代码。在这个过程中，也会对代码进行检查，如果发现出错的或需要警告的会标注出来。</li><li>优化器（Optimizer）：会进行 BitCode 的生成，链接期优化等工作。</li><li>后端（Backend）：针对不同的架构，生成对应的机器码。</li></ul><h2 id="Clang-LLVM-的编译过程"><a href="#Clang-LLVM-的编译过程" class="headerlink" title="Clang + LLVM 的编译过程"></a>Clang + LLVM 的编译过程</h2><ol><li><strong>预处理阶段</strong>：import 头文件替换；macro 宏展开；处理预编译指令</li><li><strong>词法分析</strong>：预处理完成后进入词法分析，将输入的代码转化为一系列符合特定语言的词法单元（token 流）。</li><li><strong>语法分析</strong>：将词法分析得到的 token 流进行语法静态分析（Static Analysis），输出<strong>抽象语法树（AST）</strong>，过程中会校验语法是否错误。</li><li><strong>CodeGen 生成 IR 中间代码</strong>：CodeGen 负责将语法树自顶向下遍历翻译成 <code>LLVM IR</code>，<code>IR</code> 是编译过程中前端的输出后端的输入。</li><li><strong>Optimize 优化 IR</strong>：到这里 LLVM 会做一些优化工作，在 Xcode 的编译设置里可以设置优化级别 -01, -03, -0s，也可以写自己的 Pass，Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。附件：<a href="http://llvm.org/docs/WritingAnLLVMPass.html">官方 Pass 教程</a>。</li><li><strong>LLVM Bitcode 生成字节码</strong>：如果开启了 bitcode，苹果会做进一步优化。若有新的后端架构，依旧可以用这份优化过的 bitcode 去生成。</li><li><strong>生成汇编</strong></li><li><strong>生成目标文件</strong></li><li><strong>生成可执行文件</strong></li></ol><h2 id="Xcode-Build-的流程"><a href="#Xcode-Build-的流程" class="headerlink" title="Xcode Build 的流程"></a>Xcode Build 的流程</h2><p>我们在 Xcode 中使用 <strong>Command + B</strong> 或 <strong>Command + R</strong> 时，即完成了一次编译，来看下这个过程做了哪些事情。</p><p>编译过程分为四个步骤：</p><ul><li>预编译（Pre-process）：宏替换、删除注释、展开头文件，产生 .i 文件。</li><li>编译（Compliling）：把前面生成的 .i 文件转化为汇编语言，产生 .s 文件。</li><li>汇编（Asembly）：把汇编语言 .s 文件转化为机器码文件，产生 .0 文件。</li><li>链接（Link）：对 .o 文件中的对于其他库的引用的地方进行引用，生成最后的可执行文件。也包括多个 .o 文件进行 link。</li></ul><p>通过解析 Xcode 编译 log，可以发现 Xcode 是根据 Target 进行编译的。我们可以通过 Xcode 中的 Build Phases、Build Settings 及 Build Rules 来控制编译过程。</p><ul><li>Build Settings：这一栏下是对编译的细节进行设定，包含 build 过程的每个阶段的设置选项（包含编译、链接、代码签名、打包）。</li><li>Build Phases：用于控制从源文件到可执行文件的整个过程，如编译哪些文件，编译过程中执行哪些自定义脚本。例如 CocoaPods 在这里会进行相关配置。</li><li>Build Rules：指定了不同的文件类型该如何编译。一般我们不需要修改这里的内容。如果需要对特定类型的文件添加处理方法，可以在这里添加规则。</li></ul><p>每个 Target 的具体编译过程也可以通过 log 日志获得。大致过程为：</p><ul><li>编译信息写入辅助文件（如Entitlements.plist），创建编译后的文件架构</li><li>写入辅助信息（.hmap 文件）。将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件。</li><li>运行预设的脚本。如 Cocoapods 会在 Build Phases 中预设一些脚本（CheckPods Manifest.lock）。</li><li>编译 .m 文件，生成可执行文件 Mach-O。每次进行了 LLVM 的完整流程：前端（词法分析 - 语法分析 - 生成 IR）、优化器（优化 IR）、后端（生成汇编 - 生成目标文件 - 生成可执行文件）。使用 <code>CompileC</code> 和 <code>clang</code> 命令。 CompileC 是 xcodebuild 内部函数的日志记录表示形式，它是 build.log 文件中有关编译的基本信息来源。</li><li>链接需要的库。如 Foundation.framework，AFNetworking.framework…</li><li>拷贝资源文件到目标包</li><li>编译 storyboard 文件</li><li>链接 storyboard 文件</li><li>编译 Asset 文件。如果使用 Asset.xcassets 来管理图片，这些图片会被编译为机器码，除了 icon 和 launchIamge。</li><li>处理 infoplist</li><li>执行 CocoaPods 脚本，将在编译项目前已编译好的依赖库和相关资源拷贝到包中。</li><li>拷贝 Swift 标准库</li><li>创建 .app 文件并对其签名</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-线程数量监控</title>
    <link href="/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/"/>
    <url>/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<p>在iOS开发中，我们会经常开辟新的线程去做一些事，如何合理的开辟线程，在App开发阶段，监控线程的开辟数量，避免线上发生意外情况。 </p><p>当线程过多或瞬间创建大量子线程(线程爆炸)，就在控制台打印信息，并记录信息。</p><ol><li><p>创建子线程过多，是会造成性能问题的，因为创建线程需要占用内存空间（默认的情况下，主线程占1M,子线程占用512KB）。</p></li><li><p>不合理创建和使用线程，容易引发数据一致性（线程安全）和死锁问题。</p></li></ol><p>因为在iOS中基本上都是使用的<code>p_thread</code>，在<code>Mach</code>层中<code>thread_basic_info</code> 结构体封装了单个线程的基本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">struct thread_basic_info &#123;<br>    time_value_t  user_time;      /* user run time */<br>    time_value_t  system_time;    /* system run time */<br>    integer_t    cpu_usage;       /* scaled cpu usage percentage */<br>    policy_t     policy;          /* scheduling policy in effect */<br>    integer_t    run_state;       /* run state (see below) */<br>    integer_t    flags;           /* various flags (see below) */<br>    integer_t    suspend_count;   /* suspend count for thread */<br>    integer_t    sleep_time;      /* number of seconds that thread  has been sleeping */<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<code>Mach Task</code>包含它的线程列表。内核提供了<code>task_threads</code> API 调用获取指定 task 的线程列表，然后可以通过<code>thread_info</code> API调用来查询指定线程的信息，在 thread_act.h 中有相关定义。</p><p><code>task_threads</code> 将<code>target_task</code> 任务中的所有线程保存在<code>act_list</code>数组中，act_listCnt表示线程个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">kern_return_t task_threads<br>(<br>    task_t target_task,<br>    thread_act_array_t *act_list,<br>    mach_msg_type_number_t *act_listCnt<br>);<br></code></pre></td></tr></table></figure><p> <code>thread_info</code>结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">kern_return_t</span> <span class="hljs-title">thread_info</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_act_t</span> target_act,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_flavor_t</span> flavor,  <span class="hljs-comment">// 传入不同的宏定义获取不同的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_info_t</span> thread_info_out,  <span class="hljs-comment">// 查询到的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">mach_msg_type_number_t</span> *thread_info_outCnt  <span class="hljs-comment">// 信息的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p> 如果频繁调用<code>task_threads</code>函数，来获取线程数量和增长速度，大量调用这个函数会造成一定的性能问题</p><p>通过<code>hook</code>线程的创建和销毁，来监听线程的数量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//在#include &lt;pthread/introspection.h&gt;文件里</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">定义函数指针：pthread_introspection_hook_t</span><br><span class="hljs-comment">event  : 线程处于的生命周期（下面枚举了线程的4个生命周期）</span><br><span class="hljs-comment">thread ：线程</span><br><span class="hljs-comment">addr   ：线程栈内存基址</span><br><span class="hljs-comment">size   ：线程栈内存可用大小</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">pthread_introspection_hook_t</span>)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> event,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-keyword">enum</span> &#123;<br>PTHREAD_INTROSPECTION_THREAD_CREATE = <span class="hljs-number">1</span>, <span class="hljs-comment">//创建线程</span><br>PTHREAD_INTROSPECTION_THREAD_START, <span class="hljs-comment">// 线程开始运行</span><br>PTHREAD_INTROSPECTION_THREAD_TERMINATE,  <span class="hljs-comment">//线程运行终止</span><br>PTHREAD_INTROSPECTION_THREAD_DESTROY, <span class="hljs-comment">//销毁线程</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">看这个函数名，很像我们平时hook函数一样的。</span><br><span class="hljs-comment">返回值是上面声明的pthread_introspection_hook_t函数指针：返回原线程生命周期函数。</span><br><span class="hljs-comment">参数也是函数指针：传入的是我们自定义的线程生命周期函数</span><br><span class="hljs-comment">*/</span><br>__attribute__((__nonnull__, __warn_unused_result__))<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">pthread_introspection_hook_t</span></span><br><span class="hljs-function"><span class="hljs-title">pthread_introspection_hook_install</span><span class="hljs-params">(<span class="hljs-type">pthread_introspection_hook_t</span> hook)</span></span>;<br><br></code></pre></td></tr></table></figure><h4 id="下面开始写一个Monitor"><a href="#下面开始写一个Monitor" class="headerlink" title="下面开始写一个Monitor"></a>下面开始写一个<code>Monitor</code></h4><p>先来定义一些参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static pthread_introspection_hook_t original_pthread_introspection_hook_t = NULL;<br><br>/// 创建信号量<br>static dispatch_semaphore_t semaphore;<br><br>/// 线程总数<br>static int threadCount = 0;<br><br>/// 是否开启监控<br>static bool isMonitor = false;<br><br>/// 线程总数阈值<br>static int averageThreadCount = 40;<br><br>/// 线程在一定时间内新增数<br>static int newThreadCount = 0;<br><br>/// 线程在一定时间内新增阈值<br>static int newAverageThreadCount = 10;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 开启监控<br>+ (void)startMonitor&#123;<br>    // 创建信号量 最大并发数为1<br>    semaphore = dispatch_semaphore_create(1);<br>    // 等待<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <br>    mach_msg_type_number_t count;<br>    thread_act_array_t threads;<br>    // 获取到count<br>    task_threads(mach_task_self(), &amp;threads, &amp;count);<br>   <br>    // 保证加锁的时候，线程数量不变<br>    threadCount = count;<br>    <br>    // 添加🪝钩子函数<br>    original_pthread_introspection_hook_t = pthread_introspection_hook_install(kry_pthread_introspection_hook_t);<br>    <br>    // 解锁 信号量+1<br>    dispatch_semaphore_signal(semaphore);<br>    <br>    // 开始监控<br>    isMonitor = true;<br>    <br>    <br>    // 开启一个定时器 检测每秒线程创建 然后通过clearNewThreadCount置位0<br>    const char *queenIdentifier = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);<br>    if (queenIdentifier == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>    &#125;else&#123;<br>        dispatch_async(dispatch_get_main_queue(), ^&#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>        &#125;);<br>    &#125;<br>&#125;<br><br>// 当前线程总数<br>+ (int)currentThreadCount&#123;<br>    return threadCount;<br>&#125;<br><br>void kry_pthread_introspection_hook_t(unsigned int event,<br>                                      pthread_t thread, void *addr, size_t size)&#123;<br>    <br>    // 正常调用原有逻辑<br>    if (original_pthread_introspection_hook_t) &#123;<br>        original_pthread_introspection_hook_t(event,thread,addr,size);<br>    &#125;<br>    <br>    // 开始记录<br>    <br>    // 如果是创建线程,则线程的数量+1，新增数+1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) &#123;<br>        threadCount +=1;<br>        if (isMonitor &amp;&amp; threadCount &gt; averageThreadCount) &#123;<br>            // 总数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(false, 0);<br>        &#125;<br>        <br>        newThreadCount +=1;<br>        if (isMonitor &amp;&amp; newThreadCount &gt; newAverageThreadCount) &#123;<br>            // 新增数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(true, newThreadCount);<br>        &#125;<br>    &#125;<br>    <br>    <br>    // 销毁线程，则线程数量-1，新增数-1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_DESTROY) &#123;<br>        threadCount -=1;<br>       <br>        if (newThreadCount &gt; 0 ) &#123;<br>            newThreadCount -=1;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><br>void kry_Log_CallStack(bool isIncreaseLog, int num)<br>&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    if (isIncreaseLog) &#123;<br>        printf(&quot;\n🔥一秒钟开启 %d 条线程！！！！\n&quot;, num);<br>    &#125;<br>    // 可以记录堆栈信息<br>    dispatch_semaphore_signal(semaphore);<br>&#125;<br><br>+ (void)clearNewThreadCount&#123;<br>    newThreadCount = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，都有注释，近期在看PCL的堆栈记录，后期会把堆栈记录完善上去</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.jianshu.com/p/95df83780c8f">APP性能检测方案汇总</a></p><p><a href="https://juejin.cn/post/6844904122248855560">iOS线程数量监控工具</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-自定义Section延迟load加载</title>
    <link href="/2021/07/01/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89Section%E5%BB%B6%E8%BF%9Fload%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/07/01/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89Section%E5%BB%B6%E8%BF%9Fload%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="在指定的segment和section中存入数据"><a href="#在指定的segment和section中存入数据" class="headerlink" title="在指定的segment和section中存入数据"></a>在指定的segment和section中存入数据</h4><p>之前我们已经了解过<code>machO</code>的结构了，那么我们有没有办法去修改或者新增<code>segment</code>和<code>section</code>当中的数据呢，答案是可以的，使用<code>__attribute__ section</code>将指定的数据存储到指定的<code>segmemt</code>和<code>section</code>中，也可以在通过在<code>Build Settings</code>中的<code>Other Linker Flags</code>设置链接参数，从而达到移动段，新增段，赋予权限等操作</p><h4 id="attribute-的用法"><a href="#attribute-的用法" class="headerlink" title=" __attribute__的用法"></a><code> __attribute__</code>的用法</h4><p><code>__attribute__</code> 可以用来设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）</p><ul><li><code>__attribute__((format()))</code> 按照指定格式进行参数检查。</li></ul><hr><ul><li><code>__attribute__((__always_inline__))</code> 强制内联。</li></ul><hr><ul><li><code>__attribute__((deprecated(&quot;Use xxx: instead&quot;)</code> 这个可能是我们见的比较多的，用来标记某个方法已经被废弃了，需要用其它的方法代替。</li></ul><hr><ul><li><code>__attribute__((__unused__))</code> 标记函数或变量可能不会用到。</li></ul><hr><ul><li><p><code>__attribute__((visibility(&quot;visibility_type&quot;)))</code> 标记动态库符号是否可见，有以下取值：</p><pre><code class="hljs">   1.  `default` 符号可见，可导出。          2.  `hidden` 符号隐藏，不可导出，只能在本动态库内调用。</code></pre></li></ul><hr><ul><li><code>__attribute__((objc_designated_initializer))</code> 明确指定用于初始化的方法。一个优秀的设计，初始化接口可以有多个，但最终多个初始化初始化接口都会调用 <code>designed initializer</code> 方法。</li></ul><hr><ul><li><code>__attribute__((unavailable))</code>、<code>__attribute__((unavailable(&quot;Must use xxx: instead.&quot;)));</code> 标记方法被禁用，不能直接调用，但这并不意味着该方法不能被调用，在 Objective-C 中使用 runtime 依然可以调用。</li></ul><hr><ul><li><code>__attribute__((section(&quot;segment,section&quot;)))</code> 将一个指定的数据储存到我们需要的 segment 和 section 中。</li></ul><hr><ul><li><code>__attribute__((constructor))</code> 被 <code>attribute((constructor))</code> 标记的函数，会在 <code>main</code> 函数之前或动态库加载时执行。在 mach-o 中，被 <code>attribute((constructor))</code> 标记的函数会在 <code>_DATA</code> 段的 <code>__mod_init_func</code> 区中。当多个被标记 <code>attribute((constructor))</code> 的方法想要有顺序的执行，怎么办？<code>attribute((constructor))</code> 是支持优先级的：<code>_attribute((constructor(1)))</code></li></ul><hr><ul><li><code>__attribute__((destructor))</code> 和 <code>attribute((constructor))</code> 相反：被 <code>attribute((destructor))</code> 标记的函数，会在 <code>main</code> 函数退出或动态库卸载时执行。在 mach-o 中此类函数会放在 <code>_DATA</code> 段的 <code>__mod_term_func</code> 区中</li></ul><p>… 还有很多 这里就不一一列举了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span>&#123;<br>    <span class="hljs-type">char</span> *className;<br>    <span class="hljs-type">char</span> *method;<br>&#125;;<br><br> <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JYProtocolRegister(_className_,_method_)\</span><br><span class="hljs-meta">__attribute__((used)) static struct JYProtocolInfo JYProtocolInfo##_className_ \</span><br><span class="hljs-meta">__attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,JYLoadDelayData&quot;</span>))) =\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">    .className = #_className_,\</span><br><span class="hljs-meta">    .method = #_method_,\</span><br><span class="hljs-meta">&#125;;</span><br><br><br>@interface JYLoadDelayTool : NSObject<br><br>+ (<span class="hljs-type">void</span>)readDataFromMachO;<br><br>+ (<span class="hljs-type">void</span>)xxx;<br><br>@end<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">JYProtocolRegister</span>(JYLoadDelayTool,xxx)<br><br>+ (<span class="hljs-type">void</span>)xxx&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;123&quot;</span>);<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)readDataFromMachO &#123;<br>   <br>     Dl_info info;<br>     <span class="hljs-built_in">dladdr</span>((__bridge <span class="hljs-type">void</span> *)[self <span class="hljs-keyword">class</span>], &amp;info);<br><br>    <span class="hljs-comment">// 读取__DATA中自定义的ProtocolInfoDataz数据</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LP64__</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header</span> *mhp = (<span class="hljs-keyword">struct</span> mach_header*)info.dli_fbase;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint32_t</span> *schemeMemory = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-built_in">getsectiondata</span>(mhp, <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;JYLoadDelayData&quot;</span>, &amp;schemeSize);<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* defined(__LP64__) */</span></span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header_64</span> *mhp = (<span class="hljs-keyword">struct</span> mach_header_64*)info.dli_fbase;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint64_t</span> *schemeMemory = (<span class="hljs-type">uint64_t</span>*)<span class="hljs-built_in">getsectiondata</span>(mhp, <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;JYLoadDelayData&quot;</span>, &amp;schemeSize);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* defined(__LP64__) */</span></span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeCounter = schemeSize/<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> JYProtocolInfo);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span> *items = (<span class="hljs-keyword">struct</span> JYProtocolInfo*)schemeMemory;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; idx &lt; schemeCounter; ++idx)&#123;<br>        <br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span> * info = (<span class="hljs-keyword">struct</span> JYProtocolInfo*)&amp;items[idx];<br>        <br>        Class JYClass = <span class="hljs-built_in">NSClassFromString</span>([NSString stringWithUTF8String:info-&gt;className]);<br><br>        SEL sel = <span class="hljs-built_in">NSSelectorFromString</span>([NSString stringWithUTF8String:info-&gt;method]);<br>        <br>        <span class="hljs-built_in">id</span> (*func)(Class, SEL) = (<span class="hljs-built_in">id</span> (*)(Class, SEL))objc_msgSend;<br>       <br>        <span class="hljs-built_in">func</span>(JYClass, sel);<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>这样，可以把一些<code>+load</code>的方法都通过指定<code>JYProtocolRegister</code>来加载，这样可以优化启动时间，另外我们APM的监控，应该是最早的，这样在APP启动后的问题都能够检测到，如果<code>load</code>里面的方法有性能问题，而APM监控却是在<code>load</code>之后，那么就会检查不到，所以一些非必要性的<code>load</code>方法可以放在APM之后加载，通过上述方式</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://juejin.cn/post/6980545001126101005">iOS APP 启动优化(六)：在指定的 segment 和 section 中存入数据</a></p><p><a href="https://xiaozhuanlan.com/topic/9204153876">iOS开发之runtime（12）：深入 Mach-O</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-逆向防护</title>
    <link href="/2021/06/01/iOS-%E9%80%86%E5%90%91%E9%98%B2%E6%8A%A4/"/>
    <url>/2021/06/01/iOS-%E9%80%86%E5%90%91%E9%98%B2%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="MethodSwizzle"><a href="#MethodSwizzle" class="headerlink" title="**MethodSwizzle **"></a>**MethodSwizzle **</h3><ul><li>利用OC的运行时（Runtime）特性修改 <code>SEL</code> 和 <code>IMP(函数指针)</code> 的关系，打到Hook OC方法的目的</li><li><code>method_exchangeIMP</code>交换两个 <code>IMP</code></li><li><code>class_replaceMethod</code>替换某个 <code>SEL</code>的 <code>IMP</code> （如果没有该方法就添加，相当于换掉这个方法）</li><li><code>method_getImplementation</code> 、<code>method_setImplementation</code> 获取和设置某个方法的IMP （很多第三方框架都使用）</li></ul><hr><h3 id="MonKey-Hook"><a href="#MonKey-Hook" class="headerlink" title="MonKey Hook"></a>MonKey Hook</h3><p>Monkey中使用了  <code>libsubstrate.dylib</code></p><ul><li><code>method_setImplementation</code></li><li><code>method_getImplementation</code></li></ul><h4 id="MonKey已经替换的系统函数"><a href="#MonKey已经替换的系统函数" class="headerlink" title="MonKey已经替换的系统函数"></a><strong>MonKey已经替换的系统函数</strong></h4><ul><li>dlsym </li><li>sysctl</li><li>ptrace</li></ul><hr><h3 id="Dobby-（修改静态函数-C-和-swift）"><a href="#Dobby-（修改静态函数-C-和-swift）" class="headerlink" title="Dobby （修改静态函数 C 和 swift）"></a>Dobby （修改静态函数 C 和 swift）</h3><ul><li>实际上是替换 <code>Text段</code>   </li><li>动态修改 （加载到内存的时候修改）</li></ul><hr><h3 id="防护-：lldb-ptrace"><a href="#防护-：lldb-ptrace" class="headerlink" title="防护 ：lldb - ptrace"></a>防护 ：<code>lldb - ptrace</code></h3><ul><li><code>ptrace</code> 是 命令行工程以及 Mac OS 工程里的 <code>&lt;sys/ptrace.h&gt;</code>提供的一个函数 , 可以用来来控制进程附加管理 , 它可以实现禁止应用程序进程被附加的效果 . 在 iOS 中并没有暴露出来 , 但是 iOS 是可以使用的 .</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> arg1: ptrace要做的事情: PT_DENY_ATTACH 表示要控制的是当前进程不允许被附加</span><br><span class="hljs-comment"> arg2: 要操作进程的PID , 0就代表自己</span><br><span class="hljs-comment"> arg3: 地址 取决于第一个参数要做的处理不同传递不同</span><br><span class="hljs-comment"> arg4: 数据 取决于第一个参数要做的处理不同传递不同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ptrace</span>(PT_DENY_ATTACH, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li><p>效果：</p><ul><li>运行工程 , 程序闪退 .</li><li>从手机点开应用 , 应用正常 .</li><li>使用Xcode 自带的 Debug - Attach to process 发现附加失败</li></ul></li><li><p>破解：</p><ul><li>通过符号断点检测</li><li>使用 <code>fishhook</code>  HOOK掉ptrace这个函数</li></ul></li></ul><hr><h3 id="防护：-sysctl"><a href="#防护：-sysctl" class="headerlink" title="防护： sysctl"></a>防护： sysctl</h3><ul><li><code>sysctl ( system control )</code> 是由 <code>&lt;sys/sysctl.h&gt;</code> 提供的一个函数 , 它有很多作用 , 其中一个是可以监测当前进程有没有被附加 . 但是因为其特性 , 只是监测当前时刻应用有没有被附加 .</li><li>因此正向开发中我们往往结合定时器一起使用 , 或者 定时 &#x2F; 定期 &#x2F; 在特定时期 去使用 .</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#import <span class="hljs-string">&quot;ViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;sys/sysctl.h&gt;</span></span><br>@<span class="hljs-function">interface <span class="hljs-title">ViewController</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">@end</span><br><span class="hljs-function"></span><br><span class="hljs-function">@implementation ViewController</span><br><span class="hljs-function">BOOL <span class="hljs-title">isDebug</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> name[<span class="hljs-number">4</span>];             <span class="hljs-comment">//里面放字节码。查询的信息</span><br>    name[<span class="hljs-number">0</span>] = CTL_KERN;      <span class="hljs-comment">//内核查询</span><br>    name[<span class="hljs-number">1</span>] = KERN_PROC;     <span class="hljs-comment">//查询进程</span><br>    name[<span class="hljs-number">2</span>] = KERN_PROC_PID; <span class="hljs-comment">//传递的参数是进程的ID</span><br>    name[<span class="hljs-number">3</span>] = <span class="hljs-built_in">getpid</span>();      <span class="hljs-comment">//获取当前进程ID</span><br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> info;  <span class="hljs-comment">//接受查询结果的结构体</span><br>    <span class="hljs-type">size_t</span> info_size = <span class="hljs-built_in">sizeof</span>(info);  <span class="hljs-comment">//结构体大小</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sysctl</span>(name, <span class="hljs-number">4</span>, &amp;info, &amp;info_size, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))&#123;<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;查询失败&quot;</span>);<br>        <span class="hljs-keyword">return</span> NO;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    查询结果看info.kp_proc.p_flag 的第12位。如果为1，表示调试状态。</span><br><span class="hljs-comment">    (info.kp_proc.p_flag &amp; P_TRACED) 就是0x800, 即可获取第12位</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> ((info.kp_proc.p_flag &amp; P_TRACED) != <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">dispatch_source_t</span> timer;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debugCheck</span><span class="hljs-params">()</span></span>&#123;<br>    timer = <span class="hljs-built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">dispatch_get_global_queue</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">dispatch_source_set_timer</span>(timer, DISPATCH_TIME_NOW, <span class="hljs-number">1.0</span> * NSEC_PER_SEC, <span class="hljs-number">0.0</span> * NSEC_PER_SEC);<br>    <span class="hljs-built_in">dispatch_source_set_event_handler</span>(timer, ^&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDebug</span>()) &#123;<span class="hljs-comment">//在这里写你检测到调试要做的操作</span><br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;调试状态!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;正常！&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_resume</span>(timer);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    <span class="hljs-built_in">debugCheck</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>效果：</p><ul><li>可以上报或者 <code>exit</code></li></ul></li><li><p>破解：</p><ul><li>因为 <code>sysctl</code>函数也是系统函数，从而可以使用fishHook来交换</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">int</span>  (*sysctl_ptr)(<span class="hljs-type">int</span> *, u_int, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">my_sysctl</span><span class="hljs-params">(<span class="hljs-type">int</span> * name, u_int namelen, <span class="hljs-type">void</span> * info, <span class="hljs-type">size_t</span> * infoSize, <span class="hljs-type">void</span> * newInfo, <span class="hljs-type">size_t</span> newInfoSize)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>] == CTL_KERN &amp;&amp; name[<span class="hljs-number">1</span>] == KERN_PROC &amp;&amp; name[<span class="hljs-number">2</span>] == KERN_PROC_PID &amp;&amp; *infoSize == <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> kinfo_proc)) &#123;<br>        <br>        <span class="hljs-type">int</span> old = <span class="hljs-built_in">sysctl_ptr</span>(name,namelen,info,infoSize,newInfo,newInfoSize);<br>        <span class="hljs-comment">//拿出info</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> * myinfo = (<span class="hljs-keyword">struct</span> kinfo_proc *)info;<br>        <br>        <span class="hljs-keyword">if</span> ((myinfo-&gt;kp_proc.p_flag &amp; P_TRACED ) != <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">//使用异或取反</span><br>            myinfo-&gt;kp_proc.p_flag ^= P_TRACED;<br>        &#125;<br>        <span class="hljs-keyword">return</span> old;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sysctl_ptr</span>(name,namelen,info,infoSize,newInfo,newInfoSize);<br>&#125;<br><br>+(<span class="hljs-type">void</span>)load&#123;<br>  <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> rebingSysctl;<br>    rebingSysctl.name = <span class="hljs-string">&quot;sysctl&quot;</span>;<br>    rebingSysctl.replacement = my_sysctl;<br>    rebingSysctl.replaced = (<span class="hljs-type">void</span> *)&amp;sysctl_ptr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> rebs[<span class="hljs-number">1</span>] = &#123;rebingSysctl&#125;;<br>    <span class="hljs-built_in">rebind_symbols</span>(rebs, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：<ul><li>需要慎用 <code>exit</code> 函数</li><li>逆向中通过 <code>exit</code>  添加符号断点，就可以查看函数调用栈，从而可以看到调用 <code>exit</code>的函数地址，在减去首地址就可以拿到函数的偏移量，接着在 <code>Hopper</code> 当中就可以知道调用 <code>exit</code> 的地址了</li><li>我们自己开发所使用的 <code> framework</code> 会比注入的动态库更早的执行，虽然还是会被 <code>fishhook</code> 替换掉，但是可以在此之前，禁用掉 <code>fishhook</code> 或者完成检测</li><li>只不过如果破解人员找到这个 <code>framework</code> ，然后在 <code>load</code> 方法中直接 <code>Return</code></li></ul></li></ul><hr><hr><h3 id="防护：-通过函数地址直接调用-ptrace-和-sysctl"><a href="#防护：-通过函数地址直接调用-ptrace-和-sysctl" class="headerlink" title="防护： 通过函数地址直接调用 ptrace 和 sysctl"></a>防护： 通过函数地址直接调用 <code>ptrace</code> 和 <code>sysctl</code></h3><ul><li><p>在我工程开始我就获取 <code>ptrace / sysctl</code> 的地址 , 后面直接使用地址调用这个函数 . 实际上是可行的 , 利用 <code>dlsym</code>这个函数 .</p><ul><li>通过符号获取函数地址 ( dladdr 函数 ) </li><li>通过函数内部地址找到函数符号 ( dlsym 函数 )</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#import <span class="hljs-string">&quot;MyPtraceHeader.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callFunAddres</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> name[<span class="hljs-number">4</span>];             <span class="hljs-comment">//里面放字节码。查询的信息</span><br>    name[<span class="hljs-number">0</span>] = CTL_KERN;      <span class="hljs-comment">//内核查询</span><br>    name[<span class="hljs-number">1</span>] = KERN_PROC;     <span class="hljs-comment">//查询进程</span><br>    name[<span class="hljs-number">2</span>] = KERN_PROC_PID; <span class="hljs-comment">//传递的参数是进程的ID</span><br>    name[<span class="hljs-number">3</span>] = <span class="hljs-built_in">getpid</span>();      <span class="hljs-comment">//获取当前进程ID</span><br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> info;  <span class="hljs-comment">//接受查询结果的结构体</span><br>    <span class="hljs-type">size_t</span> info_size = <span class="hljs-built_in">sizeof</span>(info);  <span class="hljs-comment">//结构体大小</span><br>    <br>    <span class="hljs-comment">//这里做法是隐藏常量字符串</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[] = &#123;<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;s&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;y&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;s&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;c&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;t&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;l&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = str;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-keyword">while</span> (((*p) ^= <span class="hljs-string">&#x27;a&#x27;</span>) != <span class="hljs-string">&#x27;\0&#x27;</span>) p++;<br>    <br>    <span class="hljs-type">void</span> * handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;/usr/lib/system/libsystem_c.dylib&quot;</span>, RTLD_LAZY);<br><br>    <span class="hljs-built_in">int</span>  (*sysctl_ptr)(<span class="hljs-type">int</span> *, u_int, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>);<br>    <span class="hljs-comment">//获取sysctl函数指针</span><br>    sysctl_ptr = <span class="hljs-built_in">dlsym</span>(handle,(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)str);<br>    <span class="hljs-keyword">if</span> (sysctl_ptr) &#123;<br>        <br>        <span class="hljs-built_in">sysctl_ptr</span>(name, <span class="hljs-number">4</span>, &amp;info, &amp;info_size, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      <br>        <span class="hljs-keyword">if</span> ((info.kp_proc.p_flag &amp; P_TRACED ) != <span class="hljs-number">0</span> )&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;调试状态&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;正常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>破解 <ul><li>使用 <code>fishhook </code> 将  <code>dlopen</code> 与 <code>dlsym</code> 这两个系统函数干掉</li></ul></li></ul><hr><hr><h3 id="防护-汇编"><a href="#防护-汇编" class="headerlink" title="防护 汇编"></a>防护 汇编</h3><ul><li>使用汇编直接调用</li></ul><hr><hr><h3 id="字符串常量隐藏"><a href="#字符串常量隐藏" class="headerlink" title="字符串常量隐藏"></a>字符串常量隐藏</h3><ul><li>例如在App内注册第三方APP的Key,SecretKey等，字符串常量隐藏</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kWxAppID @<span class="hljs-string">&quot;krystal69d7xxxxxx&quot;</span>  </span><br> - (<span class="hljs-type">void</span>)configureForWXSDK&#123;<br>    [WXApi registerApp:kWxAppID<br>         universalLink:@<span class="hljs-string">&quot;123123&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>利用Hopper打开MachO就可以看到<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gslif4da10j31lw0egmze.jpg">  </p><ul><li>解决办法<ul><li>在方法中返回这个字符串</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KRYSTAL_ENCRYPT_KEY @<span class="hljs-string">&quot;krystal_key&quot;</span></span><br>@implementation ViewController<br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    <span class="hljs-comment">//使用函数代替字符串</span><br>    [self uploadDataWithKey:<span class="hljs-built_in">AES_KEY</span>()];  <br>&#125;<br><br>- (<span class="hljs-type">void</span>)uploadDataWithKey:(NSString *)key&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> NSString * <span class="hljs-title">AES_KEY</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[] = &#123;<br>        <span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> [NSString stringWithUTF8String:(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)key];<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><ul><li><p><strong>破解：</strong></p><ul><li>静态分析需要找到这个返回 <code> Key</code> 函数</li></ul></li><li><p><strong>升级防护</strong></p><ul><li>通过异或方式</li><li>这些字符不会进入字符常量区 . 编译器直接换算成异或结果 .<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING_ENCRYPT_KEY @<span class="hljs-string">&quot;demo_AES_key&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENCRYPT_KEY 0xAC</span><br>@<span class="hljs-function">interface <span class="hljs-title">ViewController</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">@end</span><br><span class="hljs-function"></span><br><span class="hljs-function">@implementation ViewController</span><br><span class="hljs-function">- <span class="hljs-params">(<span class="hljs-type">void</span>)</span>viewDidLoad </span>&#123;<br>    [super viewDidLoad];<br><span class="hljs-comment">//    [self uploadDataWithKey:STRING_ENCRYPT_KEY]; //使用宏/常量字符串</span><br>    [self uploadDataWithKey:<span class="hljs-built_in">AES_KEY</span>()]; <span class="hljs-comment">//使用函数代替字符串</span><br>&#125;<br><br>- (<span class="hljs-type">void</span>)uploadDataWithKey:(NSString *)key&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> NSString * <span class="hljs-title">AES_KEY</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[] = &#123;<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;d&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;e&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;m&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;o&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;_&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;A&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;E&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;S&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;_&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;\0&#x27;</span>),<br>    &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = key;<br>    <span class="hljs-keyword">while</span> (((*p) ^= ENCRYPT_KEY) != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [NSString stringWithUTF8String:(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)key];<br>&#125;<br>@end<br></code></pre></td></tr></table></figure></li></ul><ul><li><strong>效果：</strong><br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsm44y5b44j30o80ka76l.jpg"></li></ul></li></ul><hr><hr><hr><h3 id="动态库检测"><a href="#动态库检测" class="headerlink" title="动态库检测"></a>动态库检测</h3><ul><li><p>可以在服务器上存储一份 <code> _dyld_image_name</code></p></li><li><p>然后本地运行后获取到的上传服务器做比对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isExternalLibs&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-type">int</span> dyld_count = _dyld_image_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dyld_count; i++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * imageName = _dyld_get_image_name(i);<br>        NSString *res = [NSString stringWithUTF8String:imageName];<br>        <span class="hljs-keyword">if</span>([res hasPrefix:@<span class="hljs-string">&quot;/var/containers/Bundle/Application&quot;</span>])&#123;<br>            <span class="hljs-keyword">if</span>([res hasSuffix:@<span class="hljs-string">&quot;.dylib&quot;</span>])&#123;<br>                <span class="hljs-comment">//这边还需要过滤掉自己项目中本身有的动态库</span><br>                <span class="hljs-keyword">return</span> YES;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>破解：</strong> </p><ul><li>可以hook NSString的hasPrefix方法绕过检测</li></ul></li></ul><hr><hr><h3 id="防护-NSFileManager"><a href="#防护-NSFileManager" class="headerlink" title="防护  NSFileManager"></a>防护  NSFileManager</h3><ul><li>使用NSFileManager通过检测一些越狱后的关键文件&#x2F;路径是否可以访问来判断是否越狱 常见的文件&#x2F;路径有<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-type">static</span> <span class="hljs-type">char</span> *JailbrokenPathArr[] = &#123;<span class="hljs-string">&quot;/Applications/Cydia.app&quot;</span>,<br>                                     <span class="hljs-string">&quot;/usr/sbin/sshd&quot;</span>,<br>                                     <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>                                     <span class="hljs-string">&quot;/etc/apt&quot;</span>,<br>                                     <span class="hljs-string">&quot;/Library/MobileSubstrate&quot;</span>,<br>                                     <span class="hljs-string">&quot;/User/Applications/&quot;</span>&#125;; <br>      <br>      <br>+ (BOOL)isJailbroken1&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">if</span>([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:JailbrokenPathArr[i]]])&#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>破解<ul><li>攻击者可以通过hook NSFileManager的fileExistsAtPath方法来绕过检测<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//绕过使用NSFileManager判断特定文件是否存在的越狱检测，此时直接返回NO势必会影响程序中对这个方法的正常使用，因此可以先打印一下path，然后判断如果path是用来判断是否越狱则返回NO，否则按照正常逻辑返回</span><br>%hook NSFileManager<br>- (BOOL)fileExistsAtPath:(NSString *)path&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        NSString *jPath = [NSString stringWithUTF8String:JailbrokenPathArr[i]];<br>        <span class="hljs-keyword">if</span>([path isEqualToString:jPath])&#123;<br>            <span class="hljs-keyword">return</span> NO;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> %orig;<br>&#125;<br>%end<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><hr><h3 id="防护-stat-函数"><a href="#防护-stat-函数" class="headerlink" title="防护 stat 函数"></a>防护 <code>stat</code> 函数</h3><ul><li><p>使用C语言函数stat判断文件是否存在(注:stat函数用于获取对应文件信息，返回0则为获取成功，-1为获取失败)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isJailbroken2&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_info;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">stat</span>(JailbrokenPathArr[i], &amp;stat_info)) &#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;      <br></code></pre></td></tr></table></figure></li><li><p>破解：</p><ul><li>使用fishhook可hook C函数，fishhook通过在mac-o文件中查找并替换函数地址达到hook的目的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*orig_stat)</span><span class="hljs-params">(<span class="hljs-type">char</span> *c, <span class="hljs-keyword">struct</span> stat *s)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hook_stat</span><span class="hljs-params">(<span class="hljs-type">char</span> *c, <span class="hljs-keyword">struct</span> stat *s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-built_in">strcmp</span>(c, JailbrokenPathArr[i]))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">orig_stat</span>(c,s);<br>&#125;<br>+(<span class="hljs-type">void</span>)statHook&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> stat_rebinding = &#123;<span class="hljs-string">&quot;stat&quot;</span>, hook_stat, (<span class="hljs-type">void</span> *)&amp;orig_stat&#125;;<br>    <span class="hljs-built_in">rebind_symbols</span>((<span class="hljs-keyword">struct</span> rebinding[<span class="hljs-number">1</span>])&#123;stat_rebinding&#125;, <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure> 在动态库加载的时候，调用statHook    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"> %ctor&#123;<br>    [StatHook statHook];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>判断stat的来源是否来自于系统库，因为fishhook通过交换函数地址来实现hook，若hook了stat，则stat来源将指向攻击者注入的动态库中 因此我们可以完善上方的isJailbroken2判断规则，若stat来源非系统库，则直接返回已越狱      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isJailbroken2&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-type">int</span> ret ;<br>    Dl_info dylib_info;<br>    <span class="hljs-built_in">int</span> (*func_stat)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-keyword">struct</span> stat *) = stat;<br>    <span class="hljs-keyword">if</span> ((ret = <span class="hljs-built_in">dladdr</span>(func_stat, &amp;dylib_info))) &#123;<br>        NSString *fName = [NSString stringWithUTF8String:dylib_info.dli_fname];<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;fname--%@&quot;</span>,fName);<br>        <span class="hljs-keyword">if</span>(![fName isEqualToString:@<span class="hljs-string">&quot;/usr/lib/system/libsystem_kernel.dylib&quot;</span>])&#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_info;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">stat</span>(JailbrokenPathArr[i], &amp;stat_info)) &#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><hr><hr><hr><h3 id="BundleID检测"><a href="#BundleID检测" class="headerlink" title="BundleID检测"></a>BundleID检测</h3><ul><li>进行BundleID检测可以有效防止多开</li><li>获取当前项目的BundleID有多种方法，此处不再赘述，绕过检测则是hook对应的方法，返回原有的BundleID</li><li>防止攻击者绕过检测，可以在自行link的framework中获取BundleID并进行检测，以在被hook前进行校验<br> BundleID并进行校验以避免常见的BundleID获取方法被hook<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取Boundle ID</span><br><span class="hljs-type">char</span>  * bundleName =  getenv(<span class="hljs-string">&quot;XPC_SERVICE_NAME&quot;</span>);<br>    NSLog(@<span class="hljs-string">&quot;%s&quot;</span>,bundleName);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-夜间模式框架</title>
    <link href="/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>iOS夜间模式的适配，主要用到了<code>NSProxy</code>转发原理 ，其中JYDynamicColor继承于UIColor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColor : UIColor<br><br>@property (nonatomic, readonly) UIColor * lightColor;<br><br>@property (nonatomic, readonly) UIColor * darkColor;<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider;<br><br>@end<br></code></pre></td></tr></table></figure><p>  但是在.m文件中,我们实际将消息给了JYDynamicColorProxy处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYDynamicColor<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor &#123;<br>  return [self colorWithDynamicProvider:^(JYTraitCollection *traitCollection)&#123;<br>    return traitCollection.userInterfaceStyle == JYInterfaceStyleDark ? darkColor : lightColor;<br>  &#125;];<br>&#125;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * _Nonnull (^)(JYTraitCollection * _Nonnull))dynamicProvider &#123;<br>    <br>    return (JYDynamicColor *)[[JYDynamicColorProxy alloc] initWithDynamicProvider:dynamicProvider];<br>&#125;<br><br>- (UIColor *)lightColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>  return nil;<br>&#125;<br><br>- (UIColor *)darkColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>   return nil;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>接着看到<code>JYDynamicColorProxy</code>是继承于<code>NSProxy</code>，将所有的事件都转发到了<code>resolvedColor</code>，而<code>resolvedColor</code>是根据当前模式返回 <code>lightColor</code> 或者 <code>darkColor</code>,这样就实现了，对外其实是一个<code>UIColor</code>，但是实际上是一个<code>JYDynamicColorProxy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColorProxy : NSProxy &lt;NSCopying&gt;<br><br>@property (nonatomic, readonly) UIColor * resolvedColor;<br><br>@property (nonatomic, strong) UIColor *(^dynamicProvider)(JYTraitCollection *);<br><br>@end<br><br><br>@implementation JYDynamicColorProxy<br><br>- (instancetype)initWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider &#123;<br>  self.dynamicProvider = dynamicProvider;<br>  return self;<br>&#125;<br><br>// MARK: NSProxy - 转发消息 将消息全部转发到 resolvedColor<br>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;<br>  return [self.resolvedColor methodSignatureForSelector:sel];<br>&#125;<br><br>- (void)forwardInvocation:(NSInvocation *)invocation &#123;<br>  [invocation invokeWithTarget:self.resolvedColor];<br>&#125;<br><br>- (UIColor *)resolvedColor &#123;<br>  return [self resolvedColorWithTraitCollection:JYTraitCollection.overrideTraitCollection];<br>&#125;<br><br>- (UIColor *)resolvedColorWithTraitCollection:(JYTraitCollection *)traitCollection &#123;<br>    return self.dynamicProvider(traitCollection);<br>&#125;<br><br>// MARK: UIColor<br>- (UIColor *)colorWithAlphaComponent:(CGFloat)alpha &#123;<br>  return [JYDynamicColor colorWithDynamicProvider:^UIColor *(JYTraitCollection *traitCollection) &#123;<br>    return [self.dynamicProvider(traitCollection) colorWithAlphaComponent:alpha];<br>  &#125;];<br>&#125;<br><br>- (CGColorRef)CGColor &#123;<br>  return [[self resolvedColor] CGColor];<br>&#125;<br><br><br>// MARK: NSObject<br>- (BOOL)isKindOfClass:(Class)aClass &#123;<br>  static JYDynamicColor *dynamicColor = nil;<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^&#123;<br>    dynamicColor = [[JYDynamicColor alloc] init];<br>  &#125;);<br>  return [dynamicColor isKindOfClass:aClass];<br>&#125;<br><br>// MARK: NSCopying<br>- (id)copy &#123;<br>  return [self copyWithZone:nil];<br>&#125;<br><br>- (id)copyWithZone:(NSZone *)zone &#123;<br>  return [[JYDynamicColorProxy alloc] initWithDynamicProvider:[self.dynamicProvider copy]];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> iOS13以下，如果需要切换颜色，该如何刷新？<code>JYDynamicColorProxy</code>是如何存储颜色的呢？</p></blockquote><p>我们<code>swizzle</code>将设置颜色方法进行了hook，例如<code>@selector(setBackgroundColor:);</code>方法，将<code>backgroundColor</code>为<code>JYDynamicColor</code>的都进行处理</p><p>这里采用了关联对象的思想，写了一个<code>UIView</code>的分类,将<code>JYDynamicColorProxy</code>进行存储，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">...<br>@property (nullable, readonly) JYDynamicColor *jy_dynamicBackgroundColor;<br>...<br><br>- (JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>    return objc_getAssociatedObject(self, @selector(jy_dynamicBackgroundColor));<br>&#125;<br><br>- (void)setJy_dynamicBackgroundColor:(JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>  objc_setAssociatedObject(self,<br>                           @selector(jy_dynamicBackgroundColor),<br>                           jy_dynamicBackgroundColor,<br>                           OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br></code></pre></td></tr></table></figure><p>当修改当前模式的时候，我们将初始化拿到的<code>UIApplication</code>进行遍历，拿到<code>UIView</code>,然后调用分类当中的修改颜色方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jyTraitCollectionDidChange:(JYTraitCollection *)previousTraitCollection &#123;<br>  if (@available(iOS 13.0, *)) &#123;<br>    return;<br>  &#125;<br>    [self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull view, NSUInteger idx, BOOL * _Nonnull stop) &#123;<br>        [view jyTraitCollectionDidChange:previousTraitCollection];<br>     &#125;];<br>     <br>    [self setNeedsLayout];<br>    [self setNeedsDisplay];<br>#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_13_0<br>    [self jy_updateDynamicColors];<br>#endif<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jy_updateDynamicColors&#123;<br>    JYDynamicColor * backgroundColor = [self jy_dynamicBackgroundColor];<br>    if (backgroundColor) &#123;<br>        [self setBackgroundColor:backgroundColor];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过关联对象取到对应模式的Color,然后赋值即可，图片也是一样的原理</p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-渲染机制</title>
    <link href="/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="CALayer-与-UIView"><a href="#CALayer-与-UIView" class="headerlink" title="CALayer 与 UIView"></a>CALayer 与 UIView</h3><p>UIView拥有一个属性为<code>layer</code>和<code>layerClass</code>属性</p><ul><li><code>layer</code> 属性返回的是 <code>UIView</code> 所持有的主 <code>Layer(RootLayer)</code> 实例，我们可以通过其来设置 <code>UIView</code> 没有封装的一些 <code>layer</code> 属性；</li><li><code>layerClass</code> 则返回 <code>RootLayer</code> 所使用的类，我们可以通过重写该属性，来让 <code>UIView</code> 使用不同的 <code>CALayer</code> 来显示</li></ul><p><code>CALayer</code>继承自<code>NSObject</code>，负责图像渲染</p><p><code>UIView</code>继承自<code>UIResponder</code>，负责事件的响应</p><h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024844.png" alt="image-20190312112603570"></p><p>CPU和GPU通过总线连接，CPU中计算出的往往是<code>bitmap</code>位图，通过总线由合适的时机传递给GPU，GPU拿到位图后，渲染到帧缓存区<code>FrameBuffer</code>,然后由视频控制器根据<code>Vsync</code>信号在指定时间之前去帧缓冲区提取内容，显示到屏幕上。</p><p>CPU工作内容: </p><ol><li>layout（UI布局，文本计算）</li><li>display（绘制 drawRect）</li><li>prepare(图片解码)</li><li>commit（提交位图）</li></ol><p><code>GPU工作内容:</code> 顶点着色，图元装配，光栅化，片段着色，片段处理，最后提交帧缓冲区</p><h3 id="View绘制渲染机制和Runloop什么关系"><a href="#View绘制渲染机制和Runloop什么关系" class="headerlink" title="View绘制渲染机制和Runloop什么关系"></a>View绘制渲染机制和Runloop什么关系</h3><p>例如有以下 <code>UIView</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYView<br>- (void)drawRect:(CGRect)rect &#123;<br>    CGContextRef con = UIGraphicsGetCurrentContext();<br>    CGContextAddEllipseInRect(con, CGRectMake(0,0,100,200));<br>    CGContextSetRGBFillColor(con, 0, 0, 1, 1);<br>    CGContextFillPath(con);<br>&#125;<br>@end<br><br><br>@implementation ViewController<br><br>- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    JYView *view = [[JYView alloc] init];<br>    view.backgroundColor = [UIColor whiteColor];<br>    view.bounds = CGRectMake(0, 0, 100, 100);<br>    view.center = CGPointMake(100, 100);<br>    [self.view addSubview:view];<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>重写了 <code>UIView</code> 的 <code>DrawRect</code>方法.展现在屏幕前经历以下堆栈</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-03-093059.jpg" alt="img"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>当在操作 UI 时，比如改变了<code>Frame</code> 、更新了 <code>UIView/CALayer</code> 的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()<br>QuartzCore:CA::Transaction::observer_callback:<br>CA::Transaction::commit();<br>CA::Context::commit_transaction();<br>CA::Layer::layout_and_display_if_needed();<br>CA::Layer::layout_if_needed();<br>[CALayer layoutSublayers];<br>[UIView layoutSubviews];<br>CA::Layer::display_if_needed();<br>[CALayer display];<br>[UIView drawRect];<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-A4.png" alt="img"></p><h3 id="View布局与约束时机"><a href="#View布局与约束时机" class="headerlink" title="View布局与约束时机"></a>View布局与约束时机</h3><p>一个视图的布局指的是它在屏幕上的的大小和位置。每个 view 都有一个 frame 属性，用来表示在父 view 坐标系中的位置和具体的大小。<code>UIView</code> 给你提供了用来通知系统某个 view 布局发生变化的方法，也提供了在 view 布局重新计算后调用的可重写的方法。</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局:"></a>布局:</h4><p><strong>layoutSubviews()</strong></p><p>它负责给出当前 view 和每个子 view 的位置和大小。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。系统会在任何它需要重新计算视图的 frame 的时候调用这个方法，所以你应该在需要更新 frame 来重新定位或更改大小时重载它。然而你不应该在代码中显式调用这个方法。相反，有许多可以在 run loop 的不同时间点触发 <code>layoutSubviews</code> 调用的机制，这些触发机制比直接调用 <code>layoutSubviews</code> 的资源消耗要小得多。</p><p><strong>自动刷新触发器</strong></p><p>有许多事件会自动给视图打上 “update layout” 标记，因此 <code>layoutSubviews</code> 会在<strong>下一个周期中（重点！！！）</strong>被调用，而不需要开发者手动操作。这些自动通知系统 view 的布局发生变化的方式有：</p><ul><li>修改 view 的大小</li><li>新增 subview</li><li>用户在 <code>UIScrollView</code> 上滚动（<code>layoutSubviews</code> 会在 <code>UIScrollView</code> 和它的父 view 上被调用）</li><li>用户旋转设备</li><li>更新视图的 constraints</li></ul><p>这些方式都会告知系统 view 的位置需要被重新计算，继而会自动转化为一个最终的 <code>layoutSubviews</code> 调用。当然，也有直接触发 <code>layoutSubviews</code> 的方法。</p><p><strong>setNeedsLayout()</strong></p><p>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法。调用这个方法代表向系统表示视图的布局需要重新计算。<code>setNeedsLayout</code> 方法会立刻执行并返回，但在返回前不会真正更新视图。视图会在下一个 update cycle 中更新，就在系统调用视图们的 <code>layoutSubviews</code> 以及他们的所有子视图的 <code>layoutSubviews</code> 方法的时候。</p><p><strong>layoutIfNeeded()</strong></p><p><code>layoutIfNeeded</code> 是另一个会让 <code>UIView</code> 触发 <code>layoutSubviews</code> 的方法。 当视图需要更新的时候，与 <code>setNeedsLayout()</code> 会让视图在下一周期调用 <code>layoutSubviews</code> 更新视图不同，<code>layoutIfNeeded</code> 会立即调用 <code>layoutSubviews</code> 方法。但是如果你调用了 <code>layoutIfNeeded</code> 之后，并且没有任何操作向系统表明需要刷新视图，那么就不会调用 <code>layoutsubview</code>。如果你在同一个 run loop 内调用两次 <code>layoutIfNeeded</code>，并且两次之间没有更新视图，第二个调用同样不会触发 <code>layoutSubviews</code> 方法。</p><p>使用 <code>layoutIfNeeded</code>，则布局和重绘会立即发生并在函数返回之前完成（除非有正在运行中的动画）。这个方法在你需要依赖新布局，无法等到下一次 update cycle 的时候会比 <code>setNeedsLayout</code> 有用</p><p>当对希望通过修改 constraint 进行动画时，这个方法特别有用。你需要在 animation block 之前对 self.view 调用 <code>layoutIfNeeded</code>，以确保在动画开始之前传播所有的布局更新。在 animation block 中设置新 constrait 后，需要再次调用 <code>layoutIfNeeded</code> 来动画到新的状态。</p><p>(<strong>注:</strong> Masonry 动画需要这个)</p><h4 id="显示："><a href="#显示：" class="headerlink" title="显示："></a>显示：</h4><p>一个视图的显示包含了颜色、文本、图片和 Core Graphics 绘制等视图属性，不包括其本身和子视图的大小和位置。和布局的方法类似，显示也有触发更新的方法，它们由系统在检测到更新时被自动调用，或者我们可以手动调用直接刷新。</p><p><strong>setNeedsDisplay()</strong></p><p>这个方法类似于布局中的 <code>setNeedsLayout</code> 。它会给有内容更新的视图设置一个内部的标记，但在视图重绘之前就会返回。然后在下一个 update cycle 中，系统会遍历所有已标标记的视图，并调用它们的 <code>draw</code> 方法。</p><p>大部分时候，在视图中更新任何 UI 组件都会把相应的视图标记为“dirty”，通过设置视图“内部更新标记”，在下一次 update cycle 中就会重绘，而不需要显式的 <code>setNeedsDisplay</code> 调用</p><h4 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h4><p><strong>updateConstraints()</strong></p><p>这个方法用来在自动布局中动态改变视图约束。和布局中的 <code>layoutSubviews()</code> 方法或者显示中的 <code>draw</code> 方法类似，<code>updateConstraints()</code> 只应该被重载，<strong>绝不要在代码中显式地调用</strong>。通常你只应该在 <code>updateConstraints</code> 方法中实现必须要更新的约束。</p><p><strong>setNeedsUpdateConstraints()</strong></p><p>调用 <code>setNeedsUpdateConstraints()</code> 会保证在下一次更新周期中更新约束。它通过标记“update constraints”来触发 <code>updateConstraints()</code>。这个方法和 <code>setNeedsDisplay()</code> 以及 <code>setNeedsLayout()</code> 方法的工作机制类似。</p><p><strong>updateConstraintsIfNeeded()</strong></p><p>对于使用自动布局的视图来说，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 “update constraints”标记（可以被 <code>setNeedsUpdateConstraints</code> 或者 <code>invalidateInstrinsicContentSize</code>方法自动设置）。如果它认为这些约束需要被更新，它会立即触发 <code>updateConstraints()</code> ，<strong>而不会等到 RunLoop 的末尾。</strong></p><h3 id="UI-卡顿-列表卡顿、掉帧原理"><a href="#UI-卡顿-列表卡顿、掉帧原理" class="headerlink" title="UI 卡顿,列表卡顿、掉帧原理"></a>UI 卡顿,列表卡顿、掉帧原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024849.png" alt="image-20190312140156990"></p><p>iOS的 <code>mainRunloop</code>是一个60fps的回调，也就是说每16.7ms(VSync信号时间)会绘制一次屏幕，这个时间段内要完成view的缓冲区创建，view内容的绘制（如果重写了drawRect），这些CPU的工作。然后将这个缓冲区交给GPU渲染，这个过程又包括多个view的拼接(compositing)，纹理的渲染（Texture）等，最终显示在屏幕上。整个过程就是我们上面画的流程图。 因此，如果在16.7ms内完不成这些操作，比如，CPU做了太多的工作，或者view层次过于多，图片过于大，导致GPU压力太大，就会导致“卡”的现象，也就是丢帧.</p><blockquote><p>在规定的16.7ms内，在下一个VSync信号到来之前，CPU和GPU并没有共同完成下一帧视频的合成，就会出现掉帧、卡顿。</p></blockquote><h5 id="滑动优化方案思路："><a href="#滑动优化方案思路：" class="headerlink" title="滑动优化方案思路："></a>滑动优化方案思路：</h5><ul><li>CPU：<ul><li>对象的创建、调整、销毁可以放在子线程中去做ASDK；</li><li>预排班。布局计算、文本计算等事先放到子线程中去做；</li><li>使用轻量级对象，比如CALayer代替UIView</li><li>预渲染。文本等异步绘制，图片编解码等。</li><li>控制并发线程数量</li><li>减少重复计算布局，减少修改frame等</li><li>autolayout比frame更消耗资源</li><li>可以让图片的size跟frame一致</li></ul></li><li>GPU：<ul><li>纹理渲染。避免离屏渲染</li><li>视图混合。减少视图层级的复杂性，减少透明视图；不透明的opaque设置为YES</li><li>GPU能处理的最大纹理是4096 * 4096，一旦超过这个尺寸就会调用CPU进行资源处理，所以纹理尽量不要超过这个尺寸</li></ul></li></ul><h3 id="UIView的绘制原理"><a href="#UIView的绘制原理" class="headerlink" title="UIView的绘制原理"></a>UIView的绘制原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024854.png" alt="image-20190312141642996"></p><p><code>[UIView setNeedsDisplay]</code> 并没有发生当前视图立即绘制工作,打上需要重绘的脏标记，最后是在某个时机完成</p><p><code>[UIView setLayoutIfNeed]</code> 立即重新布局视图(下一个Runloop)</p><p><code>[view layouIfNeeded]</code> 当前RunLoop休眠前更新</p><p>当我们调用UIView的<code>setNeedsDisplay</code>的方法时候，会调用<code>layer</code>的同名方法，相当于在当前<code>layer</code>打上绘制标记，在当前<code>runloop</code>将要结束的时候，才会调用CALayer的<code>display</code>方法进入到真正的绘制当中。</p><p>CALayer的<code>display</code>方法中，首先会判断layer的delegate方法<code>displayLayer：</code>是否实现，如果代理没有响应这个方法，则进入到系统绘制流程；如果代理响应了这个方法，则进入到异步绘制流程</p><h3 id="系统绘制流程"><a href="#系统绘制流程" class="headerlink" title="系统绘制流程"></a>系统绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024857.png" alt="image-20190312142115333"></p><p>在CALayer内部，系统会创建一个backingStore（可以理解为CGContextRef，drawRect中取到的currentRef就是这个东西），然后layer回判断是否有delegate，如果没有代理，就调用CALayer的<code>drawInContext：</code>方法；如果有代理，则调用layer代理的<code>drawLayer:inContext:</code>方法，这一步发生在系统内部，然后在合适的时间给与我们回调一个熟悉的UIView的<code>drawRect：</code>方法。也就是在系统内部的绘制之上，允许我们再做一些额外的绘制。最后CALayer把backting store（位图）传给GPU。</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-07-23-134925.jpg" alt="15420320733034"></p><ol><li>首先一个视图由 CPU 进行 Frame 布局，准备视图和图层的层级关系，查询是否有重写 <code>drawRect:</code> 或 <code>drawLayer:inContext:</code>方法，<strong>注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</strong></li><li>CPU 会将处理视图和图层的层级关系打包，通过 IPC（内部处理通信）通道提交给渲染服务，渲染服务由 OpenGL ES 和 GPU 组成。</li><li>渲染服务首先将图层数据交给 OpenGL ES 进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧缓存的切换。</li><li>最后，将最终要显示在画面上的后帧缓存交给 GPU，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</li></ol><blockquote><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存，即GPU会预先渲染好一帧放入一个缓冲区内（前帧缓存），让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器（后帧缓存）。当你视频控制器已经读完一帧，准备读下一帧的时候，GPU会等待显示器的VSync信号发出后，前帧缓存和后帧缓存会瞬间切换，后帧缓存会变成新的前帧缓存，同时旧的前帧缓存会变成新的后帧缓存。</p></blockquote><h3 id="异步绘制流程"><a href="#异步绘制流程" class="headerlink" title="异步绘制流程"></a>异步绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024902.png" alt="image-20190312142425272"></p><p>layer的delegate如果实现了<code>displayLayer:</code>方法，就会进入到异步绘制的流程。在异步绘制的过程中，需要代理来生成对应的bitmap位图文件，并把此bitmap作为layer的contents属性</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024910.png" alt="image-20190312142514299"></p><h3 id="drawRect方法内为何第一行代码总要获取图形的上下文"><a href="#drawRect方法内为何第一行代码总要获取图形的上下文" class="headerlink" title="drawRect方法内为何第一行代码总要获取图形的上下文"></a>drawRect方法内为何第一行代码总要获取图形的上下文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">CGContextRef con = UIGraphicsGetCurrentContext();<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-082448.jpg" alt="img"></p><p>每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store 当UIView被绘制时（从 CA::Transaction::commit:以后），CPU执行drawRect，通过context将数据写入backing store 当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上 所以在 drawRect 方法中 要首先获取 context</p><h3 id="为什么要将图像渲染和事件响应这两个功能分开？"><a href="#为什么要将图像渲染和事件响应这两个功能分开？" class="headerlink" title="为什么要将图像渲染和事件响应这两个功能分开？"></a>为什么要将图像渲染和事件响应这两个功能分开？</h3><p>因为<code>CALayer</code>属于<code>QuartzCore</code>框架，<code>UIView</code>属于<code>UIKit</code>框架，</p><p><code>QuartzCore</code> 框架是可以跨平台使用的，但是<code>UIKit</code>框架只能在iOS中，在MacOs当中触摸是鼠标键盘，而iOS是触摸事件，遵循设计原则中的单一职责。</p><h3 id="CALayer为什么可以呈现可视化内容呢？"><a href="#CALayer为什么可以呈现可视化内容呢？" class="headerlink" title="CALayer为什么可以呈现可视化内容呢？"></a>CALayer为什么可以呈现可视化内容呢？</h3><p>CALayer包含一个<code>contents</code>属性,<code>CALayer</code> 中的 <code>contents</code> 属性保存了由设备渲染流水线渲染好的位图 <code>bitmap</code>（通常也被称为 <code>backing store</code>），而当设备屏幕进行刷新时，会从 <code>CALayer</code> 中读取生成好的 <code>bitmap</code>，进而呈现到屏幕上。CALayer的<code>contents</code>的值必须是<code>CGImage</code>。</p><h3 id="例如添加一个View-其底层做了什么操作？"><a href="#例如添加一个View-其底层做了什么操作？" class="headerlink" title="例如添加一个View,其底层做了什么操作？"></a>例如添加一个View,其底层做了什么操作？</h3><p><code>Core Animation</code> 会在APP启动时像 <code>Runloop</code> 注册一个 <code>Observer</code>，当事件到来的时候，<code>Runloop</code> 会被唤醒处理相关的业务逻辑（UIView 的创建，修改），将UI信息提交给<code>Render Server</code>,然后会等待<code>VSync</code>信号的到来，然后会通过<code>Metal</code>或者<code>OpenGLES</code>做一些绘制操作，然后把处理完的数据，纹理，顶点，着色器等提交给<code>GPU</code>，在下一个<code>VSync</code>信号到来的时候，视频控制器等读取帧缓冲区的数据显示到屏幕上。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><h3 id="界面掉帧是因为什么引起的？"><a href="#界面掉帧是因为什么引起的？" class="headerlink" title="界面掉帧是因为什么引起的？"></a>界面掉帧是因为什么引起的？</h3><p>掉帧是因为当在一个<code>Vsync</code>周期中，<code>CPU</code>或者<code>GPU</code>没有完成内容提交，那么这一帧就会被废弃掉，等待下一个<code>Vsync</code>的到来，而显示屏还会保持之前的内容不变，这也是界面卡顿的原因。</p><h3 id="CoreAnimation渲染流程？"><a href="#CoreAnimation渲染流程？" class="headerlink" title="CoreAnimation渲染流程？"></a>CoreAnimation渲染流程？</h3><p>首先收到事件的处理，例如布局改变</p><p>通过CPU完成显示内容计算，对APP图层进行打包，在下一次runloop时将描述好的 UI 信息以 <code>IPC</code> 的形式提供给<strong>系统常驻的 UI 绘制进程</strong>渲染服务RenderServer, </p><p>将收到的打包进行解码，执行metal相关程序，调用GPU</p><p>GPU完成对图像的渲染，最后显示到屏幕上</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzj6f3n9o3j20xc0hq406.jpg"></p><p><strong>但是如果重写了 <code>drawRect:</code> 方法，这个方法会直接调用 <code>Core Graphics</code> 绘制方法得到 <code>bitmap</code> 数据，同时系统会额外申请一块内存，用于暂存绘制好的 <code>bitmap</code>。</strong></p><p>由于重写了 <code>drawRect:</code> 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。</p><h3 id="离屏渲染指的是什么？"><a href="#离屏渲染指的是什么？" class="headerlink" title="离屏渲染指的是什么？"></a>离屏渲染指的是什么？</h3><p>我们知道<code>GPU</code>会将渲染完成后的结果放入<code>Frame Buffer</code>当中，但是如果<code>GPU</code>无法一次完成渲染工作，需要两，这时就需要一个额外的载体来保存第一次的结果，而这个载体也就是离屏渲染缓冲区。</p><p>离屏渲染会创建新的缓冲区，增加额外的空间，大量的离屏渲染可能造成内存的过大压力。</p><p>离屏渲染的过程中，会进行两次上下文的切换，先切换到屏幕外，离屏渲染完成后再切回当前屏幕。</p><h3 id="所有的离屏渲染都是坏的吗？"><a href="#所有的离屏渲染都是坏的吗？" class="headerlink" title="所有的离屏渲染都是坏的吗？"></a>所有的离屏渲染都是坏的吗？</h3><p>我们可以利用开启<code>CALayer</code>的<code>shouldRasterize</code>属性去触发离屏渲染。开启之后，<code>Render Server</code> 会强制将 <code>CALayer 的渲染位图结果</code>bitmap&#96; 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。</p><p>保存的 <code>bitmap</code> 包含 <code>layer</code> 的 <code>subLayer</code>、圆角、阴影、组透明度 <code>group opacity</code> 等，所以如果 <code>layer</code> 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。<strong>其主旨在于降低性能损失，但总是至少会触发一次离屏渲染。</strong></p><blockquote><p>圆角、阴影、组透明度等会由系统自动触发离屏渲染，那么打开光栅化就可以节约第二次及以后的渲染时间。而多层 subLayer 的情况由于不会自动触发离屏渲染，所以相比之下会多花费第一次离屏渲染的时间，但是可以节约后续的重复渲染的开销。</p></blockquote><h3 id="哪些情况会触发离屏渲染？"><a href="#哪些情况会触发离屏渲染？" class="headerlink" title="哪些情况会触发离屏渲染？"></a>哪些情况会触发离屏渲染？</h3><ul><li>使用了 <code>mask</code> 的 <code>layer (layer.mask)</code>；</li><li>添加了投影的<code> layer (layer.shadow*，表示相关的 shadow 开头的属性)</code></li><li>设置了组透明度为 YES，并且透明度不为 1 的<code>layer (layer.allowsGroupOpacity/layer.opacity)</code></li><li>采用了光栅化的 <code>layer (layer.shouldRasterize)</code></li><li>绘制了文字的 <code>layer (UILabel, CATextLayer, Core Text 等)</code></li><li>需要进行裁剪的<code> layer (layer.masksToBounds / view.clipsToBounds)</code></li></ul><p>总结一下，iOS 9 之后圆角造成离屏渲染的条件包括：</p><ul><li>圆角</li><li>裁剪</li><li><code>layer</code> 的<code>contents</code>不为 <code>nil</code></li><li>设置了背景色 &#x2F; 边框 &#x2F; 其他有图像内容的图层</li></ul><h3 id="知识点问题梳理"><a href="#知识点问题梳理" class="headerlink" title="知识点问题梳理"></a>知识点问题梳理</h3><ul><li><p>图像显示的原理</p></li><li><p>layoutSubviews()&#x2F;setNeedsLayout()&#x2F;layoutIfNeeded()三者之间的区别？</p></li><li><p>setNeedsDisplay()有什么作用？</p></li><li><p>界面掉帧是因为什么引起的？</p></li><li><p>离屏渲染是什么?所有的离屏渲染都是坏的吗？哪些情况会触发离屏渲染？</p></li><li><p>异步绘制的流程</p></li><li><p>drawRect方法在什么时候调用？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-Runloop</title>
    <link href="/2021/03/01/iOS-Runloop/"/>
    <url>/2021/03/01/iOS-Runloop/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><ul><li>Run loops是线程相关的的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比 如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</li></ul><h3 id="runloop和线程的关系"><a href="#runloop和线程的关系" class="headerlink" title="runloop和线程的关系"></a>runloop和线程的关系</h3><ul><li>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。</li><li>子线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。</li><li>子线程中，RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。</li><li>你只能在一个线程的内部获取其 RunLoop（主线程除外）。</li></ul><h3 id="runloop的接口"><a href="#runloop的接口" class="headerlink" title="runloop的接口"></a>runloop的接口</h3><ul><li>CFRunLoopRef<ul><li>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source&#x2F;Timer&#x2F;Observer，让其互不影响</li></ul></li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef<ul><li>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。<ul><li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li><li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li></ul></li></ul></li><li>CFRunLoopTimerRef<ul><li>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</li></ul></li><li>CFRunLoopObserverRef<ul><li>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</li></ul></li></ul><h3 id="runloop的mode"><a href="#runloop的mode" class="headerlink" title="runloop的mode"></a>runloop的mode</h3><ul><li>kCFRunLoopDefaultMode&#x2F;NSDefaultRunLoopMode<ul><li>App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li></ul></li><li>UITrackingRunLoopMode<ul><li>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li></ul></li><li>UIInitializationRunLoopMode<ul><li>在刚启动App时第进入的第一个Mode，启动完成后就不再使用</li></ul></li><li>GSEventReceiveRunLoopMode<ul><li>接受系统事件的内部Mode，通常用不到</li></ul></li><li>kCFRunLoopCommonModes&#x2F;NSRunLoopCommonModes<ul><li>组合状态，这是一个占位的 Mode，没有实际作用。</li></ul></li></ul><h3 id="runloop内部逻辑"><a href="#runloop内部逻辑" class="headerlink" title="runloop内部逻辑"></a>runloop内部逻辑</h3><p><img src="http://blog.qiji.tech/wp-content/uploads/2016/04/RunLoop_1.png" alt="image"></p><ul><li>1、通知Observer：即将进入Loop</li><li>2、通知Observer：将要处理Timer</li><li>3、通知Observer：将要处理Source0</li><li>4、处理Source0</li><li>5、如果有Source1，跳到第9步</li><li>6、通知Observer：线程即将休眠</li><li>7、休眠，等待唤醒</li><li>8、通知Observer：线程刚被唤醒</li><li>9、处理唤醒时收到的消息，之后跳回2</li><li>10、通知Observer：即将退出Loop</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs scss">&#123;<br>    <span class="hljs-comment">/// 1. 通知Observers，即将进入RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopEntry);<br>    do &#123;<br> <br>        <span class="hljs-comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeTimers);<br>        <span class="hljs-comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeSources);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 4. 触发 Source0 (非基于port的) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>(source0);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 6. 通知Observers，即将进入休眠</span><br>        <span class="hljs-comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeWaiting);<br> <br>        <span class="hljs-comment">/// 7. sleep to wait msg.</span><br>        <span class="hljs-built_in">mach_msg</span>() -&gt; <span class="hljs-built_in">mach_msg_trap</span>();<br>        <br> <br>        <span class="hljs-comment">/// 8. 通知Observers，线程被唤醒</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopAfterWaiting);<br> <br>        <span class="hljs-comment">/// 9. 如果是被Timer唤醒的，回调Timer</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>(timer);<br> <br>        <span class="hljs-comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(dispatched_block);<br> <br>        <span class="hljs-comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>(source1);<br> <br> <br>    &#125; while (...);<br> <br>    <span class="hljs-comment">/// 10. 通知Observers，即将退出RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopExit);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><h3 id="runloop什么时候退出"><a href="#runloop什么时候退出" class="headerlink" title="runloop什么时候退出"></a>runloop什么时候退出</h3><ul><li>1、超过设定的超时</li><li>2、当前runloop中没有需要处理的timer、source</li><li>3、接收到exit信号</li></ul><h2 id="runloop在系统中的应用"><a href="#runloop在系统中的应用" class="headerlink" title="runloop在系统中的应用"></a>runloop在系统中的应用</h2><h3 id="1、AutoreleasePool"><a href="#1、AutoreleasePool" class="headerlink" title="1、AutoreleasePool"></a>1、AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="2、事件响应"><a href="#2、事件响应" class="headerlink" title="2、事件响应"></a>2、事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code></p><p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 <code>mach port</code> 转发给需要的App进程。随后苹果在APP内注册的 Source1 就会触发回调，并调用<code>_UIApplicationHandleEventQueue() </code>进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent </code>处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 <code>UIButton 点击、touchesBegin/Move/End/Cancel </code>事件都是在这个回调中完成的。</p><h3 id="3、手势识别"><a href="#3、手势识别" class="headerlink" title="3、手势识别"></a>3、手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue() </code>识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。</p><p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p><h3 id="4、界面更新"><a href="#4、界面更新" class="headerlink" title="4、界面更新"></a>4、界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h3 id="5、定时器"><a href="#5、定时器" class="headerlink" title="5、定时器"></a>5、定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="6、PerformSelecter"><a href="#6、PerformSelecter" class="headerlink" title="6、PerformSelecter"></a>6、PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="7、网络请求（现在的NSURLSession是否借助了runloop？）"><a href="#7、网络请求（现在的NSURLSession是否借助了runloop？）" class="headerlink" title="7、网络请求（现在的NSURLSession是否借助了runloop？）"></a>7、网络请求（现在的NSURLSession是否借助了runloop？）</h3><p>NSURLConnection 的工作过程也借助了runloop。使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="image"></p><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="你用runloop实现了什么"><a href="#你用runloop实现了什么" class="headerlink" title="你用runloop实现了什么"></a>你用runloop实现了什么</h2><h3 id="使用runloop开启一个常驻子线程"><a href="#使用runloop开启一个常驻子线程" class="headerlink" title="使用runloop开启一个常驻子线程"></a>使用runloop开启一个常驻子线程</h3><ul><li>AFNetworking2开启子线程，在后台线程接收 Delegate 回调  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">+ (<span class="hljs-type">void</span>)networkRequestThreadEntryPoint:(id)__unused object &#123;<br> <br>     @autoreleasepool &#123;<br>       [[NSThread currentThread] setName:@<span class="hljs-string">&quot;AFNetworking&quot;</span>];<br>       NSRunLoop *runLoop = [NSRunLoop currentRunLoop];<br>       [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>       [runLoop run];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>线上实时卡顿监控<ul><li>NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources（3. 通知 Observers: 即将触发 Source0回调）和kCFRunLoopBeforeWaiting（6. 通知Observers，即将进入休眠）之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿</li><li><a href="https://www.jianshu.com/p/890d1ba05f4c">iOS线上实时卡顿监控</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-动态库与静态库的区别</title>
    <link href="/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="静态库-Static-Library"><a href="#静态库-Static-Library" class="headerlink" title="静态库 (Static Library)"></a>静态库 (Static Library)</h3><ul><li><p>分发文件大</p></li><li><p>静态库默认仅将有用到的类文件<code>link</code>到<code>Mach-O</code>中(已类文件为最小链接单位)</p></li><li><p>ipa包小(为了APP瘦身，尽量将代码放静态库中) </p><ul><li>静态库中某个目标文件的代码没有被任何地方引用，则这个目标文件不会被链接到可执行文件中去(前提是不要使用<code>-Objc</code>和<code>-all_load</code>选项，分类代码经常被优化掉，一般都使用<code>-force_load</code>来处理静态库分类加载问题)</li></ul></li><li><p>APP冷启动速度快</p><ul><li>前提是不使用<code>动态库拆分</code>搭配<code>动态库懒加载方案</code></li><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个静态库只需要<code>rebase</code>和<code>bind</code>一次</li></ul></li><li><p>存在符号冲突可能</p></li><li><p>共享<code>TEXT段</code></p><ul><li>iOS9以前单个Mach-O的TEXT限制60M</li><li>iOS9以后单个Mach-O的TEXT限制500M</li></ul></li><li><p>不需要额外签名验证  </p></li><li><p>静态库符号的可见性可以在链接期间被修改 </p></li><li><p>文件格式多为<code>fat</code>格式的静态库文件</p></li><li><p>形式多为<code>.a</code>与<code>.framework</code></p></li><li><p>静态库不含<code>bitcode</code>时，引用静态库的目标部署时就不能包含<code>bitcode</code></p></li></ul><h3 id="动态库-Dynamic-Library"><a href="#动态库-Dynamic-Library" class="headerlink" title="动态库 (Dynamic Library)"></a>动态库 (Dynamic Library)</h3><ul><li><p>分发文件小</p></li><li><p>ipa包大  （前提是不考虑懒加载的情况）</p><ul><li>动态库会把整个<code>lib</code>复制进<code>ipa</code>中</li></ul></li><li><p>APP冷启动速度慢</p><ul><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个动态库只需要多次<code>rebase</code>和<code>bind</code></li></ul></li><li><p>需要设置合适的<code>runpath</code> </p></li><li><p>需要动态加载</p></li><li><p>需要签名且需要验证签名</p><ul><li>会检查<code>framework</code>的签名，签名中必须包含<code>TeamIdentifier</code>,并且<code>framework</code>和host APP的<code>TeamIdentifier</code>必须一致</li><li>Xcode重签命，保证动态库签名一致性</li></ul></li><li><p>需要导出符号</p></li><li><p>重复的<code>arch</code>结构</p></li><li><p>APP与动态库中重复代码可以共存，不会发生符号冲突</p><ul><li>因为可执行文件在构建链接阶段，遇到静态库则吸附进来，遇到动态库则打个标记，彼此保持独立性</li><li>对于来自动态库的符号，编译器会打个标记，交给<code>dyld</code>去加载和链接符号，也就是把链接的过程推迟到了运行时执行。（比如APP使用的是3.0版本SDK，动态库使用的是1.0版本SDK，能正常运行，但是会有风险）</li></ul></li><li><p>链接后需要包含分发大小</p></li><li><p>冷启动过程中，默认会在<code>main</code>函数之前加载</p><ul><li>默认情况下，过多的动态库会拖慢冷启动速度</li><li>如果采用懒加载动态库的形式，能够加快APP的启动速度,可以使用<code>dlopen</code>和<code>bundle</code>懒加载优化</li></ul></li><li><p>文件格式<code>Mach-O</code>（一个没有<code>main</code>函数的可执行文件）</p></li><li><p>动态库不包含<code>bitcode</code>时，引用动态库的目标部署时可以包含<code>bitcode</code></p></li><li><p><code>CocoaPods</code>从<code>v0.36.0</code>开始，可添加关键字<code>use_frameworks!</code>编译成类似<code>Embedded Framework</code>的结构（可以称之为<code>umbrella framework</code>）</p><ul><li>缺点：默认把项目的依赖全部改为动态库（可是使用<code>use_modular_headers!</code>,也可以在<code>podsepc</code>添加<code>s.static_framework = true</code>规避）</li><li><code>CocoaPods</code>执行脚本把动态库嵌入到<code>.app</code>的<code>Framework</code>目录下（相当于在<code>Embedded Binaries</code>加入动态库）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="简述OSI七层协议"><a href="#简述OSI七层协议" class="headerlink" title="简述OSI七层协议"></a>简述OSI七层协议</h3><ul><li>OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层</li></ul><hr><hr><h3 id="简述TCP-x2F-IP五层协议"><a href="#简述TCP-x2F-IP五层协议" class="headerlink" title="简述TCP&#x2F;IP五层协议"></a>简述TCP&#x2F;IP五层协议</h3><ul><li>TCP&#x2F;IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层</li></ul><hr><hr><h3 id="物理层有什么作用"><a href="#物理层有什么作用" class="headerlink" title="物理层有什么作用"></a>物理层有什么作用</h3><ul><li>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</li></ul><hr><hr><h3 id="数据链路层有什么作用"><a href="#数据链路层有什么作用" class="headerlink" title="数据链路层有什么作用"></a>数据链路层有什么作用</h3><ul><li>在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</li></ul><hr><hr><h3 id="网络层有什么作用"><a href="#网络层有什么作用" class="headerlink" title="网络层有什么作用"></a>网络层有什么作用</h3><ul><li>将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。</li></ul><hr><hr><h3 id="传输层有什么作用"><a href="#传输层有什么作用" class="headerlink" title="传输层有什么作用"></a>传输层有什么作用</h3><ul><li>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</li></ul><hr><hr><h3 id="会话层有什么作用"><a href="#会话层有什么作用" class="headerlink" title="会话层有什么作用"></a>会话层有什么作用</h3><ul><li>建立会话：身份验证，权限鉴定等；保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局；断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。</li></ul><hr><hr><h3 id="表示层有什么作用"><a href="#表示层有什么作用" class="headerlink" title="表示层有什么作用"></a>表示层有什么作用</h3><ul><li>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</li></ul><hr><hr><h3 id="应用层有什么作用"><a href="#应用层有什么作用" class="headerlink" title="应用层有什么作用"></a>应用层有什么作用</h3><ul><li>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。</li></ul><hr><hr><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><ul><li>TCP作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信 </li><li></li><li>UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播</li></ul><hr><hr><h3 id="为何TCP可靠"><a href="#为何TCP可靠" class="headerlink" title="为何TCP可靠"></a>为何TCP可靠</h3><ul><li>TCP有三次握手建立连接，四次挥手关闭连接的机制。除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。对于每份报文也存在校验，保证每份报文可靠性。</li></ul><hr><hr><h3 id="为何UDP不可靠"><a href="#为何UDP不可靠" class="headerlink" title="为何UDP不可靠"></a>为何UDP不可靠</h3><ul><li>UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。仅仅在IP数据报头部加入校验和复用。UDP没有服务器和客户端的概念。UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。</li></ul><hr><hr><h3 id="简述TCP粘包现象"><a href="#简述TCP粘包现象" class="headerlink" title="简述TCP粘包现象"></a>简述TCP粘包现象</h3><ul><li>TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。</li></ul><h3 id="TCP粘包现象处理方法"><a href="#TCP粘包现象处理方法" class="headerlink" title="TCP粘包现象处理方法"></a>TCP粘包现象处理方法</h3><ul><li>固定发送信息长度，或在两个信息之间加入分隔符。</li></ul><hr><hr><h3 id="简述TCP协议的滑动窗口"><a href="#简述TCP协议的滑动窗口" class="headerlink" title="简述TCP协议的滑动窗口"></a>简述TCP协议的滑动窗口</h3><ul><li>滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。</li></ul><h3 id="简述TCP协议的拥塞控制"><a href="#简述TCP协议的拥塞控制" class="headerlink" title="简述TCP协议的拥塞控制"></a>简述TCP协议的拥塞控制</h3><ul><li><p>拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.</p></li><li><p>当cwnd &lt; ssthresh 时，使用慢开始算法。当cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当cwnd &#x3D; ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。</p></li><li><p>慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。</p></li><li><p>拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。</p></li><li><p>快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。</p></li><li><p>快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。</p></li></ul><hr><hr><h3 id="简述快重传"><a href="#简述快重传" class="headerlink" title="简述快重传"></a>简述快重传</h3><ul><li>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。</li></ul><hr><hr><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><ul><li>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq&#x3D;x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。</li><li>第二次握手:服务端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack&#x3D;x+1,随机产生一个值seq&#x3D;y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</li><li>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack&#x3D;y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了</li></ul><hr><hr><h3 id="简述半连接队列"><a href="#简述半连接队列" class="headerlink" title="简述半连接队列"></a>简述半连接队列</h3><ul><li>TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</li></ul><hr><hr><h3 id="简述SYN攻击"><a href="#简述SYN攻击" class="headerlink" title="简述SYN攻击"></a>简述SYN攻击</h3><ul><li>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</li></ul><h4 id="优化方式："><a href="#优化方式：" class="headerlink" title="优化方式："></a>优化方式：</h4><ul><li>缩短SYN Timeout时间<br>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li></ul><hr><hr><h3 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h3><ul><li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。</li><li>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li><li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</li><li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</li></ul><hr><hr><h3 id="为什么TCP挥手需要4次"><a href="#为什么TCP挥手需要4次" class="headerlink" title="为什么TCP挥手需要4次"></a>为什么TCP挥手需要4次</h3><ul><li><p>主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。</p></li><li><p>所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。</p></li></ul><h3 id="为什么四次挥手释放连接时需要等待2MSL"><a href="#为什么四次挥手释放连接时需要等待2MSL" class="headerlink" title="为什么四次挥手释放连接时需要等待2MSL"></a>为什么四次挥手释放连接时需要等待2MSL</h3><ul><li>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</li></ul><hr><hr><h3 id="简述DNS协议"><a href="#简述DNS协议" class="headerlink" title="简述DNS协议"></a>简述DNS协议</h3><ul><li>DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</li></ul><h3 id="简述DNS解析过程"><a href="#简述DNS解析过程" class="headerlink" title="简述DNS解析过程"></a>简述DNS解析过程</h3><ol><li><p>客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器</p></li><li><p>本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找</p></li><li><p>本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器</p></li><li><p>根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址</p></li><li><p>客户机的dns服务器根据返回的信息接着访问下一级的dns服务器</p></li><li><p>这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息</p></li><li><p>客户机的本地的dns服务器会将查询结果返回给我们的客户机</p></li><li><p>客户机根据得到的ip信息访问目标主机，完成解析过程</p></li></ol><hr><hr><h3 id="简述HTTP协议"><a href="#简述HTTP协议" class="headerlink" title="简述HTTP协议"></a>简述HTTP协议</h3><ul><li>http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。</li></ul><hr><hr><h3 id="简述cookie"><a href="#简述cookie" class="headerlink" title="简述cookie"></a>简述cookie</h3><ul><li><p>HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p></li><li><p>Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。</p></li></ul><hr><hr><h3 id="简述session"><a href="#简述session" class="headerlink" title="简述session"></a>简述session</h3><ul><li>session用于标记特定客户端信息，存在在服务器的一个文件里。一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。</li></ul><h3 id="简述http状态码和对应的信息"><a href="#简述http状态码和对应的信息" class="headerlink" title="简述http状态码和对应的信息"></a>简述http状态码和对应的信息</h3><ul><li><p>1XX：接收的信息正在处理</p></li><li><p>2XX：请求正常处理完毕</p></li><li><p>3XX：重定向</p></li><li><p>4XX：客户端错误</p></li><li><p>5XX：服务端错误</p></li><li><p>常见错误码：301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到</p></li><li><p>转发和重定向的区别<br>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p></li><li><p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p></li></ul><hr><hr><ul><li><p>简述http1.0<br>规定了请求头和请求尾，响应头和响应尾（get post）</p></li><li><p>每一个请求都是一个单独的连接，做不到连接的复用</p></li></ul><hr><hr><h3 id="简述http1-1的改进"><a href="#简述http1-1的改进" class="headerlink" title="简述http1.1的改进"></a>简述http1.1的改进</h3><ul><li><p>HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</p></li><li><p>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p></li><li><p>服务端无法主动push</p></li></ul><hr><hr><h3 id="简述HTTP短连接与长连接区别"><a href="#简述HTTP短连接与长连接区别" class="headerlink" title="简述HTTP短连接与长连接区别"></a>简述HTTP短连接与长连接区别</h3><p>HTTP中的长连接短连接指HTTP底层TCP的连接。</p><ul><li><p>短连接：客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。</p></li><li><p>长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。</p></li></ul><hr><hr><h3 id="简述http2-0的改进"><a href="#简述http2-0的改进" class="headerlink" title="简述http2.0的改进"></a>简述http2.0的改进</h3><ul><li><p>提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。</p></li><li><p>引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。</p></li></ul><h3 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h3><ul><li>http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。</li></ul><hr><hr><h3 id="简述TLS-x2F-SSL-HTTP-HTTPS的关系"><a href="#简述TLS-x2F-SSL-HTTP-HTTPS的关系" class="headerlink" title="简述TLS&#x2F;SSL, HTTP, HTTPS的关系"></a>简述TLS&#x2F;SSL, HTTP, HTTPS的关系</h3><ul><li><p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。</p></li><li><p>可以将HTTPS协议简单理解为HTTP协议＋TLS&#x2F;SSL</p></li></ul><hr><hr><h3 id="https的连接过程"><a href="#https的连接过程" class="headerlink" title="https的连接过程"></a>https的连接过程</h3><ul><li><p>浏览器将支持的加密算法信息发给服务器<br>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器<br>客户端(SSL&#x2F;TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。<br>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器<br>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。<br>服务器将加密后的密文发送给客户端<br>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成<br>Get与Post区别<br>Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。</p></li><li><p>Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。</p></li><li><p>Get方法参数有大小限制吗<br>一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。</p></li></ul><h3 id="了解REST-API吗"><a href="#了解REST-API吗" class="headerlink" title="了解REST API吗"></a>了解REST API吗</h3><ul><li><p>REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：</p></li><li><p>Create ：POST<br>Read ：GET<br>Update ：PUT&#x2F;PATCH<br>Delete：DELETE<br>浏览器中输入一个网址后，具体发生了什么<br>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址<br>通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接<br>浏览器生成HTTP报文，发送HTTP请求，等待服务器响应<br>服务器处理请求，并返回给浏览器<br>根据HTTP是否开启长连接，进行TCP的挥手过程<br>浏览器根据收到的静态资源进行页面渲染</p></li></ul><hr><hr><h3 id="HTTPS相关"><a href="#HTTPS相关" class="headerlink" title="HTTPS相关"></a>HTTPS相关</h3><p>1）HTTPS 结合使用了 非对称加密算法，对称加密算法，hash算法，分别利用他们的优势，避免他们的缺点。利用非对称加密算法获得对称加密算法的秘钥，保证他的安全性；然后实际的网页内容的加密使用的是对称加密算法，利用了对称加密算法速度快的优势，hash算法主要是防止篡改的发生，是一种校验机制，最后数字证书，保证了服务器在将非对称加密算法的公钥传给浏览器时的安全性(不会被中间人篡改)，同时也标志了服务器的身份。</p><p>2）HTTPS的四大金刚：</p><p>非对称加密算法(对称加密算法的秘钥) + 对称加密算法(加密内容) + 数字证书(防止篡改非对称加密算法的公钥) + HASH算法(防止篡改消息)&#x3D;&#x3D; HTTPS</p><p>3）HTTPS的本质是什么？</p><p>HTTPS的本质就是在HTTP连接发起之前，先使用SSL&#x2F;TLS协议，协调客户端和服务端，在两端各自生产一个对称加密算法的秘钥，</p><p>然后使用普通的HTTP协议传输 经过对称加密算法加密的网页内容。因为对称加密算法的秘钥是安全的，所以对称加密算法加密的网页内容也是安全的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-同步方案（锁）</title>
    <link href="/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/"/>
    <url>/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>近期要写一个多线程工具，把之前学习的多线程，以及线程同步复习一下 </p><p>多线程的本质：有多条线程，但是只能执行一条，如果间隔时间设置的足够小，就给人的感觉是多条线程是同时进行的，时间片轮转调度算法</p><p>iOS中线程同步方案</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>Dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h4 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock - 自旋锁"></a>OSSpinLock - 自旋锁</h4><p> 等待锁🔐的线程会处于忙等状态，一直占用CPU资源</p><p>会出现优先级翻转的问题，如果线程之间的优先级不同，如果低优先级的锁先进来，把锁锁住，那么高优先级的线程进来就会一直忙等，但是系统又会分配时间资源给线程高的，从而导致低优先级的线程无法执行完自己的代码，从而导致优先级低的锁无法释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_SPINLOCK_INIT;<br>   <br>- (void)saleTicket&#123;<br>    /// 加锁<br>  OSSpinLockLock(&amp;_lock);<br>  //BOOL isLock =  OSSpinLockTry(&amp;_lock); <br>  int oldTicketsCount = self.ticketsCount;<br>  sleep(.2);<br>  oldTicketsCount--;<br>  self.ticketsCount = oldTicketsCount;<br>  NSLog(@&quot;还剩下%d张票 = %@&quot;,self.ticketsCount,[NSThread currentThread]);<br>  /// 解锁<br>  OSSpinLockUnlock(&amp;_lock);<br>&#125;<br>   <br></code></pre></td></tr></table></figure><hr><h4 id="os-unfair-lock-iOS10后支持-（本质是互斥锁）"><a href="#os-unfair-lock-iOS10后支持-（本质是互斥锁）" class="headerlink" title="os_unfair_lock - iOS10后支持 （本质是互斥锁）"></a>os_unfair_lock - iOS10后支持 （本质是互斥锁）</h4><p>用于替代<code>OSSpinLock</code> 的锁，使用的技术不再是忙等，而是休眠等待唤醒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_UNFAIR_LOCK_INIT;<br>- (void)saleTicket&#123;   <br>    /// 加锁<br>    os_unfair_lock_lock(&amp;_lock);<br>//  BOOL isLock = os_unfair_lock_trylock(&amp;lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    os_unfair_lock_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><p><code>mutex</code> 叫做”互斥锁”，等待锁的线程会处于休眠状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化属性    <br>pthread_mutexattr_t attr;<br>pthread_mutexattr_init(&amp;attr);<br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);<br>/// 初始化锁<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>//销毁属性 pthread_mutexattr_destroy(&amp;attr);<br>//销毁锁   pthread_mutex_destroy(&amp;_lock);<br><br>- (void)saleTicket&#123; <br>    /// 加锁<br>    pthread_mutex_lock(&amp;_lock);<br>    ///尝试 加锁<br>    //BOOL islock = pthread_mutex_trylock(&amp;_lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/*<br> * Mutex type attributes<br> */<br>#define PTHREAD_MUTEX_NORMAL0  //普通状态锁<br>#define PTHREAD_MUTEX_ERRORCHECK1<br>#define PTHREAD_MUTEX_RECURSIVE2  //用于处理递归锁<br>#define PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL<br><br></code></pre></td></tr></table></figure><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>递归锁：允许同一个线程对一把锁重复加锁</p><p>线程一 : 调用<code>saleTicket</code> (+🔐)</p><ul><li>调用<code>saleTicket</code> (+🔐)</li><li>调用<code>saleTicket</code> (+🔐)</li></ul><p> 线程二：调用<code>saleTicket</code> (发现已经被加锁了，等待) </p><p>当锁中间的代码遇到递归调用，打印的结果永远只有一条<code>saleTicket</code>，因为没有人能够走到解锁的那一步。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">- (void)saleTicket&#123;<br>    <span class="hljs-comment">/// 加锁</span><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;_lock);<br>    <span class="hljs-comment">///尝试 加锁</span><br>    <span class="hljs-comment">//BOOL islock = pthread_mutex_trylock(&amp;_lock);</span><br>    <span class="hljs-built_in">NSLog</span>(@&quot;%s&quot;,__func__);<br>    <span class="hljs-comment">// 卖票 递归调用</span><br>    <span class="hljs-selector-attr">[self saleTicket]</span>;<br>    <span class="hljs-comment">/// 解锁</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;_lock);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p> <code>pthread</code>是支持递归锁的，只需要把初始化属性改为递归锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxupqijd8nj30c205igme.jpg"></p><h5 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, assign) pthread_cond_t cond;<br><br>/// 初始化条件<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>// 销毁条件<br>pthread_cond_destroy(&amp;_cond);<br><br>[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil]start];<br>[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil]start];<br><br>- (void)__remove&#123;<br>   <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    if (self.dataArray.count == 0) &#123;<br>        //一旦进入等待状态，就会放开这把锁，直到别人发送信号唤醒<br>        pthread_cond_wait(&amp;_cond, &amp;_lock);<br>    &#125;<br>    [self.dataArray removeLastObject];<br>    NSLog(@&quot;删除了元素&quot;);<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br><br>- (void)__add&#123;<br>    <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    [self.dataArray addObject:@&quot;123&quot;];<br>    NSLog(@&quot;添加了元素&quot;);<br>     <br>    pthread_cond_signal(&amp;_cond);<br>    pthread_mutex_unlock(&amp;_lock);<br>    // 这里需要保证pthread_cond_signal在pthread_mutex_unlock之前<br>    // 如果在之后的话，锁解开了，发送信号的这个过程中有可能被别的锁抢先进来了<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h4 id="NSLock-x2F-NSRecursiveLock-x2F-NSCondition"><a href="#NSLock-x2F-NSRecursiveLock-x2F-NSCondition" class="headerlink" title="NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition"></a>NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition</h4><ul><li><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p></li><li><p><code>NSRecursiveLock</code> 是对<code>mutex</code>递归锁的封装</p></li><li><p><code>NSCondition</code> 是对<code>mutex</code>和<code>cont</code>的封装</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@protocol NSLocking<br><br>- (void)lock;<br>- (void)unlock;<br><br>@end<br><br>@interface NSLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (BOOL)tryLock; // 尝试加锁<br>- (BOOL)lockBeforeDate:(NSDate *)limit; //在这个时间之前等不到这个锁，都会睡眠<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br>@end<br></code></pre></td></tr></table></figure><p>可以查看GNUStep看到<code>NSLock</code>的实现</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxusubtzxlj30js0b8400.jpg"></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;<br><br>@property (readonly) NSInteger condition;<br>- (void)lockWhenCondition:(NSInteger)condition;<br>- (BOOL)tryLock;<br>- (BOOL)tryLockWhenCondition:(NSInteger)condition;<br>- (void)unlockWithCondition:(NSInteger)condition;<br>- (BOOL)lockBeforeDate:(NSDate *)limit;<br>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br><br>@end<br></code></pre></td></tr></table></figure><hr><h4 id="Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列"><a href="#Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列" class="headerlink" title="Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列"></a>Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列</h4><ul><li>串行队列，也可以实现线程同步，保证了每一条线程的操作都是按顺序的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">  @property (nonatomic, strong) dispatch_queue_t  queen;<br>  <br>  self.queen =  dispatch_queue_create(&quot;123&quot;, DISPATCH_QUEUE_SERIAL);<br>  <br>  - (void)test&#123;<br>    self.ticketsCount = 20;<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore - 信号量"></a>dispatch_semaphore - 信号量</h4><ul><li>信号量的初始值，可以用来控制线程的并发访问的最大数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, strong) dispatch_semaphore_t semaphore;<br>  // 设置最大并发数     <br> self.semaphore = dispatch_semaphore_create(1);<br>      <br>  for (int i = 0; i&lt;20; i++) &#123;<br>     [[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];<br>  &#125;<br>  <br>- (void)test&#123;    <br>    // 如果信号量的值&gt;0,就让信号量减1，然后继续执行下面的代码<br>    // 直到信号量的值&lt;=0的时候，就会休眠等待<br>    // DISPATCH_TIME_FOREVER永远 或者 设置成 DISPATCH_TIME_NOW现在立即<br>    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);<br>    self.ticketsCount--;<br>    sleep(2);<br>    NSLog(@&quot;剩下的票为 %d&quot;,self.ticketsCount);<br>    //让信号量的值+1<br>    dispatch_semaphore_signal(self.semaphore);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><ul><li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@synchronized (self) &#123; //objc_sync_enter<br>&#125; // objc_sync_exit<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">int objc_sync_enter(id obj)<br>&#123;<br>    int result = OBJC_SYNC_SUCCESS;<br><br>    if (obj) &#123;<br>        SyncData* data = id2data(obj, ACQUIRE);<br>        ASSERT(data);<br>        data-&gt;mutex.lock();<br>    &#125; else &#123;<br>        // @synchronized(nil) does nothing<br>        if (DebugNilSync) &#123;<br>            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);<br>        &#125;<br>        objc_sync_nil();<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>id2data</code> 方法内部</p><p>![image-20211229175537934](&#x2F;Users&#x2F;karthrine&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211229175537934.png)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxuusl6m2wj30cm01z74g.jpg"></p><p>内部是一个哈希表，把<code>obj</code>当做<code>key</code> ，<code>data-&gt;mutex.lock();</code> 拿到唯一的mutex锁，来加锁</p><hr><h4 id="自旋锁和互斥锁对比"><a href="#自旋锁和互斥锁对比" class="headerlink" title="自旋锁和互斥锁对比"></a>自旋锁和互斥锁对比</h4><p>什么情况下使用自旋锁比较划算？</p><ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发送</li><li>CPU资源不紧张</li><li>多核处理器</li></ul><p>什么情况下使用互斥锁比较划算？</p><ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>测试文章</title>
    <link href="/2019/04/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/"/>
    <url>/2019/04/17/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
